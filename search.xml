<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[翻译：保持你的代码洁净]]></title>
    <url>%2F2019%2F01%2F18%2Ftranslate-keeping-your-code-clean%2F</url>
    <content type="text"><![CDATA[原文链接 我在座位上安顿下来，与我的团队成员一起解决问题。我说”我们必须赢的这场比赛”。在两天内埋头开发一个工作原型，大家的好胜心都被激发，都在争夺前三名。 几分钟后，其中的一个高级工程师走到我的办公桌前，脸上露出一丝不满，喃喃自语：你的代码不清晰，很乱！这是我迈向clean code旅程的开始。 clean code？嗯，这对于我来说并不奇怪，但是如果代码正常工作，这真的很重要吗。是的，它确实很重要，一千次。 在这次活动之前，我曾担任几年的软件工程师。我已经构建了应用，但是我刚刚被告知了让我代码不一样的东西。 我的问题很简单：我专注于完成工作，目的是编写有效的代码，反过来又招致了技术债务。 clean code 的方式当你读完clean code的所有章节时，就不会发生这种情况。它需要知识和不断的实践，你必须学习原理，模式和实践。这是艰苦的工作需要数年，但你可以从今天开始。 无论你怎么去clean你的code，总有一件或两件你能学到的事情使code变得更干净。 学习的最佳方式之一是阅读专家的书籍或者帖子，你应该在你的twitter中有他们的推特流，听取他们的交谈，在github上follow他们，学习他们的代码是如何写和组织的。 Your growth is limited as an engineer if you do not constantly learn from experts in your field. 保持你的函数短小精悍这可能是1337篇文章中的一篇，来强调保持函数尽可能短，人们很容易在这里弄错。 clean code不仅仅是写短的方法，而是编写清晰表达意图的代码。 当一个函数太长了，这说明它做的太多了，阅读者可能会无法完全解读它的功能，一个函数应该做一件事。 if($order->contains($status){ //do something with order } function contains($status){ $order_statuses=['accepted','delivered','rejected','processed']; if (in_array($status, $order_statuses)) { return true; } return false; } 我们可以重写它来使contains更清楚： function contains($status){ return in_array($status, $this->config->statuses); } 现在，contains不仅仅更简短，而且还能解耦。 变量和函数名字肯以体现其功能为函数命名是乏味的，但是这绝对物有所值。当代码改变时，你可以不用更新注释。 $date =date('Y-m-d'); //Ofcourse, it's a date but too generic! $orderCreationDate =date('Y-m-d'); //cleaner code 避免使用if和switch就个人而言，我花了一段时间来掌握这一点。你怎么能告诉我避免我的最爱呢？事实上，大多数的条件语句可以很容易的提取到单独的函数和类中。这并不是说你永远不应该使用if和switch语句，但在某些情况下可以避免。 这有一个很好的例子： class BookOrder { public function process() { switch ($this->book->type) { case 'audiocopy': return $this->processAudioBook(); break; case 'downloadablecopy': return $this->processDownloadableCopy(); break; case 'paperbookcopy': return $this->processPaperBookCopy(); break; default: } } } 更整洁、更易于维护的方法是： interface IBookOrder { public function process(); } class AudioBookOrder implements IBookOrder :void { public function process() { // TODO: Implement process() method. } } class PaperBookOrder implements IBookOrder: void { public function process() { // TODO: Implement process() method. } } class DownloadableBookOrder implements IBookOrder: void { public function process() { // TODO: Implement process() method. } } 避免心理映射clean code应该是更易于阅读，理解并且不应该留下任何猜测空间。 It is not the language that makes a program look simple, but the programmer who makes the language appear simple. Robert C. Martin 以下代码检查客户能否可以提取一定数额的资金，它有效但是很乱。 if($this->user->balance > $amount &amp;&amp; $this->user->activeLoan===0){ $this->user->balance -=$amount; // withdraw amount; } 让我们把它变得更清晰： if($this->hasNoActiveLoan() &amp;&amp; $this->canWithdrawAmount($amount)){ $this->withdraw($amount); } public function hasNoActiveLoan(){ return $this->user->activeLoan===0; } public function canWithdrawAmount(float $amount){ return $this->user->balance > $amount; } public function withdraw(float $amount){ $this->user->balance -=$amount; } 这不仅仅更容易理解而且更容易测试了。 理解和应用S.O.L.I.D原则S.O.L.I.D是由Robert C Martin定义的面向对象编程的前五个原则的首字母缩写。使用这些原则，你可以编写低耦合、高内聚和封装很好的代码。这些原则密切相关。 不要太为难自己想知道这一点为什么这个在名单上？陷入清洁代码的世界是很容易，想要一天吸收一切。悲伤的是：需要时间，数月，数年和奉献精神。必须学习和实践这些原则，但这一切都始于决定让事情变得更加清洁。]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[翻译：JavaScript中的组合函数]]></title>
    <url>%2F2019%2F01%2F17%2Ftranslate-functional-composing-javascript%2F</url>
    <content type="text"><![CDATA[原文链接这篇文章很有趣。 简介lodash和underscore无处不在，但仍然有一种超级高效的方法，实际上只有那些赶时髦的人使用：组合。 我们将研究组合，并且深入了解为什么这种方法会是你的代码更加具有可读性，更易于维护和更加优雅。 基础我们将会使用lodash的一些函数，只是因为： 我们不想编写自己的简单的实现，因为它们会分散我们关注的内容 lodash被广泛使用，可以很容易的被underscore或其他的库或者自己的实现替换 在我们深入研究一些基本的例子之前，让我们回顾一下“组合”实际做了什么，以及如果需要，我们如何实现我们自己的组合函数。 var compose = function(f, g) { return function(x) { return f(g(x)); }; }; 这是最基本的实现。仔细看看上面的函数，你将会注意到传入的函数实际上是从右向左调用的，意思是将右侧函数的结果传递给它左侧的函数。 现在仔细看看这段代码： function reverseAndUpper(str) { var reversed = reverse(str); return upperCase(reversed); } reverseAndUpper函数首先反转给定的字符串，然后变大写。我们可以借助基本的组合函数重写以下代码： var reverseAndUpper = compose(upperCase, reverse); 现在我们可以使用reverseAndUpper： reverseAndUpper('test'); // TSET 这相当于写成： function reverseAndUpper(str) { return upperCase(reverse(str)); } 仅仅更加优雅、可维护和可重复使用。 快速组合函数的能力和创建数据管道的能力可以通过多种方式加以利用，从而可以在很长的管道中进行数据转换。想象一下传递一个集合，映射集合，然后在管道的末尾但会一个最大值或者将给定字符串转换成布尔值。组合是我们能够轻松的连接多个函数用来构建更复杂的功能。 让我们实现一个可以处理任意数量的函数以及任意数量的参数的非常灵活的组合函数，之前的组合函数只适用于两个函数或者只接受第一个参数传入，我们可以重写组合函数如下： var compose = function() { var funcs = Array.protoype.slice.call(arguments); return funcs.reduce(function(f,g) { return function() { return f(g.apply(this, arguments)); }; }); }; 这个组合函数能够写出像这样的代码： var doSometing = compose(upperCase, reverse, doSomethingInitial); doSomething('foo', 'bar'); 存在大量的可以微我们实现组合的库。我们的组合函数应该只有助于理解underscores或scoreunders组成函数中真正发生的事情，显然具体实现在库之间有所不同。它们大部分仍然在做同样的事情：使它们各自的组成函数更加通用。现在我们已经知道什么叫组合了，让我们使用lodash中的 _.compose函数继续下面的例子。 栗子让我们从一个很基础的例子开始： function notEmpty(str) { return ! _.isEmpty(str); } 函数notEmpty简单的否定了_.isEmpty的结果。我们可以使用lodash中的_.compose写一个not函数来做同样的事情。 function not(x) { return !x; } var notEmpty = _.compose(not, _.isEmpty); 现在我们可以在给定的任意参数调用notEmpty notEmpty('foo'); // true notEmpty(''); // false notEmpty(); // false notEmpty(null); // false 第一个例子非常简单，下一个会更高级： findMaxForCollection会返回由id和value属性组成的给定对象集合的最大的id。 function findMaxForCollection(data) { var items = _.pluck(data, 'val'); return Math.max.apply(null, items); } var data = [{id: 1, val: 5}, {id: 2, val: 6}, {id: 3, val: 2}]; findMaxForCollection(data); 上面的例子可以使用组合函数重写。 var findMaxForCollection = _.compose(function(xs) { return Math.max.apply(null, xs); }, _.pluck); var data = [{id: 1, val: 5}, {id: 2, val: 6}, {id: 3, val: 2}]; findMaxForCollection(data, 'val'); // 6 我们可以在这重构很多。 _.pluck期待集合作为第一个参数，回调函数作为第二个参数。如果我们想要部分应用_.pluck怎么办？这种情况下，我们可以使用柯里化来反转参数。 function pluck(key) { return function(collection) { return _.pluck(collection, key); } } 我们的findMaxForCollection仍然需要更加精致，我们可以创建我们的max函数。 function max(xs) { return Math.max.apply(null, xs); } 它可以使我们重写组合函数来变得更加优雅： var findMaxForCollection = _.compose(max, pluck('val')); findMaxForCollection(data); 通过编写我们自己的pluck函数，我们可以用val部分地应用pluck。现在你可以明显的争辩，当lodash已经拥有更方便的_.pluck函数，为什么要编写自己的pluck方法？原因是_.pluck期望集合作为第一个参数，这不是我们想要的。通过反转参数，我们可以将部分应用key，只需要在返回的函数上调用数据。 我们还可以进一步重写pluck函数。lodash带来了一个更简单的方法：_.curry，这使我们能够编写如下的pluck函数： function plucked(key, collection) { return _.pluck(collection, key); } var pluck = _.curry(plucked); 我们只是想包裹原始的pluck函数，这样我们就可以翻转参数了。现在pluck仍简单的返回一个函数，这么长，直到所有的参数都被提供。让我们看一下最终的代码： function max(xs) { return Math.max.apply(null, xs); } function plucked(key, collection) { return _.pluck(collection, key); } var pluck = _.curry(plucked); var findMaxForCollection = _.compose(max, pluck('val')); var data = [{id: 1, val: 5}, {id: 2, val: 6}, {id: 3, val: 2}]; findMaxForCollection(data); // 6 findMaxForCollection可以很容易的从右向左阅读，这意味着集合先返回val的属性，然后获的所有给定值的最大值。 var findMaxForCollection = _.compose(max, pluck('val')); 这使代码更具有可维护、可重用，并且更加优雅。我们将看一下最后的例子，以突出组合函数的优雅。 让我们扩展前一个示例的数据，然后添加名为active的属性，现在的数据如下： var data = [{id: 1, val: 5, active: true}, {id: 2, val: 6, active: false }, {id: 3, val: 2, active: true }]; 我们有一个名为的getMaxIdForActiveItems(data)函数，它接收一组对象，过滤所有的active项，并从返回的过滤项中返回最大的id。 function getMaxIdForActiveItems(data) { var filtered = _.filter(data, function(item) { return item.active === true; }); var items = _.pluck(filtered, 'val'); return Math.max.apply(null, items); } 如果我们可以将上面的代码转换成更优雅的内容怎么办？我们已经有了max和pluck函数，所以我们现在要做的是添加过滤： var getMaxIdForActiveItems = _.compose(max, pluck('val'), _.filter); getMaxIdForActiveItems(data, function(item) {return item.active === true; }); // 5 _.filter有和_.pluck一样的问题，这意味着我们不能将集合作为第一个参数来部分应用。我们可以通过包裹原生的filter实现，在filter上翻转参数。 function filter(fn) { return function(arr) { return arr.filter(fn); }; } 另一个改进是添加一个isActive函数，它只需要一个项目并检查active标志是否设置为true。 function isActive(item) { return item.active === true; } 我们可以在filter上部分应用isActive，使我们只能使用集合调用getMaxIdForActiveItems。 var getMaxIdForActiveItems = _.compose(max, pluck('val'), filter(isActive)); 现在我们需要传递的是数据： getMaxIdForActiveItems(data); // 5 这也使我们能够轻松编写一个函数，返回任何非active的最大id： var isNotActive = _.compose(not, isActive); var getMaxIdForNonActiveItems = _.compose(max, pluck('val'), filter(isNotActive)); 总结组合函数可以很有趣，如前面的例子中所示，如果正确应用，可以产生更优雅和可重复使用的代码。 PS: 赞赞赞👍，一个简单的实现组合函数如下： const doubleValue = (x) => x * 2; const multiplyByFour = x => x + 4 const compose = (...funcs) => (value) => { return funcs.reduceRight((acc, func) => func(acc), value) } // (((f, g) => x) === f(g(x)) console.log(compose(doubleValue, multiplyByFour)(2)) // 12]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[忽然想写一些总结]]></title>
    <url>%2F2019%2F01%2F13%2Fsummary-of-work%2F</url>
    <content type="text"><![CDATA[最近情绪不是太好，想了也很多，忽然发现，工作这么久，我还没正经的写过总结，现在和之前刚毕业的自己有什么不一样…. 墙外的世界很美好之前自学阶段，似乎什么问题都很难解决，虽然有梯子，但是没有利用好，找答案在bd上根本找不到啊，第一步就是好好使用梯子，起码自己的问题通过g，百分之九十都能解决，另外的百分之十可能是方向错了，这个时候，需要从头捋一下。 拒绝熟练工刚开始的自己，两天能写一个页面吧，现在半天能写一个页面，写的多了，熟练了。这个时候，我是一个熟练工还是其他的一个角色？boss不缺熟练工。 代码规范性刚到的时候，对于em的使用产生了讨论，是使用rem还是em？两种方案都各有好处。项目积累到一定程度，在不进行重构的时候，还是先以rem为主。代码是写给人看的，大部分的情况是，你不可能去维护你的代码，这个时候代码的可读性非常重要。你可以写一个a的函数，也可以写一个getName的函数….eslint的出现使规范代码更便利。 及时重构（如果条件允许）当你写的不舒服的时候，这就是重构的信号。一定要及时重构啊，否则越往后写的越累。例如：提取公共动作，如果新加入一个功能或者修改一些参数，这个时候，你只需要在公共处进行修改；否则，你改的就不止一个地方了。 拒绝硬编码你对于下面放入示例代码如何看呢 // methods 1 const xxx => (id) { if (id === 1) { return 'a'; } else if (id === 2) { return 'b'; } // ..... else { return 'default'; } } // methods 2 const translate = { 1: 'a', 2: 'b', // ... } const xxx = (id) => { const res = translate[id]; if (res) return res; return 'default'; } 拒绝过度使用好吧，项目中允许使用react，react使用起来也很方便，我全部的功能使用react去实现，而不去想是否应该去使用，或许使用项目中的template更好呢？ 优化or过度优化借用一句话：过度优化相当于现在想死后如果分财产。适度优化吧，度的话，颇有些只能意会，不能言传的感觉😂。 不要仅仅停留在读文档阶段新加的需求，通过找到一个插件，读完文档，实现了需求，内心很是开心啊，但不要仅仅停留在这个阶段，你可以尝试着去看一下插件内部是如何实现的…. 日常 尝试回顾之前的代码 你需要有plan b 解决不了的问题，放下，第二天再去解决 PS：2019也要red。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[threejs初试]]></title>
    <url>%2F2019%2F01%2F11%2Fuse-threejs%2F</url>
    <content type="text"><![CDATA[最近需要一个效果，去看了demo，发现是使用three.js做的。虽然是第二次看threejs的demo，但是被闪瞎了眼，真的是太酷了（我需要去补点图形学的知识）。 api太长了，我准备先去找点demo的代码试一下，额，这代码看不懂啊，这是些什么？虽然不太清楚，先写出来能看的demo试试。找了好几圈，我不知道我想要的效果是使用什么api来解决。还是都看一下吧。。。 第二天，我带着满肚子的疑问先看了文档，终于对前一天看到的api有了大致的认识。具体细节的参数，还是需要斟酌一下。 我想要的是漫天繁星的效果，仔细想想的话，首先有两个重要的点：画星星、怎么让页面动起来（这个效果应该是像拿着望远镜一样看天空的感觉） 画星星 for (let i = 0; i &lt; 300; i++) { let geometry = new THREE.SphereBufferGeometry(.6, 2, 2);; let material = new THREE.MeshBasicMaterial({ color: 0x4F4F4F }); let sphere = new THREE.Mesh(geometry, material); sphere.position.set( Math.random() - 0.5, Math.random() - 0.5, -Math.random() * 0.5 ).normalize().multiplyScalar(getRandomFloat(100, 300)); scene.add(sphere); stars.push(sphere); } 如何动起来为页面增加鼠标移动监听事件，在事件函数中改变全局变量 document.addEventListener('mousemove', onDocumentMouseMove, false); function onDocumentMouseMove(event) { mousePosition.x = event.clientX; mousePosition.y = event.clientY; normalizedOrientation.set( -((mousePosition.x / screenWidth) - 0.5) * cameraAmpl.x, ((mousePosition.y / screenHeight) - 0.5) * cameraAmpl.y, 0.5, ); } 代码戳这里]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[翻译：javascript中的对象，方括号和算法]]></title>
    <url>%2F2019%2F01%2F09%2Ftranslate-javascript-objects-square-brackets-and-algorithms%2F</url>
    <content type="text"><![CDATA[原文链接 JavaScript最强大的一个方面是能够动态引用对象的属性，在本文中，我们将了解他的工作原理以及它带给我们的好处。我们将快速浏览一下计算机科学中使用的一些数据结构。此外，我们将研究一种名为大O表示法的东西，用于描述算法的性能。 对象简介让我们从创建一个名为car的对象开始，每一个对象都有一个叫属性的东西。属性是属于一个对象的变量。car对象将有三个属性：make，model和color。 让我们看看它的样子： const car = { make: 'Ford', model: 'Fiesta', color: 'Red' }; 我们可以使用点表示法来引用对象的属性。例如，如果我们想要找出car的颜色，我们可以使用点表示法，就像这样：car.color 我们甚至可以使用console.log输出： console.log(car.color); //outputs: Red 引用属性的另一种方法是使用方括号表示法： console.log(car['color']); //outputs: Red 在上面的例子中，我们使用属性名称作为方括号内的字符串来获取与该属性名称对应的值。关于方括号表示法的优点在于我们还可以使用变量来动态获取属性。 也就是说，我们可以将其指定为变量中的字符串，而不是对特定属性名称进行硬编码： const propertyName = 'color'; const console.log(car[propertyName]); //outputs: Red 使用带方括号表示法的动态查找让我们看一个我们可以使用它的例子。假设我们经营一家餐馆，我们希望能够在菜单上获得商品的价格。这样做的一种方法是使用if / else语句。 让我们写一个接受名称并返回价格的函数： function getPrice(itemName){ if(itemName === 'burger') { return 10; } else if(itemName === 'fries') { return 3; } else if(itemName === 'coleslaw') { return 4; } else if(itemName === 'coke') { return 2; } else if(itemName === 'beer') { return 5; } } 虽然上面的方法有效，但是他不是理想的。在我们的code中有菜单的硬编码。现在如果我们的菜单改变了，我们不得不重写代码并且重新部署。此外，我们可以有一个很长的菜单，不得不写所有这些代码将是繁琐的。 更好的方法是分离我们的数据和逻辑。数据将包含我们的菜单，逻辑将从该菜单中查找价格。 我们可以将菜单表示为对象，其中属性名称（也称为键）对应于值。 在这种情况下，键将是项目名称，值将是项目价格： const menu = { burger: 10, fries: 3, coleslaw: 4, coke: 2, beer: 5 }; 使用方括号表示法，我们可以创建一个接受两个参数的函数：菜单对象和一个菜名并且返回菜品的价格： const menu = { burger: 10, fries: 3, coleslaw: 4, coke: 2, beer: 5 }; function getPrice(itemName, menu){ const itemPrice = menu[itemName]; return itemPrice; } const priceOfBurger = getPrice('burger', menu); console.log(priceOfBurger); // outputs: 10 这种方法的巧妙之处在于我们将数据与逻辑分开。在这个例子中，数据存在于我们的代码中，但它可以很容易地来自数据库或API。它不再与我们的查找逻辑紧密耦合，后者将菜品名称转换为菜品价格。 数据结构和算法计算机科学术语中的map是一种数据结构，它是键/值对的集合，其中每个键映射到相应的值。我们可以使用它来查找与特定键对应的值。 这就是我们在前面的例子中所做的。我们有一个菜品的名称，我们可以使用菜单对象查找该项目的相应价格。我们正在使用一个对象来实现一个map数据结构。 让我们看看为什么我们可能想要使用Map。 假设我们经营一家书店，并有一份书籍清单。 每本书都有一个名为国际标准书号（ISBN）的唯一标识符，这是一个13位数字。 我们将图书存储在一个数组中，希望能够使用ISBN查找它们。 一种方法是循环遍历数组，检查每本书的ISBN值，如果匹配则返回它： const books = [{ isbn: '978-0099540946', author: 'Mikhail Bulgakov', title: 'Master and Margarita' }, { isbn: '978-0596517748', author: 'Douglas Crockford', title: 'JavaScript: The Good Parts' }, { isbn: '978-1593275846', author: 'Marijn Haverbeke', title: 'Eloquent JavaScript' }]; function getBookByIsbn(isbn, books){ for(let i = 0; i &lt; books.length; i++){ if(books[i].isbn === isbn) { return books[i]; } } } const myBook = getBookByIsbn('978-1593275846', books); 这个例子很好用，因为我们只有三本书（这是一个小书店）。但是，如果我们是亚马逊，那么迭代数以百万计的书籍可能会非常慢并且计算成本也很高。 计算机科学中使用大O表示法来描述算法的性能。例如，如果n是我们集合中的书籍数量，那么在最坏的情况下使用迭代来查找书籍的成本（我们要查找的书是列表中的最后一本）将是O(n)。这意味着如果我们集合中的书籍数量增加一倍，使用迭代查找书籍的成本也会翻倍。 让我们看看如何通过使用不同的数据结构使我们的算法更有效。 如上所述，可以使用映射来查找与键对应的值。 我们可以使用对象将数据结构化为map(这里指对象)而不是数组。 键将是ISBN，值将是相应的书对象： const books = { '978-0099540946':{ isbn: '978-0099540946', author: 'Mikhail Bulgakov', title: 'Master and Margarita' }, '978-0596517748': { isbn: '978-0596517748', author: 'Douglas Crockford', title: 'JavaScript: The Good Parts' }, '978-1593275846': { isbn: '978-1593275846', author: 'Marijn Haverbeke', title: 'Eloquent JavaScript' } }; function getBookByIsbn(isbn, books){ return books[isbn]; } const myBook = getBookByIsbn('978-1593275846', books); 我们现在可以使用ISBN的简单地图查找来获取我们的价值，而不是使用迭代。我们不再需要检查每个对象的ISBN值。 我们使用key直接从地图获取值。 在性能方面，地图查找将提供相对于迭代的巨大改进。 这是因为地图查找在计算方面具有不变的成本。 这可以使用大O表示法写为O(1)。如果我们有三三百万册书籍没关系，我们可以通过使用ISBN键进行地图查找来快速获得我们想要的书。 总结 我们可以使用点表示法和方括号表示法访问对象属性的值 我们学习了如何通过使用带方括号表示法的变量来动态查找属性值 我们还了解到，map数据结构将键映射到值。 我们可以使用键直接在我们使用对象实现的map中查找值。 我们初看了如何使用大O表示法描述算法性能。此外，我们还看到了如何通过将对象数组转换为map并使用直接查找而不是迭代来提高搜索性能。 ps: hardcode真的是很硬…]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重构那些事]]></title>
    <url>%2F2019%2F01%2F02%2Fmixed-talk-3%2F</url>
    <content type="text"><![CDATA[#1今天查代码，发现又有一些可以提取公共函数的代码…真的是，对于重构这个事，真的是“野火烧不尽，春风吹又生”。 #2我的习惯是，功能性重构，当我看到一个新的需求出来的时候，发现有一些行为是和已经存在的行为是类似的，这个时候我开始去着手重构，将相同的行为提取出来。但是这个过程会使我忽略另一部分重构工作…不大但是非常值得提取的行为，因为这样的过程太多了，写着写着就习惯了😂啊，这个不复杂，我可以直接写出来，时间就是金钱，争分夺秒写，然而这个过程就666了…. 今天查看代码的时候，一搜关键字好多重复的代码，第一反应是我尽然写了这个多遍，自己都佩服自己，接着开始自我怀疑，写的时候是不是处于不清醒的状态😂。恰恰是这些，最应该做成辅助函数的代码却零星的散落在四处…忍不了啊 #3反思一下，是自己对于重构的粒度是怎么定义，换一句话讲是对重构怎么定义的。之前也享受过重构的快乐。本来预计两天的工作，真的一下手写，发现只用更改一点点，就能满足新的需求，当时的那个喜悦真的是冲破天际。现在的自我的怀疑也是突破天际，真的是很基本的基础函数，写了这么多遍怎么久没感觉呢？ “写代码的时候，如果觉得不舒服，不是方向错了就是需要重构”，这句话是我重构的标杆。思考🤔了很久，得出的答案是对自己的代码太宽容了…. #4在没有新需求或者调整架构时，我enhance code的方式是浏览每个文件，这个方式费心费力，下次应该调整方式，一次捋页面，查找里面的相同的点；并且粒度再小一点…. PS: 新的一年，掐指一算，又是写代码的一年😄]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[翻译：理解javascript中的作用域]]></title>
    <url>%2F2018%2F12%2F24%2Ftranslate-understanding-scope-in-javascript%2F</url>
    <content type="text"><![CDATA[原文链接 #简介JavaScript有一个特性叫做作用域。尽管作用域的概念对于许多初学者是不容易理解的，我会尽力在最简单的范围内解释。理解作用域会是你的代码更加清楚，减少错误，帮助你使用它制作强大的设计模式。 #什么是作用域作用域是运行时代码中某些特定部分中变量，函数和对象的可访问性。换句话说，作用域确定了代码中的变量和其他资源的可见性。 #作用域为何存在–最小访问性原则因此，限制变量的可见性的重点是什么，而不是所有的代码不是随处可见的。一个优点是作用域为你的代码提供了一定级别的安全性，计算机安全的一个常见的原则是用户应该一次只能访问他们需要的东西。 想想电脑的管理员，由于他们对公司的电脑有很多控制权，向他们的账户授予全部权限是没问题的。假设你有一个含有三个管理员的公司，他们都可以访问系统，一切都很顺利。但是突然，发生了一件坏事，其中的一个系统感染了病毒。现在你不知道到底是谁的错误导致的。你意识到你应该给他们基本的用户账户，只有在需要的时候才赋予完全访问的特权。这会帮助你追踪变化，记录谁做了什么。这叫做最小访问性原则。看起来很直观？这个原则也适用于程序语言的设计。它在大多数编程语言中称作作用域，包括我们接下来要研究的JavaScript。 随着你的编程之旅，你会意识到代码的作用域有助于提高效率，追踪bug并且减少bug。作用域也解决了在不同作用域中相同变量名的命名问题。切记不要吧作用域和上下文弄混淆了，它们是不同的特性。 #JavaScript中的作用域在JavaScript中有两种类型的作用域 全局作用域 局部作用域 函数内部的变量是在局部作用域，外部的是在全局作用域。每一个函数在调用的时候会创建一个新的作用域。 #全局作用域在文档中开始写JavaScript时，你已经在全局作用域中了。整个JavaScript文件中只有一个全局作用域，如果变量位于函数的外面，那么它是在全局作用域中。 // the scope is by default global var name = 'Hammad'; 位于全局作用域的变量可以在其他作用域被访问和修改。 var name = 'Hammad'; console.log(name); // logs 'Hammad' function logName() { console.log(name); // 'name' is accessible here and everywhere else } logName(); // logs 'Hammad' #局部作用域定义在函数内部的变量是在局部作用域中，每一次调用函数，它们会有不同的作用域。这意味着相同名字的变量可以在不同的函数中使用。这是因为这些变量绑定在它们各自的函数中，每一个有不同的作用域，并且在其他的函数中无法访问。 // Global Scope function someFunction() { // Local Scope #1 function someOtherFunction() { // Local Scope #2 } } // Global Scope function anotherFunction() { // Local Scope #3 } // Global Scope #块语句块语句类似if和switch条件或者for和while循环中，不像函数那样创建新的作用域。定义在块语句中的变量将保留在它们已经存在的作用域中。 if (true) { // this 'if' conditional block doesn't create a new scope var name = 'Hammad'; // name is still in the global scope } console.log(name); // logs 'Hammad' ECMAScript 6中采用let和const关键字，这些关键词可以代替var关键字。 var name = 'Hammad'; let likes = 'Coding'; const skills = 'Javascript and PHP'; 与var关键字相反，let和const关键字支持在块语句中声明局部作用域。 if (true) { // this 'if' conditional block doesn't create a scope // name is in the global scope because of the 'var' keyword var name = 'Hammad'; // likes is in the local scope because of the 'let' keyword let likes = 'Coding'; // skills is in the local scope because of the 'const' keyword const skills = 'JavaScript and PHP'; } console.log(name); // logs 'Hammad' console.log(likes); // Uncaught ReferenceError: likes is not defined console.log(skills); // Uncaught ReferenceError: skills is not defined 只要您的应用程序存在，全局作用域就会存在。只要调用和执行函数，本地作用域就会存在。 #上下文很多开发者经常混淆作用域和上下文，认为它们指的是相同的概念。但这种情况并非如此。作用域是我们上面讨论的，上下文用来在代码的某些特定部分引用this的值。作用域是指变量的可见性，而上下文是指在同一范围内的this的值。我们也可以使用函数方法更改上下文，我们将在后面讨论。在全局作用域中上下文始终是Window对象。 // logs: Window {speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage…} console.log(this); function logFunction() { console.log(this); } // logs: Window {speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage…} // because logFunction() is not a property of an object logFunction(); 如果作用域在一个对象的方法中，则上下文是该方法所属的对象。 class User { logName() { console.log(this); } } (new User).logName(); // logs User {} (new User).logName()是一种将对象存储在变量中然后在其上调用logName函数的简短办法。在这里，你不需要创建新的对象。 你会注意到如果使用new调用你的函数，上下文的值表现是不一样的。上下文将会被设置为调用函数的实例。考虑上面的一个示例，使用new关键字调用该函数。 function logFunction() { console.log(this); } new logFunction(); // logs logFunction {} 在严格模式下调用函数时，上下文默认为undefined。 #执行上下文要消除我们上面学的内容的混淆，执行上下文中的上下文指的是作用域而不是上下文。这是一个奇怪的命名约定，但是由于JavaScript的规范，我们与之相关。 JavaScript是一个单线程的语言，所以它一次只能执行一个任务。其余的任务在执行上下文中排队。正如我之前告诉你的，当JavaScript解释器开始执行你的代码时，默认情况下，上下文（作用域）设置成全局。此全局上下文附加到您的执行上下文，该上下文实际上是启动执行上下文的第一个上下文。 之后，每个函数调用都会将其上下文附加到执行上下文。当在该函数内部或其他地方调用另一个函数时，会发生同样的事情。 每个函数都创建自己的执行上下文 一旦浏览器完成该上下文中的代码，那么该上下文将从执行上下文中弹出，并且执行上下文中的当前上下文的状态将被传送到父上下文。 浏览器总是执行位于执行堆栈顶部的执行上下文（实际上是代码中最内层的范围）。 只能有一个全局上下文，但有任意数量的函数上下文。 执行上下文有两个创建阶段和代码执行阶段。 创建阶段当调用函数但其代码尚未执行时，存在创建阶段的第一个阶段。在创建阶段发生的三件主要事情是： 创建可变对象 创建作用域链 设置上下文的值（this） 可变对象可变对象（也称为激活对象）包含在执行上下文的特定分支中定义的所有变量，函数和其他声明。 调用函数时，解释器会扫描所有资源，包括函数参数，变量和其他声明。 当打包到单个对象中时，所有内容都将成为可变对象。 'variableObject': { // contains function arguments, inner variable and function declarations } 作用域链在创建阶段的运行上下文中，作用域链在可变对象后被创建。作用域链本身包含变量对象。作用域链被用来解决变量。当被要求解析变量时，JavaScript始终从代码嵌套的最内层开始，并一直跳回到父作用域，直到它找到正在寻找的变量或任何其他资源。作用域链可以简单地定义为包含其自己的执行上下文的可变对象的对象，以及它父对象的所有其他执行上下文，该对象拥有一堆其他对象。 'scopeChain': { // contains its own variable object and other variable objects of the parent execution contexts } 执行上下文对象执行上下文对象可以表示为这样的抽象对象： executionContextObject = { 'scopeChain': {}, // contains its own variableObject and other variableObject of the parent execution contexts 'variableObject': {}, // contains function arguments, inner variable and function declarations 'this': valueOfThis } 代码执行阶段在执行上下文的第二阶段是代码执行阶段，其他的值被分配，代码最终运行。 #语法作用域语法作用域意味着嵌套在函数组中，内部的函数可以访问其父作用域的变量和其他资源。这意味着子函数在语法上绑定了其父函数的执行上下文。语法作用域有时也被称为静态作用域。 function grandfather() { var name = 'Hammad'; // likes is not accessible here function parent() { // name is accessible here // likes is not accessible here function child() { // Innermost level of the scope chain // name is also accessible here var likes = 'Coding'; } } } 你会注意到关于语法作用域的事情是它向前工作，这意味着name可以通过其子项的执行上下文来访问。但是他不会像父母一样向后工作，这意味着变量likes不能被它的父函数访问。这也告诉我们在不同执行上下文中具有相同名称的变量从执行堆栈的顶部到底部优先获得。一个变量和其他变量具有相同的名称，在最里面的函数（执行堆栈的最顶部的上下文）具有最高的优先权。 #闭包闭包的概念和我们上面学习的语法作用域密切相关。当内部函数尝试访问其外部函数的作用域链时创建Closure，这意味着语法作用域之外的变量。闭包包含自己的范围链，父母的范围链和全局范围。 闭包不仅可以访问外部函数中定义的变量，还可以访问外部函数的参数。 即使在函数返回后，闭包也可以访问其外部函数的变量。这允许返回的函数维护对外部函数的所有资源的访问。 当您从函数返回内部函数时，这时候您尝试调用外部函数时，将不会调用返回的函数。你必须首先将外部函数的调用保存在单独的变量中，然后将该变量作为函数调用。思考这个例子： function greet() { name = 'Hammad'; return function () { console.log('Hi ' + name); } } greet(); // nothing happens, no errors // the returned function from greet() gets saved in greetLetter greetLetter = greet(); // calling greetLetter calls the returned function from the greet() function greetLetter(); // logs 'Hi Hammad' 这里要注意的关键点是函数greetLetter在greet函数返回的情况下任然可以访问变量name。在没有变量赋值的情况下从greet函数调用返回函数的一种方法是使用括号两次，如下所示： function greet() { name = 'Hammad'; return function () { console.log('Hi ' + name); } } greet()(); // logs 'Hi Hammad' PS：我觉得上面的例子没有很好的反映出来闭包的概念，让我看来它只是一个高阶函数的代表。我第一次接触闭包是我之前在写一个手风琴的demo时，为每一个li标签添加事件，但是写出来的结果是只能为最后一个li标签添加事件，其他的列表没有添加上！what？我是来了一个for循环加上的呀…这时候我开始寻找问题的原因，进而了解到闭包这个概念。 #public作用域和private作用域在很多其他的编程语言中，你可以使用private、public、private和protected设置类方法和类属性的可见性。使用PHP语言思考这个例子： // Public Scope public $property; public function method() { // ... } // Private Sccpe private $property; private function method() { // ... } // Protected Scope protected $property; protected function method() { // ... } 封装来自public作用域的函数可以使他们免受易攻击。但是在JavaScript中，共有和私有的概念都没有。然而，我们可以使用闭包来模拟这个特性。为了使所有内容与全局分离，我们必须首先将函数封装在如下的函数中： (function () { // private scope })(); 函数的尾部告诉解释器无需调用立即就可以执行它。我们向其中增加函数和变量，在外部是不可以访问的。但是，如果我们想在外部访问它们，意味着我们希望一部分是public一部分是private？我们可以使用的另一种闭包叫做模块模式，这允许我们使用对象中的public和private作用域来界定我们的函数。 模块模式模块模式看起来像这样： var Module = (function() { function privateMethod() { // do something } return { publicMethod: function() { // can call privateMethod(); } }; })(); 模块的返回声明中包括我们的public函数，private函数并不会返回。不反悔的函数是在模块命名空间外不能访问。但是我们的共有方法是可以访问我们的私有函数，这些函数一般是辅助函数，例如ajax调用和一切其他的。 Module.publicMethod(); // works Module.privateMethod(); // Uncaught ReferenceError: privateMethod is not defined 一种惯例是私有函数的命名是以下划线开头，并返回包含我们的公共函数的匿名对象。这使得它们易于在长对象中进行管理。这就是它的样子： var Module = (function () { function _privateMethod() { // do something } function publicMethod() { // do something } return { publicMethod: publicMethod, } })(); 立即执行函数（IIFE）另一种闭包的类型是立即执行函数。这是在window的上下文中自调用的匿名函数，这意味着this的值是window。这暴露了一个与之交互的全局接口。它看起来是这样： (function(window) { // do anything })(this); #使用.call(), .apply() 和 .bind()改变上下文call和apply函数用于在调用函数时更改上下文，这为您提供了令人难以置信的编程能力（以及统治世界的一些终极能力）。要使用call或apply函数，只需要在函数上调用它，而不是使用一对括号调用函数，并将上下文作为第一个参数传递。函数自己的参数可以在上下文之后传递。 function hello() { // do something... } hello(); // the way you usually call it hello.call(context); // here you can pass the context(value of this) as the first argument hello.apply(context); // here you can pass the context(value of this) as the first argument .call()和.apply()之间的区别在于，在call中，您将其余参数作为以逗号分隔的列表传递，而apply允许您传递数组中的参数。 function introduce(name, interest) { console.log('Hi! I\'m '+ name +' and I like '+ interest +'.'); console.log('The value of this is '+ this +'.') } introduce('Hammad', 'Coding'); // the way you usually call it introduce.call(window, 'Batman', 'to save Gotham'); // pass the arguments one by one after the contextt introduce.apply('Hi', ['Bruce Wayne', 'businesses']); // pass the arguments in an array after the context // Output: // Hi! I'm Hammad and I like Coding. // The value of this is [object Window]. // Hi! I'm Batman and I like to save Gotham. // The value of this is [object Window]. // Hi! I'm Bruce Wayne and I like businesses. // The value of this is Hi. call性能略高于apply。 以下示例获取文档中的项目列表，并将它们逐个打印到控制台: &lt;!DOCTYPE html> &lt;html lang="en"> &lt;head> &lt;meta charset="UTF-8"> &lt;title>Things to learn&lt;/title> &lt;/head> &lt;body> &lt;h1>Things to Learn to Rule the World&lt;/h1> &lt;ul> &lt;li>Learn PHP&lt;/li> &lt;li>Learn Laravel&lt;/li> &lt;li>Learn JavaScript&lt;/li> &lt;li>Learn VueJS&lt;/li> &lt;li>Learn CLI&lt;/li> &lt;li>Learn Git&lt;/li> &lt;li>Learn Astral Projection&lt;/li> &lt;/ul> &lt;script> // Saves a NodeList of all list items on the page in listItems var listItems = document.querySelectorAll('ul li'); // Loops through each of the Node in the listItems NodeList and logs its content for (var i = 0; i &lt; listItems.length; i++) { (function () { console.log(this.innerHTML); }).call(listItems[i]); } // Output logs: // Learn PHP // Learn Laravel // Learn JavaScript // Learn VueJS // Learn CLI // Learn Git // Learn Astral Projection &lt;/script> &lt;/body> &lt;/html> HTML仅包含无序的项列表。然后JavaScript从DOM中选择所有的列表。循环列表。在循环内部，我们将列表项的内容记录到控制台。 此日志语句包含在括在括号中的函数中，在该函数中调用调用函数。相应的列表项将传递给调用函数，以便控制台语句中的关键字记录正确对象的innerHTML。 对象可以有这些方法，同样函数对象也可以有这些方法。事实上，JavaScript函数带有四个内置方法，它们是： Function.prototype.apply() Function.prototype.bind() (Introduced in ECMAScript 5 (ES5)) Function.prototype.call() Function.prototype.toString() Function.prototype.toString()返回函数源代码的字符串表示形式。 到目前为止，我们已经讨论过.call(),.apply()和toString()。 与call和apply不同，bind本身不调用该函数，它只能在调用函数之前用于绑定上下文和其他参数的值。 在上面的一个例子中使用bind： (function introduce(name, interest) { console.log('Hi! I\'m '+ name +' and I like '+ interest +'.'); console.log('The value of this is '+ this +'.') }).bind(window, 'Hammad', 'Cosmology')(); // logs: // Hi! I'm Hammad and I like Cosmology. // The value of this is [object Window]. bind就像call函数一样，它允许你一个接一个地用逗号分隔其余的参数，而不是像apply一样，在数组中传递参数。 #总结这些概念对JavaScript来说是激进的，如果您想要处理更高级的话题，这一点很重要。 我希望你能更好地理解JavaScript Scope及其周围的事情。如果有什么疑问，请随时在下面的评论中询问。 扩展您的代码，直到那时，快乐编码！ Scope up your code and till then, Happy Coding! PS终于理解编辑的累了，这么长的文章！！！这是分好几次做的…]]></content>
      <categories>
        <category>翻译</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哇哇，我的第一个task]]></title>
    <url>%2F2018%2F12%2F21%2Ffirst-task%2F</url>
    <content type="text"><![CDATA[最近有一些数据迁移，心中已有蓝图，但是不知如何下手，请教了后端的小哥哥，写出了我的第一个task， namespace :migrate do desc 'migrate info to apply' task :to_apply => :environment do Membership.all.each do |membership| user = membership.user apply = Apply.new( user_id: user.id, # .... ); apply.save!(validate: false) end end end 本来是想写一个数据库的migrate，征求了后端的意见，选择了写一个task，migrate在被合并的时候，这次的数据迁移可能会被吃掉，于是写了一个task，一个简单的数据迁移…]]></content>
      <categories>
        <category>rails</category>
      </categories>
      <tags>
        <tag>rails</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序web-view的实践]]></title>
    <url>%2F2018%2F12%2F21%2Fweapp-web-view%2F</url>
    <content type="text"><![CDATA[因为小程序的标签有限，像iframe这样的标签不能在小程序里面很好的展示，于是只能选择使用web-view去展示小程序的内容，点击web-view中iframe期望跳到小程序中的某个页面。 根据小程序的文档来，小程序嵌入web-view是一个很简单的事情 &lt;web-view src="{{url}}">&lt;/web-view> 如何在页面中跳入小程序的页面，为了防止污染现有的页面，我选择新建一个页面，引入小程序的sdk， - if browser.wechat? = javascript_include_tag 'https://res.wx.qq.com/open/js/jweixin-1.3.2.js' // ..... wx.miniProgram.navigateTo({ url }) ok，成功！]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Boolean隐形类型转换]]></title>
    <url>%2F2018%2F12%2F17%2Fjs-boolean%2F</url>
    <content type="text"><![CDATA[在if类型中，为了使代码看起来好看一些，你往往会使用最简洁的判断，但是其中涉及的隐形类型转换，一不小心就出了bug。 if (count) { // .... } 在运行过程中，if代码块死活不执行，仔细想了想，count等于零的时候，是不执行的，这不是我的本意呀，我想着存在着这个值的时候，就执行，所以我应该这样写，才能达到我的目的。 if (count !== undefined) { // .... } 这里有一份列表，表中的值类型转换完一定为false undefined null false +0, -0, and NaN “” 不在上面列表中，一定为true。 思考一下： var a = new Boolean( false ); var b = new Number( 0 ); var c = new String( "" ); var d = Boolean( a &amp;&amp; b &amp;&amp; c ); d; // true 你会不会感到疑惑？看一下值时候在上面的列表中！记住只要不在列表中的值，类型转换之后，一定为true 这里补充一下+c的意思是将c转换成number类型，那么&quot;foo&quot;++&quot;5&quot;，就是先执行+&quot;5&quot;]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序二级地址选择器]]></title>
    <url>%2F2018%2F12%2F11%2Fweapp-address%2F</url>
    <content type="text"><![CDATA[今天的任务里面有一个表单，表单里面有地址选择器，小程序官方的组件提供的是国内三级地址选择器，但是有些地方还需要海外的地址，地址又不需要这么详细，到二级足矣… 我的想法是共有两了picker,第一个选择国家，如果选择的是中国的话，第二个输入框为省市picker，如果是海外，第二个为输入框。 那么第二个输入框的数据从哪来呢？是否是需要请求后端？想了想延迟，还是从前端来吧，数据的来源就是某宝了，数据也是最新的。数据格式我存储成下面这样，向后端传值的时候，就传代码就可以了。 export const province = [ { id: "110000", name: "北京" }, // ... } export const city = { "110000": [{ "id": "110100", "name": "北京" }], "110100": [{ "id": "110101", "name": "东城" }, { // .... }, // ... ], // ..... } 其中有一个很坑的地方是，在picker的bingchange函数中，如果直接使用event中的detail值直接赋值，会会发现你的数据从number变成string类型，我在第二个显示输入框还是picker的时候，死活显示不出来，都已经给设计要planb了😂，我说是小程序的锅吗后来搜了一圈，也没发现类似问题…最后使用Number强制类型转换了一下。 下面是部分小程序的代码了： &lt;picker name="city" bindchange="bindCountryChange" value="{{countryIndex}}" range="{{country}}"> &lt;text>{{country[countryIndex]}} &lt;/text> &lt;/picker> &lt;view class="{{countryIndex === 0 ? '' : 'is-hidden'}}"> &lt;picker name="external" mode="multiSelector" range-key="name" bindchange="bindCityChange" bindcolumnchange="bindCityColumnChange" value="{{cityIndex}}" range="{{city}}" > &lt;view class="u-text-limit--one" name="internal"> {{city[0][cityIndex[0]].name}}{{city[1][cityIndex[1]].name}} &lt;/view> &lt;/picker> &lt;/view> &lt;view class="{{countryIndex === 0 ? 'is-hidden' : ''}}"> &lt;input type="text" name="internal" placeholder="请输入城市" /> &lt;/view> bindCityChange: function(event) { const index = Number(event.detail.value); this.setData({ cityIndex: index }) }, bindCityColumnChange(e) { const data = { city: this.data.city, cityIndex: this.data.cityIndex } data.cityIndex[e.detail.column] = e.detail.value if (e.detail.column === 0) { const provinceIndex = data.cityIndex[0]; const provinceId = data.city[0][provinceIndex].id; data.city[1] = city[provinceId]; data.cityIndex[1] = 0; } this.setData(data) },]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今日杂谈]]></title>
    <url>%2F2018%2F12%2F10%2Fmixed-talk-2%2F</url>
    <content type="text"><![CDATA[今天看到写出来的api不尽人意，于是我就问了我后端的小伙伴：他们是怎么写api，他说是照着原型来…对于这个答案，我也是一脸懵逼…. 还记得之前实习的我和同学一起做了一个排班系统，前端是按照星期展示的，写的过程中，我的同学问我：你什么样的数据方便啊，我就给你什么类型的数据？嗯，当时很年轻，我要这这样的数据，巴拉巴拉的。。最后做出来的系统非常满意，最后交工的时候，CTO看了代码之后，就说：你这样给前端数据，假如前端的ui变了，需要两星期一行展示数据怎么办？你还是需要改后端的接口，这是一个完全颠倒的过程…api应该是后端主导，而不是前端去主导，api的职责是提供数据，至于数据如何展示，应该是前端的职责。 当时说到这样的建议，也是非常惭愧，真的是出于无知，做出无知的事情。 虽然小目标是成为一个全栈工程师，目前是前端，写简单的api，我谨记这些话，以防整个过程是由前端来主导。 我只能当作对方出于人道主义精神，写出让我处理起来简单的API，否则真的是无法忍受这样的api… 今天在接api的时候，发现小程序不接受patch请求…why 最近想了很多，也寻求了很多建议，权衡各方面的利弊，虽然寒冬来临，希望自己能有一片温暖的小天地…]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[翻译：js中的神奇的类型转换]]></title>
    <url>%2F2018%2F12%2F07%2Fjs-type-coercion%2F</url>
    <content type="text"><![CDATA[来源这边文章主要讲的是运算符中的隐式类型转换，我只摘了下面的例子 true + false // 1 12 / "6" // 2 "number" + 15 + 3 // 'number153' 15 + 3 + "number" // '18number' [1] > null // true "foo" + + "bar" // 'fooNaN' 'true' == true // false false == 'false' // false null == '' // false !!"false" == !!"true" // true ['x'] == 'x' // true [] + null + 1 // 'null1' [1,2,3] == [1,2,3] // false 0 || "0" &amp;&amp; {} // {} {}+[]+{}+[1] // '0[object Object]1' !+[]+[]+![] // 'truefalse' new Date(0) - 0 // 0 new Date(0) + 0 // 'Thu Jan 01 1970 02:00:00(EET)0' true + false加法运算符会触发数字转换 true + false ==> 1 + 0 ==> 1 12 / “6”除法运算符会触发字符串的数字转换 “number” + 15 + 3加法运算符是从左到右结合，所以先执行&quot;number&quot; + 15，因为第一个操作数是字符串，加法运算符对15进行字符串转换，第二步也是如此。 15 + 3 + “number”如同上一个一样，先执行15+3，因为都是数字，所以不需要进行类型转换。第二步中，因为一个操作数中有字符串，所以对数字进行字符串转换。 [1] &gt; null比较运算符会触发对操作数的数字转换 [1] > null ==> '1' > 0 ==> 1 > 0 ==> true “foo” + + “bar”右边运算符比左边运算符具有更高的优先级，因此+&#39;bar&#39;表达式先执行。一元加号运算符会触发对字符串进行数字类型转换，由于字符串转换之后是一个非法的数字，结果是NaN。第二步执行&#39;foo&#39; + NaN "foo" + + "bar" ==> "foo" + (+"bar") ==> "foo" + NaN ==> "fooNaN" ‘true’ == true and false == ‘false’==运算符会触发数字类型转换，字符串&#39;true&#39;被转换成NaN，布尔true被转换成1 null == ‘’==运算符通常会触发数字类型转换，但不是null的情况，null只能和null和undefined进行比较，不能和其他值进行比较。 !!”false” == !!”true”!!运算符将这两个字符串转换成布尔值true，因为他们不是空的字符串， ==不进行类型转换，只对布尔值的true进行比较 [‘x’] == ‘x’==运算符会触发对一个数组进行数组转换，数组的valueOf()方法会返回数组自己，但是因为数组不是基本类型，velueOf会被忽略。数组的toString()仅仅将[&#39;x&#39;]转换成字符串&#39;x&#39; [] + null + 1+会触发将[]进行数字类型转换，和上一个一样进行toString操作，会返回一个空的字符串，接下来就进行&#39;&#39; + null + 1 [1,2,3] == [1,2,3]两边有同样类型，不进行类型转换，由于==检查值相等而不是引用相等，两个数组是两个不同的实例，所以结果是false 0 || “0” &amp;&amp; {}逻辑运算符||、&amp;&amp;会进行布尔类型转换，但是会返回原始操作数。0是false，&#39;0&#39;是true，{}是true，最后返回{} {}+[]+{}+[1]所有的操作数都不是基本类型，所以+开始从左边的触发数字转换，数组和对象的valueOf方法被忽略。使用后备toString方法。这里有一个诀窍，第一个{}不被看作对象，而是被视为块声明语句，因此它被忽略。于是开始从后面的+[]开始进行评估，[]的toString返回一个空字符串，再对空字符串进行数字转换是0 {}+[]+{}+[1] ==> +[]+{}+[1] ==> 0 + {} + [1] ==> 0 + '[object Object]' + [1] ==> '0[object Object]' + [1] ==> '0[object Object]' + '1' ==> '0[object Object]1' !+[]+[]+![]这个可以根据运算符的优先级去解释 !+[]+[]+![] ==> (!+[]) + [] + (![]) ==> !0 + [] + false ==> true + [] + false ==> true + '' + false ==> 'truefalse' new Date(0) - 0减号运算符会进行数字转换。Date.valueOf()返回自Unix纪元以来的毫秒数 new Date(0) - 0 ==> 0 - 0 ==> 0 new Date(0) + 0加号运算符触发默认转换。 Date假定字符串转换为默认值，因此使用toString()方法，而不是valueOf()。]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迁移csdn博客]]></title>
    <url>%2F2018%2F12%2F04%2Fget-csdn-blog%2F</url>
    <content type="text"><![CDATA[一直想着吧csdn上的文章迁过来，但是一直没动手…这次终于动手了，先想一下我的思路：获取所有的文章链接 -&gt; 获取文章的内容 我使用了： https（获取链接的dom） cheerio（解析dom） fs (向文件中写取内容) 获取页面的htmlfunction getUrlHtml(url, cb) { return new Promise(function(resolve, reject) { https .get(url, function(res) { let html = '' res .on('data', function(data) { html += data }) .on('end', function() { resolve(cb(html)) }) }) .on('error', function(err) { reject(err) }) }) } 解析html，并创建promise请求function getArticleUrl(html) { const $ = cheerio.load(html) const $articleList = $('.article-item-box.csdn-tracking-statistics h4 a') const articleUrlList = [] $articleList.each(function(index, item) { articleUrlList.push($(item).attr('href')) }) return articleUrlList } 执行所有的promise，这里我使用的是Promise.all写入文件fs.writeFile(`./post/${title}.md`, content, 'utf8', function (error, result) { if (error) { console.log(error) reject(error) } else { resolve(result) } }) ps在获取文章的html内容的时候，获得的是转义后的字符，想着有没有接口可以直接将html转成md？看了csdn上的代码的格式，不知道可不可以转义？]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[翻译：javascript中方的所有事物并不都是对象]]></title>
    <url>%2F2018%2F11%2F29%2Ftranslate-not-everything-in-javascript-is-an-object%2F</url>
    <content type="text"><![CDATA[文章出处 关于javascript是面向对象编程（OOP）语言还是函数式语言，存在和很多混淆，其实，javascript都可以在两者中使用。这会导致人们问：在JavaScript中所有事物是对象吗？函数是什么？这篇post将会作出解释。 让我们从头开始吧在JavaScript中有六种原始数据类型 Booleans - true or false null undefined number - 双精度的64位的浮点数，JavaScript中没有整数 string symbol (new in ES6) 除了这六种基本类型，ECMAScript标准也定义了一个object类型，它是一个键值对存储 const object = { key: "value" } 所以，简单来说，不是基本类型的是事物是一个object，并且包括function和array 所有的函数都是object // Primitive types true instanceof Object; // false null instanceof Object; // false undefined instanceof Object; // false 0 instanceof Object; // false 'bar' instanceof Object; // false // Non-primitive types const foo = function () {} foo instanceof Object; // true 基本类型（Primitive types）基本类型没有挂载方法，所以你永远不会看见undefined.toString()。也是因为这个，基本类型是不可变的，因为没有附加方法能改变他。 你可以为基本类型重新分配给变量，但它将会是一个新的值，不是原来的值，也不是改变。 const answer = 42 answer.foo = "bar"; answer.foo; // undefined 基本类型是不可变的 此外，基本类型作为本身的值存储，不像object作为引用存储。这会影响相等性检查。 "dog" === "dog"; // true 14 === 14; // true {} === {}; // false [] === []; // false (function () {}) === (function () {}); // false 基本类型作为值存储，object作为引用存储 函数（function）函数是一种特殊类型的object，它具有一些特殊的属性，例如call和contractor const foo = function (baz) {}; foo.name; // "foo" foo.length; // 1 就像普通的对象一样，你可以为对象增加新的属性。 foo.bar = "baz"; foo.bar; // "baz" 这可以是函数成为一等公民（This makes functions a first-class citizen.）。因为他可以像任何其它对象一样当作参数传递给其他参数。 方法（method）方法是一个对象属性，也是一个函数。 const foo = {}; foo.bar = function () { console.log("baz"); }; foo.bar(); // "baz" 函数的构造函数如果你有多个相同实现的对象，你可以将实现逻辑放在构造函数中，然后使用这个构造函数创建这些对象。 构造函数和普通函数没有什么区别，当函数在new关键字后使用，它被当作构造函数使用。 任何函数都可以是构造函数 const Foo = function () {}; const bar = new Foo(); bar; // {} bar instanceof Foo; // true bar instanceof Object; // true 一个构造函数会返回一个object，你可以在函数内部使用this增加新的属性。因此我们想要为多个对象的属性bar初始化为baz，我们可以创建一个新的构造函数Foo来封装这个逻辑 const Foo = function () { this.bar = "baz"; }; const qux = new Foo(); qux; // { bar: "baz" } qux instanceof Foo; // true qux instanceof Object; // true 你可以使用构造函数来创建一个新的对象 不带new关键字运行构造函数，就像Foo()，将会像普通的函数一样。函数内部的this将会指向运行上下文。因此如果我们在所有函数的外部调用Foo()，它实际上会修改window对象 Foo(); // undefined window.bar; // "baz" 相反，将普通的函数作为构造函数运行，你会得到一个新的空对象，正如你看到的那样。 const pet = new String("dog"); 包装对象(wrapper object)由于函数如String，Number，Boolean，Function等而产生混淆，当使用new调用时，会为这些基本类型创建包装器对象。 String是一个全局函数，它在参数中传递时创建一个原始字符串;它会尝试将该参数转换为字符串。 String(1337); // "1337" String(true); // "true" String(null); // "null" String(undefined); // "undefined" String(); // "" String("dog") === "dog" // true typeof String("dog"); // "string" 但您也可以使用String函数作为构造函数。 const pet = new String("dog") typeof pet; // "object" pet === "dog"; // false 这将创建一个表示字符串“dog”的新对象（通常称为包装对象），具有以下属性： 对象包装器通常也称为包装器对象。Object wrappers are often referred to as wrapper objects, too. Go figure. 自动装箱(Auto-Boxing)有趣的是，原始字符串和对象的构造函数都是String函数。 更有趣的是你可以在原始字符串上调用.constructor，当我们已经了解了基本类型不能有方法时！ const pet = new String("dog") pet.constructor === String; // true String("dog").constructor === String; // true 发生的事情是一个叫做自动装箱的过程。 当您尝试在某些基本类型上调用属性或方法时，JavaScript将首先将其转换为临时包装器对象，并访问其上的属性/方法，而不会影响原始对象。 const foo = "bar"; foo.length; // 3 foo === "bar"; // true 在上面的示例中，要访问属性长度，JavaScript将autoboxed foo转换为包装器对象，访问包装器对象的length属性，然后将其丢弃。 这样做不会影响foo（foo仍然是一个原始字符串）。 这也解释了为什么当您尝试将属性分配给基本类型时JavaScript不会报错，因为赋值是在该临时包装器对象上完成的，而不是基本类型本身。 const foo = 42; foo.bar = "baz"; // Assignment done on temporary wrapper object foo.bar; // undefined 如果你尝试使用没有包装器对象的基本类型，例如undefined或null，它会报错。 const foo = null; foo.bar = "baz"; // Uncaught TypeError: Cannot set property 'bar' of null 总结 并非JavaScript中的所有内容都是对象 JavaScript中有6种基本类型 所有不是基本类型的东西都是一个对象 函数只是一种特殊类型的对象 函数可用于创建新对象 字符串，布尔值和数字可以表示为基本类型，但也可以表示为对象 某些基本类型（字符串，数字，布尔值）似乎表现得像对象，因为JavaScript特色称为自动装箱。 PS:我在评论区发现了一张很好的图片]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ror+psql+puma+nginx部署项目]]></title>
    <url>%2F2018%2F11%2F28%2Fror-deploy-with-puma-and-nginx%2F</url>
    <content type="text"><![CDATA[前言这个过程基本上我花了三个星期，才弄好，其中的有些部署文件还是我直接从项目复制粘贴过来的。现在一整理，发现并没有那么难，那为什么会花费三个星期呢？大部分可能是因为我的无知和对centos的不了解。 例如，我在启动数据库的时候，它告诉我不能以root身份启动，等我切换到普通账户，又告诉我，对文件夹没有写入权限，看得我真的很矛盾。 例如，我在安装pg这个gem的时候，告诉我缺乏依赖，我找到答案yum install libs-devel，又告诉我ruby的版本太低了，很纳闷，我明明装的是最新的ruby版本，之后就一直在缺乏依赖着转圈，等到现在才知道是因为找不到pg_config， pg_config这个文件一般是在/usr/bin文件夹下，但是我安装完没有在这…. 安装ruby如果使用yum安装ruby，版本太低，为了管理ruby版本，我使用rbenv来管理安装参考链接 安装postgresql修改/etc/yum.repos.d/CentOS-Base.repo文件 sudo vi /etc/yum.repos.d/CentOS-Base.repo exclude=postgresql* // 在[base]和[updates]块中加上这一行 安装postgresql sudo rpm -Uvh http://yum.postgresql.org/9.5/redhat/rhel-6-x86_64/pgdg-centos95-9.5-1.noarch.rpm sudo yum install postgresql95 postgresql95-devel postgresql95-server postgresql95-libs postgresql95-contrib 初始化数据库找到psql的安装目录(xxxx)的bin文件夹， xxxx/bin/pg_ctl -D xxxx/data initdb //初始化数据库 xxxx/bin/pg_ctl -D xxxx/data start // 启动数据库 在initdb，可能会出现权限不够的情况，这个时候，查看一下data的权限，发现你应该将用户切换成postgres sudo su postgres 在这一步，会提示你输入密码，如果你不知道密码，就使用以下命令去修改密码 passwd postgres 将用户切换成postgres就可以初始化和启动数据库，也可以使用以下命令 sudo service postgresql-9.5 start // 启动数据库 sudo chkconfig --levels 235 postgresql-9.5 on // psql开机自启动 创建psql的链接用户名和密码 sudo su postgres psql alter user username with password 'password'; create database testdb owner=username; 为puma增加代理cap production puma:restar 这个时候访问端口，发现无法访问，查一下puma的log，发现puma在production环境下是使用socket链接，只能使用nginx做代理了，编辑/etc/nginx/conf.d/default.conf文件，替换下面代码中的username和deploy_path upstream app { # Path to Puma SOCK file, as defined previously server unix:///home/username/deploy_path/shared/sockets/puma.sock fail_timeout=0; } server { listen 80; server_name localhost; root /home/username/deploy_path/current/public; try_files $uri/index.html $uri @app; location @app { proxy_pass http://app; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_redirect off; } error_page 500 502 503 504 /500.html; client_max_body_size 4G; keepalive_timeout 10; } 关于puma的sock的地址，你查一下puma的log确认一下 你可能遇到的问题 在安装pg这个gem的时候，可能会报缺少依赖，或者找不到pg_config文件答：gem install pg --with-pg-config=psql的安装目录/bin/pg_config 报错：ActiveRecord::StatementInvalid: PG::InsufficientPrivilege: 错误: 创建扩展 “uuid-ossp” 权限不够答：需要为psql中的新建username设置super权限 即使你添加了nginx代理，你发现，网站还是无法访问答：可以查一下/var/log/nginx/nginx_error.log，我遇到的原因是权限不够，修改nginx的config，将user由nginx改成root 后续如果遇到瓶颈，不要再继续下去，放下来，明天再来尝试….]]></content>
      <categories>
        <category>rails</category>
      </categories>
      <tags>
        <tag>rails</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器-初探]]></title>
    <url>%2F2018%2F11%2F20%2Fcentos-server-1%2F</url>
    <content type="text"><![CDATA[目前的想法需要了解一下服务器的端的知识，才可以在使用过程中不崩溃。使用中最让我崩溃的是，我在启动pg的时候，使用root身份启动，告诉我不可以使用root身份，使用普通用户启动，告诉我没有文件的读写权限😵 虽然还是没有安装上pg这个gem 1. 新建用户 新建用户，创建密码# adduser tony 赋予root权限找到三个方法：2.1. 修改 /etc/sudoers 文件，找到下面一行，在root下面添加一行 ## Allow root to run any commands anywhere root ALL=(ALL) ALL tommy ALL=(ALL) ALL 2.2. 修改 /etc/sudoers 文件，找到下面一行，把前面的注释（#）去掉 ## Allows people in group wheel to run all commands %wheel ALL=(ALL) ALL 修改用户，使其属于root组: # usermod -g root tony 2.3. 修改 /etc/passwd 文件，找到如下行，把用户ID修改为 0 tony:x:0:33:tony:/data/webroot:/bin/bash 上传ssh-key，关闭密码登录 # ssh-copy-id tony@服务器ip 编辑/etc/ssh/sshd_config #PasswordAuthentication yes 改为 PasswordAuthentication no 2. 安装软件不同系统管理软件的软件不同，对于这个我也是乱乱的，找了一圈，才发现是使用yum安装的…. 3. 启动服务启动的服务的命令（是这样叫吗，或者启动服务的包）大部分在/etc/init.d/文件夹下….]]></content>
      <categories>
        <category>server</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再次尝试pm2-自动化部署]]></title>
    <url>%2F2018%2F11%2F10%2Fpm2-second%2F</url>
    <content type="text"><![CDATA[时间可以给人沉淀，现在再解决一年前的问题，比之前省力✌️。之前尝试过pm2，但是以失败告终。 不知到之前为什么会报nvm的错误，这次使用yum安装node，还算顺利。 # yum install node # pm2 deploy ecosystem.json production setup # pm2 deploy ecosystem.json production 过程中，虽然start了，但是还是无法访问，这个时候，我尝试在服务器上使用node start,发现端口被占用，但是pm2显示还是启动了(因为项目是一年前写的，不知道是不是因为版本太低了还是什么原因)。。。更换端口，可以访问了…. 之前我是想使用ror，但是pg那个gem死活装不上，就还是转用node+mongodb mongodb的安装# yum -y install mongodb-org # rpm -qa |grep mongodb // 验证安装 # rpm -ql mongodb-org-server // 验证安装 # /etc/init.d/mongod start // 启动服务 # netstat -nltp|grep mongo // 查看占用端口 # mongo // 进入数据库]]></content>
      <categories>
        <category>nodejs</category>
        <category>pm2</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拒绝过度使用react]]></title>
    <url>%2F2018%2F11%2F05%2Frefuse-to-overuse-react%2F</url>
    <content type="text"><![CDATA[对于目前三大潮流框架，我先使用的是Angular，用它写了一个购物车，感觉非常好。工作之后，使用的react，用顺手之后，第一解决办法就是想到react，导致有很多过度使用的地方。 这个在原来的基础上，需要做一套和之前的东西功能上完全不一样的东西，于是我暗暗下定决心，尽量不使用react和其它的package… 对于搜索这一块，之前使用react做的，这一次我想要尝试一下使用js去实现…缕了一下，我需要做的 // 请求数据（改变“查看更多”按钮的状态） // 处理数据（根据数据生成html片段） // 渲染dom（将html插入target dom） 请求数据在react 中，通过改变state的状态，js中需要操作button // react this.setState({ isFetch: status }); const Button = (status) => { return ( &lt;button type="button">{status ? '加载中' : '查看更多'}&lt;/button> ) } // js $button.html(getButtonHTML(status)); const getButtonHTML = (status) => { return status ? '加载中' : '查看更多' } 处理数据在react中通过改变state去实现dom的动态插入，react中是写一个组件，js中为了清晰期间，我将每个html片段分成一个文件 // react const List = (list) => { return ( list.map(item => &lt;p>{item.title}&lt;/p>) ) } // js const list = (list) => { return list.reduce((acc, item) => `${acc}&lt;p>${item.title}&lt;p>`) } 渲染domreact是通过改变status，js是将生成的html fragment插入 // react this.setStatus({ list: [...oldList, ...newList] }) // js $container.append(htmlFragment); 总结使用react给我带来的最大感受就是一切组件化，一个问题大变小，是非常容易解决的，组件化可以代码更smart…大胆的去除code的bad smell 明天也是元气满满的一天加油:)]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获得当前页面的小程序码初探索]]></title>
    <url>%2F2018%2F10%2F31%2Fget-current-page-qrcode%2F</url>
    <content type="text"><![CDATA[小程序中，获得小程序中的某一篇文章的分享图片，识别图片中的小程序码进去当前文章的详情页， 问题是如何获得当前页面的小程序码呢？ 微信给提供了三个接口： 接口 A: 适用于需要的码数量较少的业务场景 生成小程序码，可接受 path 参数较长，生成个数受限，数量限制见 注意事项，请谨慎使用。接口 B：适用于需要的码数量极多的业务场景 生成小程序码，可接受页面参数较短，生成个数不受限。接口 C：适用于需要的码数量较少的业务场景 生成二维码，可接受 path 参数较长，生成个数受限，数量限制见 注意事项。 其中，第二个接口的中的其中参数最多接受32个字符。第一和第三的生成个数最多是十万张 步骤 通过小程序的appid和密钥去获得access_token(有效期两个小时) 通过access_token和相应的参数去获得图片的二进制流 将图片的二进制流转换成base64就可以显示了 因为需要canvas将小程序码画出来，调试工具上可以画出来base64的图片，但是在android和iPhone都显示不出来…所以前端去获得小程序是不能完成想要的功能的。和后端沟通的结果是：后端去获得图片返回给前端图片的临时地址… 附上代码： request(`https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=appid&amp;secret=secret`) .then(res => { request(`https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=${res.data.access_token}`, { page: '你的page', scene: 'id=2' }, 'POST') .then(res => { // arrayBufferToBase64 }) })]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在小程序中画图的第二次体验]]></title>
    <url>%2F2018%2F10%2F29%2Fcanvas-in-weapp%2F</url>
    <content type="text"><![CDATA[今天的主要任务是画一个分享的海报，基于之前的一次经验，这次遇到的坑比较少，也更有耐心了🙂️ canvas中绘制网络图片canvas中的drawImage中的第一个参数是图片的地址，但是不能是网络图片，解决的办法是：先下载下来，再去绘制 wx.downloadFile({ url: this.data.article.cover_image_url, success: (res) => { if (res.statusCode === 200) { // cover this.ctx.drawImage(res.tempFilePath, 0, 0, width, height); } } }); 给图片来再来个遮罩 this.ctx.setFillStyle('rgba(40, 40, 40, 0.3)'); this.ctx.fillRect(0, 0, width, height); 基于canvas在小程序中的是原生组件实现的，层级高于普通元素，怎么将它隐藏？ opcity: 0; visibility: hidden; 测试了一下是不可以的…. position: absolute; left: 10000rpx; // 给它一个巨大的偏移 之前是做了一个切换，需要绘制canvas的时候就显示出来，但是这样会有一个闪烁的效果，所以想着有没有一个能让canvas看不见又能导出图片的方法，方法一在虚拟机上是可行的，但是在真机上canvas是能显示出来的…plan A pass，幸运的是plan B可行….赞 canvas中的最重要是获得canvas的实际高度之前试过直接拿着dom的高度去设置canvas的高度，但是每个手机上的表现是不一样的，有的可能过长，有的可能过短，总之很难预测…canva中排版字体的时候，由于不能自动换行，只能去手动的计算，可能导致的后果是符号显示在行首，正常使用dom的话，通过设置可以避免符号在行首，这样以来，两者对于文字的排版是不一样的，从而高度也是不一样的 补充：在setFillStyle后使用drawImage绘制图片我的图片本来是白的，但是看起来却是灰的，原因竟是我在前面的setFillStyle的操作！！！]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css中rem的注意点]]></title>
    <url>%2F2018%2F10%2F25%2Fcss-rem%2F</url>
    <content type="text"><![CDATA[今天在使用rem中发现了一个之前没注意的点 html { font-size: 10px; } .title { font-size: 1.6rem; } .container { width: 2.4rem; } 其中title的字体大小为16px，但是container的宽度却是28.8px，我算了一下28.8/2.4=1.2，想到浏览器的最小字体是12px，所以我想着可能和最小字体的大小有关系。 于是我尝试将chrome的最小字体设置为最小（比12px还小），发现container的宽度是24px。 去查资料没有找到相应的资料，可以了解的是rem最好使用在font-size上，使用在margin和padding上也会出现和期望不用的值。]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你能把这两个查询变成一个吗]]></title>
    <url>%2F2018%2F10%2F22%2Ftwo-select-change-one%2F</url>
    <content type="text"><![CDATA[今天写了一个方法，被问到这两个查询能改成一个查询吗？ def get_producer_name str = producers.limit(3).map{ |producer| producer.name } str += '等' if producers.count > 3 end 在上面的代码中，producers.limit(3)和producer.count会进行两次查询，要变成一个查询，肿么办？ def get_producer_name pros = producers.limit(4) str = pros[0...2].map{ |producer| producer.name } str += '等' if pros.length > 3 end 一次性查出来前四条！这个方式真的很赞👍！是否给了你新的idea🤔️]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>pg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stimulus初体验]]></title>
    <url>%2F2018%2F10%2F22%2Fstimulus-begin%2F</url>
    <content type="text"><![CDATA[demostimulusts作为js的超集，应用率也是非常广泛，在github上看到一个有趣的框架，于是想着从hello word走起，看完栗子有，我尝试写一个列表… &lt;div data-controller="content-loader" data-content-loader-url="/message.html" data-content-loader-refresh-interval="5000">&lt;/div> &lt;h1>list controller&lt;/h1> &lt;div data-controller="list" data-list-initial='["name"]'> &lt;div> &lt;input type="text" data-target="list.text" value="hello1"> &lt;button data-action="click->list#add">add&lt;/button> &lt;/div> &lt;div data-target="list.items">&lt;/div> &lt;/div> import { Controller } from 'stimulus'; export default class extends Controller { static targets = ['text', 'items', 'item']; connect() { this.getInitialItems(); } get items() { return this.items; } set items(newItems) { this.items = newItems; this.render(newItems); } get text() { return this.textTarget.value; } getInitialItems() { try { this.items = JSON.parse(this.data.get('initial')); } catch(e) { this.items = []; console.error(e) } } render(items) { this.itemsTarget.innerHTML = items.reduce((acc, item, index) => { return acc + `&lt;p data-target="list.item">&lt;span>${item}&lt;/span>&lt;button data-id="${index}" data-action="click->list#deleteItem">delete&lt;/button>&lt;/p>`; }, ''); } add() { this.items = this.items.concat(this.text); } deleteItem(event) { const targetIndex = event.currentTarget.dataset.id; const newItems = [ ...this.items.slice(0, targetIndex), ...this.items.slice(targetIndex + 1) ]; this.items = newItems; } } 看起来非常good，于是开始运行，发现死循环了，检查了代码没发现错误，尝试debugger发现程序一直在执行set操作，很纳闷，没执行set呀。找机会问了哟哟，他告诉我，在set中尝试给this.item意味着你在set调用set本身，于是乎，死循环了… get items() { return this._items; } set items(newItems) { this._items = newItems; this.render(newItems); } 修改成以上代码可以正常工作。 思考：1、如果以上面的方式进行，我觉得还不如做成面向对象中的set/get….这只是我个人的想法 将html写在js中一点都不优雅，我找到了一个demo，它提供一个更好的方式。 使用stimulus，思维方式和传统的js相似 在stimulus中，数据和元素不是一一对应的，所以在deleteItem中直接删除元素并且改变items的方式会不会比通过数据去改变dom更好一点？虽然二随一变会容易出bug，但是考虑到列表可能会很多，删除一个元素比重新渲染整个列表代价小很多吧…..]]></content>
      <categories>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这一部分是否需要使用react]]></title>
    <url>%2F2018%2F10%2F14%2Fwhether-to-use-react%2F</url>
    <content type="text"><![CDATA[最近在重构项目中，发现了很多过度使用react的地方，现在想想原因是：1. 时间紧迫 2.被react的状态管理迷花了眼睛，总之是没磨好刀就砍柴了… 又一个左右布局三七分的页面，左边是一堆可以switch check的条件，右边的上部是checked的条件，中间是筛选结果列表，下部是分页。 使用react实现，总之要注意的是对状态的管理。但如果是使用jq实现，我仔细的想了一下，啊，左边和右边上部的数据的一致性可以通过元素选择器来保证，总之，使用jq，没有了一个全局状态，右边需要获得checked的条件，只能通过元素的不同来得到，假如选择的条件改变了，我需要先去获得选择的条件，然后再去改变右边的dom，我该如何去渲染dom，写一个函数，输入变量，输出为html string，咦，这不相当于react component嘛。 总之，使用react去实现是维护的一个全局状态变量，使用jq，是通过dom去得到状态变量…这是我对两种实现方式的认知….至于使用哪一个，还需要了解一下需求… PS：总之，离开了react，使用js不是一个困难的事情，磨刀呀…]]></content>
      <categories>
        <category>react</category>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[翻译：reference equality and value equality]]></title>
    <url>%2F2018%2F09%2F26%2Freference-equality-and-value-equality%2F</url>
    <content type="text"><![CDATA[在编程语言世界中通常有两种类型的相等： reference equality value equality 引入思考下面的代码： var x = 12, y = 12; var object = { x: 1, y: 2 }; var object2 = { x: 1, y: 2 }; 正如你看到的，object和object2有相同的值。如果你看一下object和object2中的每个键以及它们对应的值，它们是相同的。在object和object2中，x的值是1，y的值是2。 但是当你想要在你的程序中检查object和object2是否相等，你会发现：这两个对象是不一样的。 object == object2 // false object === object2 // false 这是为什么呢？ reference equalityObjects是灰常复杂的数据结构。它们可以有很多key，这些key可以执行不同的值。这些值也可以是objects，所以objects是可以嵌套的。 如果你考虑事物的相等行，事实上你需要考虑两件事情： 一个事物是否意味着与另一个事物相同？ 一个事物与其它东西完全一样？ 如果我从现实世界中举一个例子：想象一下你有一个红色的跑车，你的邻居也有和你的车一样的车，相同的颜色，相同的发动机，相同的牌子。如果陌生人经过你的家，他们会说：嘿，这些人有相同的车。 但是，你邻居的车不是你的。你不会坐上邻居车，认为这是你的，对吧，或者至少你不应该。如果你撞坏了邻居的车，你可能会有一个不快乐的邻居，当然还有一些法律问题:) 区分你的车和邻居的车的最明显的地方是车牌。 事实上， JavaScript objects的内置了这种“牌照”，每个object的独特特性称为reference（引用）。当你在js中比较object时，它们通过reference比较 object == object2; object === object2; 问题：object和object2是相等吗？实际上你分配变量的时候，也分配了reference。你可以很容易的检查这个： object = object2; object == object2; // true object === object2; // true 也会有一些有趣的结果，代码如下： object = object2; object.x = 12; object.x; // 12 object2.x; // 12 在这个例子中，你做了一次将x这个key分配给object这个对象。object和object2指向相同的引用，所以只要一个变量更改，另一个变量也会更改。 JavaScript中的复杂的数据结构都遵循reference equality的原则，这包括arrays和objetcs，实际上通过typeof查看array的类型，得到的结果也是object。 还有一些值像：numbers, strings, booleans or null / undefined，它们都遵循一种相等：value equality。 value equality像前面说的，reference equality回答的是object1和object2是否一样？这种检查很简单，它们非常有效。 说到Javascript中的primitives（这个我也不知道怎么翻译18.12.21更新：上面的primitives指的是Primitive types（基本类型）, 指的是上面的numbers等)，它们是不可以嵌套的。这种不能嵌套其它结构的结构称为shallow data structures（浅数据结构）。在这样的结构中，你可以以有效的方式执行value equality。 但是什么是value equality？思考下面的代码： var x = 12, y = 12; 在相等方面，数字是最简单的。你可以清楚的说x变量的值等于y变量的值（12在数学中等于12）但是如果这些变量遵循reference equality，它们是不一样的，因为它们是在不同的地方创建的。所以它们的引用是不同的。x的12可能是和y的12是不一样的。这真是太乱了。 幸运的是，members在JavaScript中是primitives，primitives在javascri中使用的是value equality进行比较。所以看到这是不奇怪的： x == y; // true x === y; // true value equality回答的是这个疑问：一个事物是否意味着与另一个事物相同？ 嵌套的数据结构是的相等更加难以比较。Objects有任意的key和value，它可以包含其他的objects。为了比较两个objects的相等，你可能需要下面的算法： / Input: an object1 and object2 // Output: true if an object1 is equal in terms of values to object2 valueEqual(object1, object2): object1keys = &lt;list of keys of object1> object2keys = &lt;list of keys of object2> return false if length(object1keys) != length(object2keys) for each key in object1keys: return false if key not in object2keys return false if typeof(object1[key]) != typeof(object2[key]) if object1[key] is an object: keyEqual = valueEqual(object1[key], object2[key]) return false if keyEqual != false if object1[key] is a primitive: return false if object1[key] != object2[key] return true 呼，这里面有好多相等检查，这是一个递归算法。它在比较两个object是会执行上千次相等检查，这样的相等检查通常被称作 deep equality checks（深比较）。更糟糕的是，这个算法是不会完成的。这是因为你可能创建了循环的引用对象。 PS：参考链接]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[immutable-data]]></title>
    <url>%2F2018%2F09%2F25%2Fimmutable-data%2F</url>
    <content type="text"><![CDATA[项目中的apollo主要是用的分页这个功能，但是我在check代码的时候，发现了每次我向列表中push了一个数据，整个列表是全部re-render!!!假如每个是十条数据，等我滑到第十页的时候，100个item是全部re-render的…我去查apollo fetch updata 没有找到结果，我向react-apollo提了issue，感谢G友captDaylight给我的回复。 When you update an item in a list with immutablility helper its returning a brand new array, so it’ll have a new reference. So that list in React’s eyes is completely new, even if structurally most of the items in the array are the same. Thus each item will be re-rendered. 开始，我的重点是放在immutablility-helper，但是查了好久也没找到why 这个时候，我查了项目中使用state的列表，发现它只会re-render新增的数据，于是我使用redux来渲染list，发现它也是全部re-render所有item。state和redux的差异在哪？redux中使用的是immutable data，于是我去查文档。 1. What are the benefits of immutabilityimmutability可以为你的应用程序带来更高的性能，并且可以简化变成和调试。在整个应用程序中，从不会更改的数据比可以随意更改的数据更容易理解。 特别的，Web应用程序环境中的不变性可以使复杂的变更检测变得更简单和廉价，确保计算成本高昂的DOM更新过程只发生在绝对必要的时候（这是React相对于其他库性能改进的基石）。 2. Why is immutability required by Redux? Redux和React-Redux都使用浅等式检查。尤其是： Redux的combineReducers实用程序浅层检查由它调用的reducer引起的引用变化。 React-Redux的connect方法生成的组件浅层地检查对根状态的引用更改，以及来自mapStateToProps函数的返回值，以查看包装的组件是否实际需要re-render immutable data的管理最终使数据更安全 Time-travel debugging要求reducers是没有副作用的纯函数，因此你可以在不同的状态之间正确跳转。 3. Why does Redux’s use of shallow equality checking require immutability?如果要正确的更新任何connected组件，Redux使用 shallow equality checking（浅检查），要了解原因，我们需要了解 shallow equality checking和deep equality checking（深检查）之前的区别。两者的区别是：shallow equality checking只是简单的检查两个不同的变量是否是相同的引用；相反，deep equality checking必须检查两个对象属性的每个值。 4. How does Redux use shallow equality checking？Redux在combineReducers函数中使用浅等式检查来返回根状态对象的新变异副本，或者，如果没有进行任何突变，则返回当前根状态对象。 5.How does React-Redux use shallow equality checking?当根状态对象的引用改变时，对于有mapStateToProps的组件，检查mapStateToProps的返回值，如果返回值不变，则组件不会re-render。 对于下面这个组件，如果state.todos和getVisibleTodos返回的值不变时，这个组件不会re-render function mapStateToProps(state) { return { todos: state.todos, // prop value visibleTodos: getVisibleTodos(state) // selector } } ​ export default connect(mapStateToProps)(TodoApp) 对于下面这个组件，始终会re-render，因为todos的值始终是新对象，无论它的值是否更改 // AVOID - will always cause a re-render function mapStateToProps(state) { return { // todos always references a newly-created object todos: { all: state.todos, visibleTodos: getVisibleTodos(state) } } } ​ export default connect(mapStateToProps)(TodoApp) 6. 如何避免不必要的render？和shouldComponentUpdate搭配使用，PS:shouldComponentUpdate返回的值是建议性的，所以在组件中你返回false，组件有可能re-render。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HOC在react中的调用顺序]]></title>
    <url>%2F2018%2F09%2F20%2Fhigh-oreder-component-tip%2F</url>
    <content type="text"><![CDATA[question今天遇到了一个问题：写了一个高阶组件，使用的时候竟然告诉我props is required, but it is undefined??? // FormWrapper.jsx const FormWrapper = initialState => Component => { class FormInnerWrapper extends React.Component { state = initialState checkFeildValid = (value, type) => { // ... } changeValue = (value, type) => { // ... } isFormValidate = () => { // ... } render() { return &lt;Component data={this.state} changeValue={this.changeValue} isFormValidate={this.isFormValidate} {...this.props} />; } } return FormInnerWrapper; }; FormWrapper.propTypes = { initialState: PropTypes.object.isRequired, }; export default FormWrapper; // MyForm.jsx @FormWrapper({ xxx: 'xxx', xxxx: 'xxx' }) class MyForm extends React.Component { // ... } MyForm.propTypes = { isFormValidate: PropTypes.func.isRequired, data: PropTypes.object.isRequired, changeValue: PropTypes.func.isRequired, }; export default MyForm; react给我三个warning： The prop `data` is marked as required in FormInnerWrapper, but it is undefined. The prop `isFormValidate` is marked as required in FormInnerWrapper, but it is undefined. The prop `changeValue` is marked as required in FormInnerWrapper, but it is undefined. debug我检查了代码，发现我没有对FormInnerWrapper定义propTypes， 我只对MyForm进行了propTypes定义。我尝试给MyForm加上defaultProps,其中data的default值为null，在调试的时候发现data的值永远为null, 不会去改变🤔️。发生了什么？ plan B于是我尝试了下面的格式： // MyForm.jsx export default FormWrapper({ xxx: 'xxx', xxxx: 'xxx' })(MyForm); 发现没有warning。 why装饰器的写法是从左到右执行？？？第二种写法比较符合正常的调用顺序？？我需要再去查decorator与HOC的具体区别…PS: 上次的immutable data疑问，在今天终于得到了解决，下一篇见～]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stateless component vs Pure component in react]]></title>
    <url>%2F2018%2F09%2F13%2Fstateless-component-vs-pure-component%2F</url>
    <content type="text"><![CDATA[介绍1. stateless componentstateless component声明为一个没有state的function const Article = (props) => { return ( &lt;div> // ... &lt;/div> ) } react的文档中这样说到： These components must not retain internal state, do not have backing instances, and do not have the component lifecycle methods. They are pure functional transforms of their input, with zero boilerplate. However, you may still specify .propTypes and .defaultProps by setting them as properties on the function, just as you would set them on an ES6 class. 2. pure componentpure component是最大的意义是优化React应用的性能。使用PureComponent可以大大的提高性能，因为它减少render的次数。 3. 对比两者的性能class Welcome extends React.PureComponent { render() { return &lt;h1>Welcome&lt;/h1> } } Hello = () => { return &lt;h1>Hello&lt;/h1>; } 以上例子是一个非常简单的Welcome(Pure Component)和Hello(Stateless Component)。当你在父组件中使用它们，你会发现当父组件re-render时，Hello就会re-render，但是Welcome就不会。 这是因为PureComponent改变了生命周期中的shouldComponentUpdate方法，并且添加了一些逻辑用来自动检查组件是否需要re-render。这允许PureComponent仅仅在检测到state或者props改变时，才会调用render方法。 使用1. 什么时候使用Pure Component假如你创建一个字典的页面，在该页面中显示所有以A开头的单词的含义。这个时候，你可以写一个接收props为heading和meaning并返回视图的组件。假如你使用分页每次只显示10个单词，当滚动时，再去请求另外10个单词并且在父组件中更新state。在这种情况下，应该使用Pure Component，它将会避免render之前请求到的所有单词。 此外，在你要使用Component的生命周期函数时，你必须使用Pure Components，因为stateless components没有生命周期函数。 2. 什么时候使用Stateless Component假如你想要创建一个漂亮UI的lable用来评估个人资料的可信度，例如初学者，中级，高级。由于它是一个很小的组件，其重新渲染几乎没有任何区别，并为这种small case创建一个新的组件将是耗时的。如果你继续为很小很小的view创建组件，很快，你将会遇到更多的组件，在一个大型项目中，它们会变得很难管理。同时应该牢记Pure Component具有shallowEqual（浅比较）的特性。 3. 结论Pure Components会使性能大幅提升，因为它减少了应用中render的次数。这对于一份复杂的UI是个巨大的胜利，因此建议尽可能的使用。此外还有一些情况需要使用生命周期函数，在这种情况下，我们不能使用stateless components。 Stateless Components可以简单而快速的实现。这对于一个re-render代价小的非常小的UI视图是很好的。它们提供更清晰的代码和更少的文件来处理。它最好的使用场景应该是在父组件为Pure Component或者HOC中使用。 后记项目中使用的Apollo，我尝试将stateless component改为pure component，但是组件还是会re-render。Apollo中数据是immutiable，并且每个item在list中都有key，但是不知道为什么还是会重新渲染，十分纳闷啊。我已经提了issue，期待有答复～如果找不到好的方法来解决，我只能为每个pure comoponent增加shouldComponentUpdate了… 参考链接]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多瞅了几眼react blog]]></title>
    <url>%2F2018%2F09%2F08%2Freact-blog%2F</url>
    <content type="text"><![CDATA[react的生命周期 问答 ajax为什么不在componentWillMount进行，而在componentDidMount中进行？ajax是一个异步操作，在render调用之前，不会在一步操作中返回数据，这意味着组件将使用default数据呈现至少一次；同时，在异步操作的callback中更新state不会触发re-render。另外，没有办法在等到返回数据后再去掉用render。react文档建议到：componentDidMount会在组件挂载后立即调用，需要dom节点的初始化应放在这里。如果你想远程获得数据，这是实例化网络请求的好地方。在这个方法中，调用setState这个方法会触发额外的render，它保证会在同一时间刷新，意为：即使你在这个情况下中调用render两次，用户不会看到中间的状态。 componentWillReceiveProps会执行一次还是多次？多次，所以你在这个使用这个方法时，需要比较current props和 next props。 setState是同步的还是异步的？异步。setState会触发re-render，如果是同步的话，可能会导致浏览器无反应。异步是为了获得更好的UI体验和性能。 Component和PureComponent的区别？PureComponent在shouldComponentUpdate中对props进行浅比较，而Component则进行深比较。 react的事件机制react中的事件在真实DOM中是全部挂在以事件代理的方式挂在document上面，事件代理的机制是事件冒泡。这是在react的事件中使用原生的阻止事件冒泡不起作用的原因。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序总结]]></title>
    <url>%2F2018%2F09%2F01%2Fweapp-tip%2F</url>
    <content type="text"><![CDATA[如果你使用了canvas 、map类的组件，因为小程序是使用原生控件，无论你是怎样调整z-index，都不可能覆盖到这类组件上。网传的z-index设置为1000以上，经过实践是不起作用的。请使用cover-view。但是cover-view无法增加shadow和border。border可以通过使用cover-view的背景色来代替。shadow可以使用cover-image来代替。 正确的选择scroll-view和page。两者都能实现下拉刷新，上拉加载。通过业务，选择最适合的方案。 自定义导航栏时，通过getSystemInfo得到statusBarHeight在页面上使用px定义，而不是rpx来定义。 自定义导航栏时，如果有监控page的滚动的需求，请选择scroll-view来实现。在使用onPageScroll时，在iphonex上会导致上方自定义的导航栏抖动。测试的时候，会看到页面滚动时，iphonex上方有1px的空隙…. 小程序在iphonex的下方的安全边距为68rpx ios上会有自带的橡皮筋效果，记得保证页面下部的颜色与page的背景色相同 如果想实现保存图片的功能，需要通过canvas去画出图片，canvas的高度需要按照实际的内容计算出来。 待续…]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今天经历的小程序的滑铁卢]]></title>
    <url>%2F2018%2F08%2F28%2Fjoker-weapp-4%2F</url>
    <content type="text"><![CDATA[今天遇到的一个问题是：在页面滚动过程中，可能会导致fixed的元素被遮盖住（偶尔），这个bug早在17年就被提及，但是到现在还没有修复… 键盘弹起对于页面有两个选择，是否推起页面，尴尬的是推起页面，页面会滑动；不推起页面，动态改变fixed的元素的bottom，也很尴尬；不知道有没有好的办法； 建议小程序出一个设计趋势，很多坑的出现是因为在小程序中使用和app等同的效果，生态局限性对开发者是一个很大的挑战，也是一个巨浪费时间的开发过程…]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矛盾：技术与本质]]></title>
    <url>%2F2018%2F08%2F26%2Fmixed-talk-1%2F</url>
    <content type="text"><![CDATA[今天读到一本书，其中有一句话很有感触： 我们很容易沉浸在技术里，而忽略了生命的真谛。 当然这不是一本讲技术的书，但它成功的引起了我的注意。 人生处处是矛盾，人以主观意识来认识别人，但主观意识又会影响你对对方现在的感觉。士别三日刮目相看，即是处理矛盾的一种方式，以主观并且发展的眼光看待别人。 大一大二的课程最主要的是学习语言与算法。大三的课程是来学习关于产品和测试的。由于大三的可能比较偏重于理论，所以对待起来不是太看重。如此一来，等到毕业答辩的时候，矛盾就凸显出来了。 对待毕业项目来说，我是抱着一定要用到最新的技术来的。我使用express搭了一个框架，使用mongodb作为数据库。继而，手机端适应inoic做了一个webapp，当时觉得自己的目的已经达到了，我尝试使用了比较流行的技术做出来了一个还能看的demo（那时候的整体逻辑很是简单，现在一看到处是bug，看上去比较无组织无纪律）。在小组答辩，老师会注重看你的demo，进入大组后，评委就注重论文了。在我答辩完，评委问我：有人在用吗？我说没有。之所以我把它叫做demo，我就没把它当作一个产品来对待。但是评委们要的是一个产品，他们不会care你用了什么技术，他们只是要一个结果：成熟的产品。这是一个很矛盾的事情，究其原因，就是二者的关注点不同，我关注的是技术，对方关注的是一个成熟的产品，关注点不同，最后出现矛盾是一个再正常不过的是事情。总之，这是我遇到的第一件充满矛盾的事情。 最近遇到的一件事是，黑发（暂且这么叫吧，因为他的头发真的好多啊）问了我一切基础的问题。虽然自身没有为这些问题做任何准备，但是想着应该也能答上来吧。印象最深刻的问题是时间委托的机制，emmm，当时对这个问题手足无措，我最先想到的是设计模式。我说的是一塌糊涂，现在想想是在瞎扯。接着又问我委托的原理，依然一脸懵逼，我问了答案：事件冒泡。啊，我怎么把这么基础的给忘了呢。。。总之给我带来的冲击很大。结果又问我jsonp的机制，我又是一脸懵逼，黑发很震惊：你是真不知道还是假不知道…我排斥跨域，所以就没有了解过…黑发告诉我跨域这种场景还是很常见的，即使你排斥，但也需要了解它… 经过这次交谈，我不仅想，我到底做了些什么… 想了想大部分的工作时间都在写业务，业余的时间，自己就捣鼓一些小东西或者看一些书，拓展思维。大部分的时间，都在想着解决问题。例如事件委托，我是把它当作一个解决方法来看，当我遇到类似的问题，我会想到用这个方法来解决…我仅仅把它当作一个答案来看…渐渐的，我忘了本质。这个时候忽然想到在大学的时候，有位院长给我们上课，讲的内容也很是高深，根本就听不懂啊。我把这种现象称之为：title越高，就渐渐的忽略了最基础的东西。这与我现在的状况，不谋而合。 在技术的长河中，不仅需要积极的寻找解决问题的方法，还需要了解技术的本质。 这是今天的杂谈，明天也是元气满满的一天哦，不对，已经明天了，今天也是元气满满的一天哦😄]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[没写小程序之前，我还是快乐的空空（下篇）]]></title>
    <url>%2F2018%2F08%2F24%2Fjoker-weapp-3%2F</url>
    <content type="text"><![CDATA[如何自定义导航栏？ 这个需求的来源是：我向朋友转发了小程序中的页面，对方打开后，左上角是没有返回按钮的，这时候，右上角有一个去主页的标志是很合适的… app.json中设置属性: navigationStyle这意味着你的小程序是全屏显示的，title，还有左上角的路由状态需要自己去处理 每个设备的上面的statusbar的高度是不一样的，自制的导航栏的高度就是未知的，这个只能通过getSystemInfo去获得 需要对之前的fixed做一下处理，还是需要statusbar的值，设置margin-top 目前是这样的一个思路，暂时没发现其它的问题…顺便吐槽一句，小程序的开发者是经历过从C++转到python嘛….]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[没写小程序之前，我还是快乐的空空（上篇）]]></title>
    <url>%2F2018%2F08%2F24%2Fjoker-weapp-2%2F</url>
    <content type="text"><![CDATA[如何在小程序里面保存图片？ plan小程序可以将canvas保存成一张图片。现在主要的任务是将canvas中的内容画出来web端有一个叫做html2canvas，对于小程序，暂时没有找到相似的工具库…只能自己来画了目前，需要画出来的是： 背景纹理 title 图片 progress设置画布的大小ctx.rect(0, 0, width, height); 这里的遇到的问题，如何得到画布的高度…我先用html写出来结构，得到内容的高度，另一种方法是先去计算，emmm…这种方法还没想好思路 8-27更新：使用html的高度，和canvas画出来的排版不一样，不同的手机上的排版还不一样，最后导致的问题是在不同的手机上导出的图片要不是过短要不就是下面长出一截，最好还是一个一个元素的计算吧，确定每个元素的起点的y坐标 heightInfo.hrTop = heightInfo.xxxxxTop + titleInfo.height + 20; heightInfo.xxxxTop = heightInfo.hrTop + 24; heightInfo.xxxTop = heightInfo.xxxxTop + 14 + 20; heightInfo.xxxxTop = heightInfo.xxxTop + xxxInfo.height + 36; heightInfo.xxxxTop = heightInfo.xxxxTop + 90 + 7; this.height = heightInfo.xxxxTop + 14 + 30; 在这个过程中可以直接将多行字符串分割….还有一个将数字定义成常量 画背景纹理，每隔10画一条横线，竖线这个是重复画线的一个过程 drawLine: function(fromX, fromY, toX, toY, lineWidth = 1) { this.ctx.beginPath(); this.ctx.setLineWidth(lineWidth) this.ctx.moveTo(fromX, fromY); this.ctx.lineTo(toX, toY); this.ctx.stroke(); }, // .... const step = 10; const countX = width / step; const countY = height / step; for (let i = 0; i &lt; countX; i++) { drawLine(i * step, 0, i * step, height); } for (let i = 0; i &lt; countY; i++) { drawLine(0, i * step, width, i * step); } title涉及到文字换行，canvas不能主动对超出的文字做换行处理，处理的方法是拿到字符片段长度与最大宽度依次比较 const arrText = text.split(''); const line = ''; for (let n = 0; n &lt; arrText.length; n++) { const testLine = line + arrText[n]; const metrics = this.ctx.measureText(testLine); const testWidth = metrics.width; if (testWidth > maxWidth &amp;&amp; n > 0) { // 超出一行，打印 ctx.fillText(line, x, y); line = arrText[n]; y += lineHeight; } else { line = testLine; } } ctx.fillText(line, x, y); 图片这个涉及到居中显示 // 计算出图片的起始点即可 // use drawImage 过程中遇到的问题canvas的层级过高，会遮盖view元素，解决办法是使用：croll-view另一个问题是：croll-view设置border或者box-shadow不起作用，次而求之，再用一个croll-view假装边框吧….]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我经历了小程序的哪些坑]]></title>
    <url>%2F2018%2F08%2F17%2Fjoker-weapp%2F</url>
    <content type="text"><![CDATA[在这个可爱的节日里，让我来说说，写小程序的坑～ 对小程序的期待就像对vue的期待一样，看着文档就能写…可是，我踩了一个又一个的坑… textarea的padding问题为textarea设定了上下12rpx的内边距，在安卓机上十分完美，但是从测试那边反馈的结果是：框太高了…于是就去看看网上的讨论，在这吐槽一下，度娘真的是用中文都检索不出来结果…查了结果之后，发现textarea的内边距在安卓和iOS上的差别很大…我有以下方案： 不使用textarea的内边距，外面套一层view，为view添加内边距。实践的结果是：不行。看到有答案说：textarea使用的原生组件，任何padding、line-height都对此不起作用 为view设置box-sizing: border-box，这么一设置，textarea的auto-height都不起作用了，扎心… 没办法了，我只能去区别手机系统了：wx.getSystemInfo({ success: (res) => { if (res.model.match('iPhone X') !== null) { this.globalData.isIphoneX = true; } if (res.platform === 'ios') { this.globalData.isAndroid = false; } } }) view层通过判断getApp().globalData.isAndroid的值，如果为true，则加padding，否则，不加 padding。 iphone的橡皮筋效果如果你的页面有header、body、footer，header是白色，body是灰色，footer是白色，page本身是灰色，那么你在iphone上上拉页面，会看到灰中一块白，如何去调整，当然是遮盖再遮盖…这个效果，体验特别差… iphone X的安全边距找到的资料是安全边距是68rpx，这个时候，如果你有一个固定到下方的footer，和出现上面的问题，那么一定得好好想想如何去遮遮遮… input和textarea的选择textarea有一个auto-height的属性，可以自动根据内容去改变高度；但是input有手机键盘会有完成而不是回车的键，同时也会有一个点击完成键盘不收起的选项；总之你可以根据这两个特性去选择你需要的组件，加入需要input的属性，又需要textarea的属性，input是最好的选择…以我的经验来说 页面即有上拉加载又有下拉刷新一定要选用Page的特性，而不是scroll-view 打开键盘是否推起页面先考虑不推起页面，再考虑推起页面…因为推起页面显得特别不自然…. 得到globalData中的值如果你想以下面的格式来得到globalData的值，可能会出乎你的意料 Page({ data: { isIphoneX: app.globalData.isIphoneX, // 同步得到，可以得到正确的值 isLogin: app.globalData.isLogin, // 异步得到，得不到正确的值 }, }) 没办法，我只能在page的onload中再重新赋值一次…. 8-17，先写到这…]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我经历了小程序的哪些坑]]></title>
    <url>%2F2018%2F08%2F17%2Fjoker-xiaochengxu%2F</url>
    <content type="text"><![CDATA[在这个可爱的节日里，让我来说说，写小程序的坑～ 对小程序的期待就像对vue的期待一样，看着文档就能写…可是，我踩了一个又一个的坑… textarea的padding问题为textarea设定了上下12rpx的内边距，在安卓机上十分完美，但是从测试那边反馈的结果是：框太高了…于是就去看看网上的讨论，在这吐槽一下，度娘真的是用中文都检索不出来结果…查了结果之后，发现textarea的内边距在安卓和iOS上的差别很大…我有以下方案： 不使用textarea的内边距，外面套一层view，为view添加内边距。实践的结果是：不行。看到有答案说：textarea使用的原生组件，任何padding、line-height都对此不起作用 为view设置box-sizing: border-box，这么一设置，textarea的auto-height都不起作用了，扎心… 没办法了，我只能去区别手机系统了：wx.getSystemInfo({ success: (res) => { if (res.model.match('iPhone X') !== null) { this.globalData.isIphoneX = true; } if (res.platform === 'ios') { this.globalData.isAndroid = false; } } }) view层通过判断getApp().globalData.isAndroid的值，如果为true，则加padding，否则，不加 padding。 iphone的橡皮筋效果如果你的页面有header、body、footer，header是白色，body是灰色，footer是白色，page本身是灰色，那么你在iphone上上拉页面，会看到灰中一块白，如何去调整，当然是遮盖再遮盖…这个效果，体验特别差… iphone X的安全边距找到的资料是安全边距是68rpx，这个时候，如果你有一个固定到下方的footer，和出现上面的问题，那么一定得好好想想如何去遮遮遮… input和textarea的选择textarea有一个auto-height的属性，可以自动根据内容去改变高度；但是input有手机键盘会有完成而不是回车的键，同时也会有一个点击完成键盘不收起的选项；总之你可以根据这两个特性去选择你需要的组件，加入需要input的属性，又需要textarea的属性，input是最好的选择…以我的经验来说 页面即有上拉加载又有下拉刷新一定要选用Page的特性，而不是scroll-view 打开键盘是否推起页面先考虑不推起页面，再考虑推起页面…因为推起页面显得特别不自然…. 得到globalData中的值如果你想以下面的格式来得到globalData的值，可能会出乎你的意料 Page({ data: { isIphoneX: app.globalData.isIphoneX, // 同步得到，可以得到正确的值 isLogin: app.globalData.isLogin, // 异步得到，得不到正确的值 }, }) 没办法，我只能在page的onload中再重新赋值一次…. 8-17，先写到这…]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react和websocket的实现实时推送]]></title>
    <url>%2F2018%2F08%2F15%2Fwebsocket-push%2F</url>
    <content type="text"><![CDATA[刚听到这个需求的时候，好慌…之前没做过，该怎么办？ plan A我的大脑迅速闪过一个方案：收到信息就在右上方弹出消息块，然后过个五秒，就把自己删除。接着我去查：react如何把自己删除，得到的答案是：移除组件必须是父组件去移除。此计划不行，怎么办？ 接着我继续想，不行啊，我得记录之前的消息，要是两秒内来个三条消息，新的就把旧的遮住了… plan A over了，plan B此时，我想到了一个package：react-s-alert，这个组件可以满足我的需求呢，但是，我如何自定义我的消息块，只有一个message的选项，可是我的消息块类型有好几种呢，我难道要去拼接字符串？仔细想想，不可以呀，都用react了，得用组件啊，但是看了参数，好像没找到解决办法。仔细想了想，嗯，我要的核心是和它一样的，这样我改改view层，就可以用了，此方法可行。于是我fork、clone，开始仔细看源码…. 哇，这个组件内部实现了一个迷你的redux，好酷，看不懂呢，我查的时候，看到了一个叫React小书，里面有一部分是主要讲这个的，看了讲解，能稍微看懂了。于是我知道这个组件的内部的大概逻辑。仔细想了想，我是写一个插件块呢还是拼接字符串快呢？目前的阶段先用拼接字符串吧。 项目内部已经使用salert来作为全局的弹框了，我要是还用它来显示消息块，这个组件是使用一个store，这会影响我的消息块的显示！！这个时候，我还在认真的想着怎么去解决这个问题…. 终极解决方案忽然灵机一动，这不就是把东西存到store里面，展示成一个列表嘛！！！唯一多出的东西就是在每个item内部加一个timeout，显示几秒后，移除。这个时候忽然想到这个终极的解决办法的我，真的是！！！ 为什么是这样的一个心理活动仔细分析了我的全部心理活动，为什么这个解决方案如此常见，我没有想到呢！！刚开始一听到实时推送，没听过，听起来很高级呢，很难吧…于是自己把自己吓住了，人在不清醒的状况下，无法正常的思考问题…于是我开始了一系列的plan，绕了一圈才想到正常的方法。只是当我想到最后的方案时，但是带给我的冲击太大了，就是 乱花渐欲迷人眼， 我的眼睛被迷住了，当清醒的那一刻…. 过程还是不错的，我学到了如何构建一个mini的redux，现在需要努力的是：如何在大脑不清醒的状态下进行思考…多玩玩恐怖的密室逃脱 PS: 炒鸡推荐一款游戏 human resource machine，希望我没写错吧，这款的游戏对于我来说是锻炼算法和逻辑能力的，仔细画流程图还是能找到解决办法…解可能不是最优解，去搜搜最优解， 有对比才有爱❤️]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[翻译：在使用React工作一年后，我学到了最重要的经验教训]]></title>
    <url>%2F2018%2F08%2F10%2Ftranslate-mindset-lessons-from-a-year-with-react%2F</url>
    <content type="text"><![CDATA[前原文链接在M站经常能看到优秀的文章，昨天看到的一篇文章今天在看公众号推荐的文章中，就看到了这篇文章的译文。我看英文文章也是边看边翻译，阅读后的记忆不深，有时候还需要再看一遍，萌发了翻译的念头，先尝试一下！ 使用react工作一年后，我学到了最重要的一课我不想加这张图片，但是我知道它会引起你的注意(hhh 确实很引人注意)🔪 从一门新技术开始可能会得常麻烦，你经常发现你自己处于教程和文章的海洋中，后面是数以百万计的个人观点，每一个人都说他们找到了正确而完美的解决办法。 这些会让我们纠结我们选择的教程是否是浪费时间。 在去知识的海洋中之前，我们必须理解技术的基本概念。接着我们需要开发一种基于技术的思维模式。如果我们开始学习react，我们首先对react进行思考。只有在以后我们才开始将各种心态融合成一体。 在这篇文章中，我将从我个人使用react的经历中介绍我从这方面学到一些经验教训。我们在白天工作，晚上写个人的项目，甚至会谈一些我在本地JavaScript活动。 那么，就让我们开始吧！ react正在发展，你必须是更新到最新版本如果你还记得版本16.3.0的初始公告，你会记得每个人对此都很兴奋。 这是新版的的一些变化和改进： Official Context API createRef API forwardRef API StrictMode Component Lifecycle Changes react core团队和所有的贡献者都在你鼓励的改进我们喜欢的技术。 在版本16.4.0中，我们看到了Pointer Events。 肯定还有更近一步的改变，这只是时间的问题，异步渲染、缓存 版本17.0.0 以及其他很多不知道的改变。 因此，如果你想成为最棒的专家，你必须了解社区中发生的事情。 了解它们是怎么工作的以及它们为何被开发出来。学习正在解决的问题以及如何使开发更容易。这些真的对你很有帮助。 不要害怕将代码分成更小的块react是基于组件的。所以你应该利用这个概念，不必害怕将更大的部分分成更小的部分。有时候一个简单的组件可能只是4-5行代码，在某些情况下，它完全没问题。这样做，如果来一个新人，他们将不需要几天去了解一切是如果运作的。 // isn't this easy to understand? return ( [ &lt;ChangeButton onClick={this.changeUserApprovalStatus} text="Let’s switch it!" />, &lt;UserInformation status={status}/> ] ); 你不必制作内置复杂的逻辑组件。它们仅仅能看变量名就能理解组件。如果这样可以提高代码的可读性和测试性，并进一步减少更深一步的代码味道，那它对于团队里的每个人都是一个胜利。 import ErrorMessage from './ErrorMessage'; const NotFound = () => ( &lt;ErrorMessage title="Oops! Page not found." message="The page you are looking for does not exist!" className="test_404-page" /> ); 在上面的例子中，属性是静态的。所以我们可以有一个负责网站错误信息的pure component：NOTFound，仅此而已。 另外，如果你不喜欢在任何地方都使用css类作为类名，我建议使用样式化组件。这可以提高可读性。 如果害怕创造一个新的组件而污染你的文件夹，请重新思考如果构建代码。我一直在使用fractal structure，它很棒。 不要拘泥于基础-要变的先进有时你可能认为你不够了解一些东西而转向高级的东西。但通常你不必过于担心：接受挑战并证明自己错误。 通过掌握高级的主题来提高自己，你可以理解更多基础的东西并且如何将它们应用于更大的事情上。 你可以去探索以下很多模式： Compound Components High Order Components Render Props Smart/Dumb Components many others (try out Profiling) 探索他们，你将会知道使用它们的原因和地方。你会对React感到更舒适。 // looks like magic? // it's not that hard when you just try render() { const children = React.Children.map(this.props.children, (child, index) => { return React.cloneElement(child, { onSelect: () => this.props.onTabSelect(index) }); }); return children; } 并且，你不要害怕在你的工作中尝试一些新的事物，当然，在某些范围内。不要只限于在私人的项目中试验。别人可能会提问问题，这些都是正常的。你的任务是用强有力的论据来捍卫你的工作和决定。 你的目标应该是解决现有问题，进一步开发，或者只是提高代码质量（原文是：or just clean some pasta in the code. 我找了pasta code的意思，它与以下的名词有关：SpaghettiCode、RavioliCode、LasagnaCode），即使你的建议被拒绝了，你应该回家去了解，而不是沉默。 不要过于复杂这个听起来像一个反驳论点，但是它有所不同。在生活中，无处不在，我们必须保持平衡。我们不应该过于炫耀（over-engineer to show off）。我们必须务实。编写容易理解并实现其目的的代码。 如果你不需要redux，但是你想要使用它因为每个人都在不知道它的真正目的而使用它，不要这样，提出意见，如果别人推你，不要害怕站起来。 有时候你也许会想使用最新的技术编写复杂的代码，你就可以向世界说：我不是一个初学者，我正在成为一个中级，看看我能做些什么。 说实话，这是我在开发之旅开始的心态。但是随着时间的推移，你会理解不带有炫耀编写代码，因为‘它能工作’是最容易使用。 同事可以处理你的项目，你不是唯一负责开发、修复、测试的人。 团队可以在不参加长时间的会议了解其他人的所作所为。几分钟就足够用来讨论了。 当你的同事出去度假两周时，你可以接管他们的任务，而且你不需要工作8小时，因为它可以在一小时内完成。人们尊重让别人生活更轻松的人。 因此，如果您的目标是获得尊重，提升排名并进行改进，则需要为团队而不是自己编写代码。你将成为每个人最喜欢的团队成员。 重构，重构和重构 - 这是正常的尽管项目经理会经常改变他们的想法，你改变主意十几次。其他人会批评你的工作，你也会批评它。因此，你必须多次改变你的代码。不要担心，这是一个自然的学习过程。没有失败和错误你不能提高。我们倒下的次数越多，恢复起来就越容易。 但这里有一个提示：确保测试当前的软件。 Smoke、unit、integration、snapshot，不要害羞使用它们。 每个人都面临或将面临这个场景：测试可以节省宝贵的时间。如果你像许多人一样认为他们浪费时间，那就试着思考一下。 你不必和你的同事一起解释事情是如何运作的。 你不必和你的同事一起解释为什么事情会破裂。 您不必为您的同事修复错误。 您不必修复3周后发现的错误。 你将有时间做你想要的东西。 这都是非常有益处的。 如果你喜欢它，你会茁壮成长。在过去的一年里，我的目标是在React上做得更好。 我想谈谈它。 我希望别人和我一起享受。我可以不停地坐着整夜编码，看着各种各样的谈话，享受它的每一分钟。 问题是，如果你想要什么，不知怎的，每个人都开始帮助你。上个月，我面对200人发表了我的第一次React演讲。 在这一年期间，我变得更强大，更舒适地面对react的多种模式、范式和内部运作。我可以进行高级讨论并向其他人讲授我不敢触及的话题。而今天我仍然感受到一年前我所感受到的同样的兴奋和享受。 所以我建议每个人都问自己：“你喜欢你做什么吗？”，如果没有，继续寻找你可以谈论几个小时的特殊的一块，每晚学习，变得开心。因为我们必须找到最接近我们心灵的东西。 不能强迫成功，它必须实现。 如果我可以回到一年的时间，那么在我前面的旅程之前，我会为自己做些准备。 谢谢你的阅读！ 如果你觉得这篇文章对你有帮助，请鼓掌。 后不尝试不知道！翻译过程中，我只能看懂一句话表达的意思，但是翻译出来需要稍微润色一下。对于我看不懂的句子，我尝试google translate，效果还是很好的😂。对于里面的一些通用名词我还是不太了解：例如 pasta code、code smell，需要我再去查一遍，有时候可能自己也是看的懵里懵懂的。第一次翻译之旅真的是太累了，我需要大量的时间去找一些专业名词，进而才会理解作者要表达的意思，但有时候翻译出来还是很晦涩。这次真真正正的感受到翻译者的不易，感谢我曾经看过的翻译文章的作者，也深深了解到我司编辑的压力。]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstarp中的modal打开时为神马动态为body增加padding-right]]></title>
    <url>%2F2018%2F08%2F08%2Fbootstrap-modal%2F</url>
    <content type="text"><![CDATA[之前看bootstrap的modal的时候，当modal打开时，动态为body增加padding-right: 15px的style，刚开始时有点疑惑为什么不直接给open-modal增加padding-right: 15px，还非要动态增加呢？ 由于现在的项目中也有modal，我是采取的第二个方案，通过class给body增加样式。由于我的chrome的滚动条是需要占空间的，emmm，打开modal，样式是ok的，但是测试给我说，打开modal的时候页面整体会移动，很疑惑，看了他的浏览器，发现浏览器的滚动条是不占宽度的，所以当打开modal的时候，给body增加padding-right导致页面右移。 这个时候，我赶紧去看bootstrap的源码： // modal.js Modal.prototype.show = function (_relatedTarget) { // ..... this.checkScrollbar() this.setScrollbar() this.$body.addClass('modal-open') // ..... } Modal.prototype.checkScrollbar = function () { var fullWindowWidth = window.innerWidth if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8 var documentElementRect = document.documentElement.getBoundingClientRect() fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left) } this.bodyIsOverflowing = document.body.clientWidth &lt; fullWindowWidth this.scrollbarWidth = this.measureScrollbar() // 得到scoll bar的宽度 } Modal.prototype.measureScrollbar = function () { // thx walsh var scrollDiv = document.createElement('div') scrollDiv.className = 'modal-scrollbar-measure' this.$body.append(scrollDiv) var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth this.$body[0].removeChild(scrollDiv) return scrollbarWidth } Modal.prototype.setScrollbar = function () { // 为body动态增加padding-right var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10) this.originalBodyPad = document.body.style.paddingRight || '' if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth) } // 注： 如果没有对body的宽度做设置 // fullWindowWidth - document.body.clientWidth也可以得到scrollbar的宽度 每次打开modal的时候，动态的计算一下scrollbar的宽度，宽度即为padding-right的值。关闭modal的时候清空style的值即可。 扩展 先去增加body的style，再增加class，在写的过程中，我一直得到scrollbar的width为0，我还想着是不是异步的计算，检查了代码以后，发现是先加class再计算才导致每次计算为0。 我测试了Chrome、firefox、safari三个浏览器，scrollbar的width都是15，看的资料说scrollbar的width一般在14-18之间… 我检索了一下：如何隐藏chrome的滚动条，得到的答案是： chrome://flags/#overlay-scrollbars，我去找这个设置的时候，发现已经找不到这个设置了…..]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单双向数据流中的父子组件如何进行交流]]></title>
    <url>%2F2018%2F08%2F05%2Fdata-flow%2F</url>
    <content type="text"><![CDATA[前话，我最开始接触的是Angular，再是Vue，工作之后就开始用React，之前习惯了双向数据绑定，刚开始写太顺手，但心中想着框架是相通的，于是抱着这个想法，继续下去，遗憾的是，我把不相通的地方当成了相通….最明显的例子应该就是父子组件因为数据而产生的通信 双向数据流对于angular来说，对于同一份数据，我既在父组件中可以进行更改，也可以在子组件中进行更改，通信功能其实很弱化。 单向数据流对于父组件中的数据，子组件如果有修改的需求，该怎么办？在查到的资料中，很多解决方案都提到了调用这个词，父组件调用子组件的方法，子组件调用父组件的方法。抱着这样的想法我会写出以下： const Parent = () => { return &lt;MyChild {...someFunc}/> }; class MyChild extends React.Component { delete(id) { // $.ajax this.props.someFunc(); } render() { return ( // ) } } 写了很久的上面的解决方案….即是单向数据流，子组件调用了父组件的方法，我在调试的时候，假如看到数据的变化，我还需要去子组件里面查找，而且最典型的是对于一个数据的处理发生在了两个组件之间。这违背了单向数据流的思想。于是，第二个解决方案来了： class Parent extends React.Component { delete() { // babbababa } } const MyChild = (props) => { return ( &lt;div onClick={props.delete} ) }; 子组件变成一个纯组件，它如果想要对数据做什么，只是简单的告诉父组件，它本身没有任何的操作逻辑。所有的数据操作都发生在拥有数据的组件中。 结语：特性不相通，和特性有关的操作也不会相通的。]]></content>
      <categories>
        <category>前端</category>
        <category>angularjs</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码优化：度与平衡]]></title>
    <url>%2F2018%2F08%2F03%2Fcode-optimization%2F</url>
    <content type="text"><![CDATA[代码需要及时优化，但是什么的优化是恰当的呢？什么优化是不恰当的呢？ 这个时候需要优化了我有两个container： 一个具有筛选功能、一个不具有筛选功能，但是他们有共同的属性：list为空的时候，都显示没有数据；并且都具有瀑布流的功能。但针对目前只有这两个container的时候，我可以不进行相同功能的提取。但是，第三个container出来了，它与之前的两个container都不相同（数据获取的方式与前两者不同），但是具有相同的特性。在我准备写的时候，我发现再让我写一遍瀑布流的功能很别扭，这个时候，就应该考虑优化代码了。于是，我比较了这三个container的相同性之后，开始进行分层处理。 // fetch 数据层 // 解析数据层 // 判断是否与内容以及增加瀑布流功能层 // 内容显示层 分层处理后，代码的重复性减少，代码层级变得更清楚，架构也变得稳定。因为使用React去进行开发的，这样的划分带来的最显著的特点就是组件化，即使以后出现新的数据源，这样的分层也会很灵活。以上是我做的一个我觉得很棒的优化。我放下手头的活，写写画画思考了一会，经过分析得出这是最好的一个处理方式，确定好方案，撸起袖子，开始干活！ 以下优化不可取 写了好多组件，都需要用到redux里面的数据，写的mapState那叫一个重复啊，我想着把这一块相同的代码提成一个公用函数。想了就做了，结果当然是得到了反对，并乖乖的改了过去。对方给我的理由是：mapState本来就是标示从Redux里面去了哪些数据，如何命名。如果写到别的地方，阅读者不能一眼看到你想要的数据类型，反而还需要再去查别的文件，这种做法是不恰当的。 2.技术栈现在用的graphql + apollo，所以大部分组件都是以这样的格式开头的： @graphql(QUERY, { options: { variables: { // params } } }) @WaterFallWrapper() // 高阶组件 class HomeNewest extends React.Component { // bababa } 我看了很多组件都是这样开头的，心理的优化分子开始作祟，我想再把graphql弄成一个高阶函数，准备这样做的时候，我认真的思考一下🤔，这个包暴露的方法为什么不来一个最精简的方法呢，这么想了想，就没有进行这个优化工作…这个就属于过度优化了… 总结优化代码的话，最好从架构的方面去入手去进行，而不是仅仅从代码角度去思考 PS: 引用别人的话：过度优化相当想着死后如何分遗产;-)]]></content>
      <categories>
        <category>优化</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找素数：算法之美]]></title>
    <url>%2F2018%2F07%2F25%2Fprime-number%2F</url>
    <content type="text"><![CDATA[给定一个数字n, 打印出n以内的所有素数。素数的定义非常简单，对于一个整数，除1和它本身外，再没有其他因数了，这个数就是素数。就是说，只除以1或者本身时余数为0，除以其他数所得的余数均不为0。 最简单的方法-- 返回一个整数的所有因数 factors :: Integral a => a -> [a] factorsn=[ x | x &lt;- [1..n], mod n x == 0] > factors 24 -- out: [1,2,3,4,6,8,12,24] -- 检验一个数是否为素数的函数，只需检验它的因数是否只有1和他自己 isPrime :: Integral a => a -> Bool isPrime n = factors n == [1, n] -- 生成素数列表 primes :: Integral a => a -> [a] primes n = [x | x&lt;- [1 .. n], isPrime x] 上面的方法效率很低，每次求因数的时候，要从1～n全都遍历一遍 思考一下，可以简化一些过程 除去2以外，所有的素数都必须为奇树 素数必须是大于等于2的整数 对于一个整数N，若它有一个因数为p1，必有另外一个因子p2，使得N=p1*p1，并 并且p1与p2 一 分布在N的两端或p1 =p2 = 根号下N; 因为比2大的素数必须是奇数，所以它一 也不会有偶因数. 所以，对2进行单独讨论，然后对于其他的数只需要用它去除以所有 3 ∼ 根号下n的所有奇 数，若余数全不为0，则这个数为素数。这样，对于isPrime可以这样定义 isPrime' :: Integral a => a -> Bool isPrime' 2 = True isPrime' p = p > 1 &amp;&amp; (all (\n -> p `mod` n/=0 ) $ takeWhile(\n -> n*n &lt;= p)[3,5..]) -- 注： takeWhile (\n -> n*n &lt;= p) [3,5..]) 求出了 3 ∼ √N 的所有奇数数组成的列表 除此之外还有一个方法叫做埃拉托斯特尼筛法。给 从2开始连续的一列数，2为素数。那 么，在2之后有2 为因数的数均不为素数，可以被筛 。下一个数为3，3之后的所有为3的倍数的数就全被筛 了，因为4为2的倍数，这在第一轮中已经被筛掉了，下一个是5，依次类推，假设列表是无穷的，那么按着这个方法可以遍历所有的素数。 在看书时，阅读到这一块，就感觉真棒👍。填鸭式学习没有这样的思考过程，入门式的编程是以解决问题为主，未曾再进行思考。所以，入门加深入，会发现原来这个问题原来有如此优雅的方法。 PS: 以上出自haskell函数式编程入门]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最近发现问题的汇总]]></title>
    <url>%2F2018%2F07%2F14%2Fsummary-work%2F</url>
    <content type="text"><![CDATA[react selector最近我看到很多组件需要的redux中的值是一样的，但是，我需要为每个组件写一个mapState，我最直观的感觉是代码的重复性。于是我看了文档，在redux中的找到了一个selector的概念，看了看是可以减少我的代码重复性的。我尝试写了一个，就将这个重构工作交给同事。同事给我的说的意思是：selector可以理解成vue里面的computed。是通过计算得到一个新的值。例如： const getCurrentUser = (state) => ({ currentUser: state.info.currentUser }); 虽然上段代码需要在多个组件中出现。如果抽成一个方法，那么阅读代码的人需要再去找到这个方法才知道我实际需要的数据格式，虽然函数的名字已经很明确，但是你不清楚实际上在组件中使用的变量名。 例如： const searchSelector = { hasSearchFunction: (state) => state.info.currentUser.isBig &amp;&amp; state.info.currentUser.isSmall } 上段代码体现了selector的特点，通过计算得到一个新的值。这是一个提倡的做法。 redux store虽然这个坑我没遇到过，但是踩坑的人告诉我，不要什么东西都放在store里面，在store里面存值，是要进行一次stringfy，最直接的就是不要把不能进行stringfy的数据往store里面放。 组件大小最近在开发新功能的时候，会看到之前写的代码。我能体会得到之前组长的槽点。现在我看到组件，不光大而且里面很多if，看着就脑袋疼。React提倡组件可复用性。组件如果做到最大的复用性，最直接的方法就是组件功能单一性，这样组件可能变得非常小，最好还是把握一下度。以下代码会给你什么启示？ // ArticleItem.jsx const ArticleItem = () => { return ( &lt;div className="article-item"> &lt;div className="article-item__cover"> {/* ....content */} &lt;/div> &lt;div className="article-item__conent"> &lt;div className="article-item__content--top"> {/* ....content */} &lt;/div> &lt;div className="article-item__content--middle"> {/* ....content */} &lt;/div> {/* ....others content */} &lt;/div> {/* ....content */} &lt;/div> ); }; // ArticleItem.jsx const ArticleItem = () => { return ( &lt;div className="article-item"> &lt;ArticleItemCover /> &lt;ArticleItemContent> &lt;ArticleItemContentTop /> &lt;ArticleItemContentMiddle /> &lt;/ArticleItemContent> &lt;/div> ); }; 以上代码会给你带来不同的直观感受。阅读第一版代码，需要足够的耐心来阅读才能知道article中的内容。看第二版的代码，你可以很清晰的看到，article中到底有着什么内容。嗯，可以理解为什么别人不想看我的代码了，又臭又长！现在看来重构别人的代码也是件痛苦的事情。 闲谈之前看到很多的大神的经验谈，但是最真实的感受就是：没经历过真的很难去理解其中的意思。只有真正上手后，才能理解其中的奥妙。hhhh，是不是特别像高中的老师痛心疾首的告诉学生要好好学习，当时真的内心毫无波动，但是现在在想，会发现已经没有足够的精力对待学习这个事情了。活到老学到老，加油，你是最棒的！]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SPA起点？]]></title>
    <url>%2F2018%2F07%2F13%2Fhistory-push-state%2F</url>
    <content type="text"><![CDATA[如何想要点击浏览器自带的前进 后退按钮 不刷新页面，可以通过改变history的state想了一下，写了一个小demo。 &lt;nav> &lt;a href="/home">主页&lt;/a> &lt;a href="/about">个人&lt;/a> &lt;a href="/test">测试&lt;/a> &lt;/nav> &lt;div id="content">&lt;/div> &lt;script> const baseHref = location.href; const baseUrl = '/test.html'; window.onload = () => { const links = document.querySelectorAll('a'); links.forEach(item => { item.addEventListener('click', (event) => { event.preventDefault(); const href = item.getAttribute('href'); history.pushState('', '', baseHref + href); setContentHtml(href); }); }); window.onpopstate = (event) => { // console.log(event); const currentPathname = event.target.location.pathname; const targetHref = currentPathname.split(baseUrl)[1]; setContentHtml(targetHref); } const setContentHtml = (content) => { document.getElementById('content').innerHTML = content; } // 接管路由 // 1. 得到baseUrl之后的href // 2. 根据href去render } &lt;/script> 假如你是直接打开html文件，使用history.pushState会出错，这时候你需要新开一个server。其中最主要的是，你要托管a链接的herf。其中在onpopstate中，我得到targetHref的方式，感觉有些蠢，目前还没想到好的方法。去看一下其他的框架可能会给我一个不一样的思路。飘过～ 2018-07-14 更新在history这个项目中得到的启示：history.pushState的第一个参数就是onpopstate事件中的event.state这样的话，我可以对现有的进行一些改进 // first argumens is event state // history.pushState('', '', baseHref + href); history.pushState(href, null, baseHref + href); // .... // const currentPathname = event.target.location.pathname; // const targetHref = currentPathname.split(baseUrl)[1]; const targetHref = event.state; 这样想一下，event.state里面可以存很多东西….]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[set access-origin in rails]]></title>
    <url>%2F2018%2F07%2F06%2Frails-access-origin%2F</url>
    <content type="text"><![CDATA[记录一下，在rails里面如何设置access-origin…. gem 'rack-cors', :require => 'rack/cors' config.middleware.insert_before 0, Rack::Cors do allow do origins '*' resource '*', :headers => :any, :methods => [:get, :post, :options] end end]]></content>
      <categories>
        <category>rails</category>
      </categories>
      <tags>
        <tag>rails</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有及时重构代码给我带来的启示🙂️]]></title>
    <url>%2F2018%2F07%2F05%2Fbad-code-2%2F</url>
    <content type="text"><![CDATA[最近的烦恼最近真的超级苦恼。一直在进行新功能的开发，没时间做我之前想要重构的东西。在进行开发的时候，这个时候我已经很注意重构的信号，新功能的开发需要重构一些代码，秉承着一个pr只做一个功能，于是我需要切换分支，提pr，合并pr之后，再进行新功能的开发，这个事情真的非常痛苦。之前没有充分的经验和思考进行的开发，给现在的我带了巨大的痛苦。 启示（都是泪）1. 每个文件的入口文件应尽可能的保持干净不要因为函数小，就要往index中塞。index是入口文件，了解整个项目从这里开始，所以要保证，这里的代码做到最简洁明了，一眼看过去，就能有一概览的感觉。小函数感觉放在一个单独的文件中太不值当的，就把所有的小函数放在一个文件中。整理之后，我感觉非常清新。 2. 多处都用到的样式，这个时候就要考虑重命名了要不看了很疑惑，这个页面为什么有其他页面的style 3.实时抽取util组件划分要清楚，例如可以抽出来api.js、tool.js 4.函数复杂度尽可能的降低若真的找不到适合的解决方法，可以与身边的人分享一下，或许会得到更好的解决办法 5. 你连续copy一段代码以上，这个时候，你可以考虑写一个工具来生成相同的代码6. 需要lazy的地方，及时lazy7. 一个问题有两个不同的解决办法，各有利弊,选择代价最小的移动端和PC端共用一个相同的组件，这个我写一个组件，写两份样式。在这个情况下，假如你修改一下组件，这个时候，你就要同时修改两份样式。一般移动端展示的UI较少，用PC端的组件，会造成很多DOM的多余。所以这个时候，写两个组件更好一点。 8.对于react的看法要学会切小片片，尽可能的组件化，组件尽可能的小，职责尽可能明确。之前写两个wrapper有一段相同的代码，这个还可以接受，等我再写一个wrapper时，发现还需要那一段相同的代码，我受不了了，于是将一个组件拆成了三层。emmmm，组件小多么重要。]]></content>
      <categories>
        <category>优化</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何写出烂代码]]></title>
    <url>%2F2018%2F07%2F02%2Fbad-code%2F</url>
    <content type="text"><![CDATA[重构当你发现现有的结构满足不了现有的功能，这是重构的信号。很遗憾，为了赶进度，当这些信号出现时，你没有放在第一位去考虑，随着增量的开发，再回头准备下手重构，有一种牵一发动全身的感觉。 烂代码的由来词不达意代码写出来的目的是给人看的，一般你写的代码都不会由你维护。emmmm 随意的命名，给阅读代码的人带来巨大的负担。自己看两天的代码也会有一种雾里看花的感觉。 二随一变这个是在开发过程中，两个对象都随着一个对象变，又勤勤恳恳的写了两遍。这个时候，当发生一点变化，我要找到全部随变的代码，两个一块修改…改的手都累了，眼也花了 我就不改变参数的个数现有的函数不能满足最新的需求，哎呀，我得在往这个函数中传一个参数，emmm，好麻烦，试试能不能在现有的参数中得到我想要的参数，还可以，就这样吧。于是，开始循环，整个函数已经不堪重负了….满篇的if else 来来来 我的麻花真好看写了一个函数，哎呀，我这边需要和这个函数差不多的函数。哎呀，传一个标志，里面判断吧。这麻花不是一般的好看啊 const getData => (isAdd) { if (isAdd) { ..... } // 共用代码 if(isAdd) { ..... } // 共用代码 if (isAdd) { ..... } } repeat yourself做spa的时候，五个页面都是一个list，于是我勤勤恳恳的写了五个list。这是在做ui的时候。在接数据的时候，我发现这几个页面的整体都是一样的，唯一不同的就是里面的item是不一样的，那我为什么还要写五遍呢？其实开发的时候，就是ctrl+c和ctrl+v，那个时候还庆幸，因为把功能划分的十分清楚，我在每个页面map一遍，还挺简单的。沉浸在这种欢乐中，导致忘了这个repeat的操作。于是，动手写个一个生成list的function后，每个组件的代码两行就可以搞定了。 磨刀不误砍柴工对待一个复杂的问题，首先要勾勒出它大概的轮廓，把能想到的全列上，以此先做出一个好的架构。边写边想看是一个需要摒弃的习惯（对于我自己来说）。这次新做的搜索，我先写好ui,在接数据之前，我能大概想到是什么个情况。于是我开始下手写了。写着写着，我发现，嗯 导航需要条件，下面的list需要条件，右边的筛选也需要这个条件。筛选和list是属于一个组件中，我已经写到单独的list这一块了，有种写不下去的感觉，于是我开始将它们共用的数据全部放在父组件。这对于开发中的时间，是一个巨大的浪费，因为这意味着我之前的工作是白做的。这个时候，我开始拿起纸和笔，开始分析我应该怎么去规划…尽管我再分析的时候，把能预见的问题都想到了，但是在开发过程中还是遇到了未知的问题..写代码的仔细分析很重要….开发过程中的清晰头脑也很重要 先写到这….]]></content>
      <categories>
        <category>优化</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于整理css和js]]></title>
    <url>%2F2018%2F06%2F23%2Frefactor%2F</url>
    <content type="text"><![CDATA[闲谈最近很大一部分工作是在进行重构工作，每次都需要提一个大pr，很是心累。原本项目就是重写了一份，但是在架构方面还是没有做好。在开发过程中，没有进行总结，错过了重构的好机会，导致后期维护起来很累。编写代码的很大感觉，哎这一块我好像写过，copy过来。其实这就是一个重构的信号。don&#39;t repeat yourself.在开发过程中，我做了很多copy的工作，于是出来混总是要还的。现在重构起来就需要将凌乱的部分整合在一起。 css整理工作最近的整理工作，主要是在整理css和js，现在想想也很是惊奇。对于css的整理，是在前期没有很好的去总结组件的共同之处，导致css文件是一个增量的过程，而不是迭代的过程。意思到这点之后，我开始梳理和提取相同的地方。css的整理要注意的是：词达意和语义化，这意味着别人一看到你的class就能大概猜出来它是个什么样的。 js整理工作对于js的整理，很大一部分问题就自己否定自己。刚开始写的时候，我问自己：js可以拿redux里面的数据吗？我在没有查询的基础上给了一个自己否定的答案。嗯，不可以的话只能退而求其次了。现在有人告诉我可以，于是开始整理和重构。看起来问题是出在我没有做好准备工作上面。 什么时候进行整理我不知道这次的整理是否可以称得上重构？但是这次的整理是我的整体思路更加清晰，架构也在渐渐明了之中。在编写的过程，做好的时机是：这一块我之前写过类似的，这个时候，你就考虑把相同的地方抽出来作为一个单独的部分。还有一个情况是你写着写着写不下去了，这个时候，就需要从头梳理一下思路，到底是哪出的问题。或者是目前的代码已经不能满足新的需求时。 整理完一个item，感觉浑身清爽PS:作为一个前端来说，写出来的是直接和用户交流的产品，在开发过程中，我是在知道需求的基础上进行开发的，对于一个临时的功能，我可以写的简单一点，但是也需在明了的基础上进行，emmmm…反之，使用者已疯]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用pdf.js在页面中在线加载pdf文件]]></title>
    <url>%2F2018%2F04%2F08%2Fpdf%2F</url>
    <content type="text"><![CDATA[在网页中浏览pdf文件，最简单的办法当然是插入iframe了 html5中浏览pdf文件html5中有标签可以插入pdf,但是在每个浏览器上的表现形式不一样… &lt;embed src="pdfFiles/interfaces.pdf" width="600" height="500" alt="pdf" pluginspage="http://www.adobe.com/products/acrobat/readstep2.html"> 插件pdf.jspdf.js是一个浏览器兼容的插件，移动端也很使用，有一点：需要引入的包太大。为此，有人又做了一个包裹pdf.js-viewer。这个npm是pdf.js的打包后的版本。在使用的过程中，你会发现样式不对，此时你可以将pdf.js中的viewer.scss，拷贝的你的开发目录，而不是引入pdf.js-viewer的css，里面的样式已经过时了。语言包引入后，页面就会翻译，不用做其他设置。 &lt;!DOCTYPE html> &lt;html lang="en"> &lt;head> &lt;meta charset="UTF-8"> &lt;title>Document&lt;/title> &lt;link rel="stylesheet" href="./viewer-2.css"> &lt;link type="application/l10n" href="node_modules/pdf.js-viewer/locale/zh-CN/viewer.properties" /> &lt;style> html, body { height: 100%; margin: 0; padding: 0; } body { overflow: hidden; } #pdfjs { height: 100%; } #viewBookmark, #secondaryToolbarToggle { display: none; } pdfjs-wrapper { display: block; height: 100%; } &lt;/style> &lt;/head> &lt;body> &lt;div id="pdfjs"> &lt;!--#include virtual="node_modules/pdf.js-viewer/viewer.html" --> &lt;/div> &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js">&lt;/script> &lt;script src="node_modules/pdf.js-viewer/pdf.js">&lt;/script> &lt;script type="text/javascript"> $(function() { // window.PDFJS.locale = 'zh-CN'; $('div#pdfjs').load('http://localhost:65534/viewer.html', function(res) { window.PDFJS.webViewerLoad(); window.PDFViewerApplication.open('http://localhost:65534/sample-3pp.pdf'); }); }); &lt;/script> &lt;/body> &lt;/html> 集成到webpack中测试开发可以正常使用，需要集成到webpack中。由于文件都需要用webpack打包，于是按照平常一样，将文件引入，发现控制台报错。在调试过程中，我遇到5种左右的错误，影响最深刻的一点是：document undefined…也是很迷，调试过程中，发现pdf.js种的代码执行了两遍，第二次的时候就会出这个错误。仔细翻了翻源码，在pdf.js中，它需要引入pdf.work.js文件，webpack打包时，它根本就找不到这个文件，最后的结果是只在windows上挂载了关于pdf的两个对象…最后的最后，直接在页面上引入pdf.js和pdf.work.js，由于文件过大，你按需进行加载就可以了。 最后的最后，写了很长时间的slim模版，我忘了原生的标签怎么写了…导致我在引入语言包话费个很长时间…也是很迷…切莫忘本😊]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在webpack环境下，安装jquery插件不能使用]]></title>
    <url>%2F2018%2F03%2F13%2Fjquery-plugin%2F</url>
    <content type="text"><![CDATA[使用插件现在是使用webpack打包，yarn安装需要的插件很便捷。今天遇到了一个奇怪的问题，我使用yarn安装了一个jquery插件，使用时，jquery报错… 排错 安装、引用是否正确首先先确定一下：包是否正确安装；使用时是否正确引用；ok，这两个都是正确的 webpack是否配置正确在webpack中，一般都会将jQuery设置为全局变量，在webpack中设置如下: new webpack.ProvidePlugin({ $: "jquery", jQuery: "jquery" }) webpack版本是否合适开发中使用的是rails-webpack，其中的配置需要更改（之前对照文档修改配置，报错；今天才看到原来是版本问题😂） 最最重要的一点：查看你安装的插件的包里面有没有node_modules这个文件夹在排查错误时，我将包里面的代码拷贝到开发目录，我发现能用。。。直接引用包就不可以。使用插件，最终目的是在$这个对象上挂载方法。报错就是说明$对象上没有这个方法，问题来了，包里面的$是哪来的？全局对象还是node_modules文件夹中的jquery???引用多个插件，插件依赖的jquery版本可能不是一样的，webpack打包的时候，首先去找安装包的插件node_modules里面的jquery，局部变量覆盖全局变量。所以此时挂载方法的$对象是node_modules包中的jquery，而不是全局的$对象 为什么安装的jquery版本会不同这个时候你也许会疑问🤔️为什么会安装这么多版本？首先你要去检查依赖的jquery版本，这个时候你可以去查看yarn.lock文件，里面有具体的依赖关系。这个时候，假如按照算法，你发现几个插件依赖的jquery的版本应该是一致的。但为什么yarn计算出来的不一样呢🤔️？因为yarn在add包时，计算lock的时候，会在原来的基础上进行计算，恰好在这个时间隔中，jquery升级了…这就导致yarn计算出来的依赖版本可能有所不同此时，你可以使用yarn upgrade进行更新lock文件 如果以上步骤还不能解决问题…我也不知道根本问题是什么]]></content>
      <categories>
        <category>前端</category>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>jquery</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用node自动发送邮件]]></title>
    <url>%2F2017%2F11%2F15%2Fnode-send-email%2F</url>
    <content type="text"><![CDATA[发送邮件: nodemailer 基本代码，使用之前请确保邮箱开启SMTP const nodemailer = require('nodemailer'); nodemailer.createTestAccount(() => { const config = { host: 'smtp.163.com', port: 465, secure: true, // true for 465, false for other ports auth: { user: 'xxxx@163.com', // generated ethereal user pass: 'xxx' // generated ethereal password } }; const transporter = nodemailer.createTransport(config); // setup email data with unicode symbols const mailOptions = { from: '"Fred Foo 👻" &lt;xxx@163.com>', // sender address to: 'xxxx@gmail.com', // list of receivers subject: 'Hello ✔', // Subject line text: 'Hello world?', // plain text body html: '&lt;b>Hello world?&lt;/b>' // html body }; // send mail with defined transport object transporter.sendMail(mailOptions, (error, info) => { if (error) { return console.log(error); } console.log('Message sent: %s', info.messageId); }); }); 若使用SSL, 在config中添加 secureConnection: true, // use SSL 3.添加附件, 在mailOptions添加 attachments: [ { filename: '文档.txt', // 不会乱码 content: '哈哈哈' }, { filename: '2.txt', content: 'heool word' } ] 添加图片, 在mailOptions添加 attachments: [ { filename: '文档.txt', content: '哈哈哈' }, { filename: '01.png', // image path: './flow.png', // 图片路径 cid: '00000001' } ]]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[要说了...]]></title>
    <url>%2F2017%2F11%2F06%2Fproject%2F</url>
    <content type="text"><![CDATA[设计图出代码根据设计图，如何写出好的代码。设计图是一张一张的出的，因为不知道哪一块会在其他的设计图中出现，于是只看到当下并不是一个好的想法。看到一张图，可以先思考一下，哪一块有可能被复用。在class的命名上就会有所改变…刚开始一个元素在主页出现，我可以给它命名home__XX，但是当这个元素也在文章页面出现时，再起一个class，重复写一样的css，这不是一个好的想法，但是将这个类名直接写在文章页，看着又很不爽。在项目中，使用scss用来开发，这个时候，你可以改变类名或者使用@include和@extend来组织代码。js部分，不止实现功能，也要保证优雅。例如一个参数可能是数组或者string，你可以这样写： if (typeof argument === 'string') { //... } else if (typeof argument === 'object') { //... } 也可以这样 const map = { string: () => { //... }, object: () => { //... } }; return map[typeof argument](); 文件夹组织根据项目需要组织出合适的文件结构，文件名也要更好的表达出这个文件夹中的内容，使之清晰… 重构开发的过程中，代码量越来越大，这时候可以考虑一下代码的重构。重构是不大幅度改变代码的基础上进行的…大幅度的重构甚至重写不能称作重构…推荐书籍：重构:改善既有代码的设计]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node项目自动化部署]]></title>
    <url>%2F2017%2F09%2F13%2Fpm2%2F</url>
    <content type="text"><![CDATA[由来嘤嘤，看到ruby中有一个gem叫做capistrano， 使用它可以实现一键部署到服务器上了。之前在懵里懵懂的时候，做了一个网站，每次更改后，我都用filezilla将新版本的代码上传，再restart项目，超级费劲。看到ruby后，于是赶紧去网上搜了搜，pm2可以做这件事。之前也见到过pm2，那时候我在寻求守护进程的module，但是我选择了forever。 使用pm2实现自动部署这个链接对我的帮助很大，基本上按照他的步骤来应该是可以实现自动化部署。 出现的问题服务器上的node是我很久之前安装的，但是pm2要求使用nvm，于是装了nvm，但是到了“克隆好之后执行安装和启动”，这一步报错：npm 这个命令找不到。去寻找解决办法，有的说将.bashrc文件中的关于nvm的部分放在最上面，还有的说要使用nvm重新安装node，这两个方法都试了，但是都没有解决错误。于是我只能去pm2的目录中的source文件夹，手动去执行npm install 和 pm2 start app.js 等待update得到解决方案： nginx转发最暴力的方法就是下面👇的代码： server{ listen 80; server_name xxx.xxx.xxx;(域名) location / { proxy_pass http://127.0.0.1:3000 } } 目前可以解决我的需要，假如还有其他的端口需要监听该怎么办？]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[得到一个linux服务器要做的事情]]></title>
    <url>%2F2017%2F09%2F13%2Flinux-first%2F</url>
    <content type="text"><![CDATA[对待自己的服务器，想着反正也没人攻击，也就从来没在意过。前天得到了一个讯号：要好好对待服务器，第一步就是安全性， 你需要这么做 使用root账户登录后，创建一个用户并设置密码，如果有必要，就赋予用户root权限 上传ssh-key，上传成功后，你就不用输入密码登录服务器了 关闭密码登录，打开ssh-key登录 以后就使用你新建的用户登录吧]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[url上添加query]]></title>
    <url>%2F2017%2F09%2F03%2Fweek6%2F</url>
    <content type="text"><![CDATA[举一个栗子🌰：在分页时，你通常会看到url上一般是xxx?page=1通常的做法是点击第几页直接跳转页面，是通过location进行的现在的需求是：在跳转页面的时候，我既想要改变url，同时我只需要改变分页的数据，而不需要整个页面重绘。 —–很幸运history提供了这么一个方法pushState，它有三个参数：state object，title，以及一个可选的URL地址。第二个参数title:现在firefox和chrome已经忽略该参数 window.history.pushState('','title','?page=1'); pushState参考链接]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[coursera第三周]]></title>
    <url>%2F2017%2F09%2F03%2Fcoursera-3%2F</url>
    <content type="text"><![CDATA[淡淡的忧伤three time 是三倍的意思 学习一门新的语言目前学习一门新的语言仅仅停留在Syntax，但是真的要把代码写的优雅，你更要了解它的Type-checking和Evalustion，了解这两者之后，你能知道代码在哪里可以优化，而不是代码的优化是在写代码中或者看到别人的代码时看到的目前这个方面需要改变，思想的转变…人的思想都是在肤浅向深沉转变😄 应用类型下面是一段java代码，乍看上去没有问题，但是使用p.getAllowesUsers[0] = p.currentUser，这一句代码使权限形同虚设。原因是：getAllowesUsers中直接返回的是allowedUsers，我尝试修改p.getAllowesUsers的值, 实际上修改了示例的私有变量的allowedUsers的值修改： 在getAllowesUsers中直接返回的是allowedUsers的一个克隆 class ProtextedResource { private Resource theResource = ...; private String[] allowedUsers = ...; public String[] getAllowesUsers () { return allowedUsers; } public String currentUser() { // ... } public void useTheResource() { for(int i = 0; i&lt; allowedUsers.length; i++) { if (currentUser().equals(allowedUsers[i])) { ... // access allowed: use it return ; } } throw new IllegalAccessException(); } } 之前在项目中，我定义了一个default的值，合并对象选的是lodash的extend,因为没有看文档就直接使用了，extend(default, options)，发生了bug。我的本意是default是一个不可变的值，它作为一个函数的默认值。经过长时间😅的调试，我发现default的值改变了，去看文档发现extend会改变第一个参数的值。于是更改为extend({}, default, options)当应用类型作为函数的参数，一定要特别注意，尽量使用实参的clone值，要不在函数中修改参数的值，就相当于修改实参的值了… 尾递归递归在一定程度上可以代替loop，一方面它看起来更优雅，另一方面…下面的代码上面的函数是我们经常使用的方式，通俗易懂。下面的递归称为尾递归。两种函数实现的功能相同。但是若要分析到stack处，你会发现下面的函数比上面的函数有更好的性能；首先上面的函数涉及到每次递归都要去进栈和出栈后才能得到就过，但是下面的函数却没有这样的操作。而且在Evalustion阶段，上方的函数最终结果的数据类型需要依赖上一步的结果；下面的函数时不需要上一步的计算结果 fun sum1 xs = case xs of [] => 0 | i::xs’ => i + sum1 xs’ (* tail recursion*) fun sum2 xs = let fun f (xs,acc) = case xs of [] => acc | i::xs’ => f(xs’,i+acc) in f(xs,0) end 就到这吧…😪]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本周总结]]></title>
    <url>%2F2017%2F08%2F26%2Fweek5%2F</url>
    <content type="text"><![CDATA[上周没写总结… if条件什么时候为false因为react共用组件，但是传过来的值的结构不同，于是使用||来进行判断选择，于是写了以下代码放心的提上去了 const count = node.count || node.usage_count || node.total_count 发现报total_count是undefined，这个我仔细看了代码没找出来哪错了，于是把生产环境的数据库拿下来，开始调试…最后发现因为usage_count的值为零的时候，会继续往后执行，因为node.usage_count值为0，js会认为是false…我的原意是为undefined的时候，会继续向后执行。使用js很随便，但是忘记了随便的副作用。于是我只能用if…else…去判断undefined了👉当if语句中的变量为false，0，NaN，空字符串，null，undefined时，判断结果为假; 图片是使用背景图还是img标签一般来说，我的习惯是图片一般使用img标签插入页面。但是，假如一个网站有中文英文两个版本，通过类名的切换而不是跳转页面可以实现中英文的切换，这个时候，就不要img标签，而是背景图的形式插入图片，这样做的好处是：图片是在css设置的，我可以为元素设置不同的类名进而切换图片 BEM不应该嵌套太深BEM命名的方式，一般是一个block里面包含element,所以我是一个block一层来的。大哥告诉我这样是不对的，划分block没有错，但是在命名不冲突的情况下，block中的element的类名没有必要一定按照block的类名开头。 一定要选好元素之前做tab切换的时候，咋改都没达到想要的效果。看了大哥的代码，才发现自己选错元素了。应该选择section的父元素而不是每个section…写代码之前没有经过严密的思考，遇到错误时，思想受到了限制，导致没想到正确的方向去… calccss3中的calc这个计算属性超级好用，但是有一点需要注意 height: calc(100%-75px); 以上代码不起作用，让人摸不着头脑，经过查询之后，需要注意的是-号两边要有空格 height: calc(100% - 75px); display:flex;兼容性网站要兼容到IE9，而flex是从ie10兼容的。找hack但是没有只对IE9起作用的hack…唉，使用\9的hack，它也在IE10下起作用对于IE9的兼容，我一般使用display: table;和display: table-cell;。此时你在设置子元素的margin是不起作用的，此时你想要的效果这两个css属性可以达到你的需求border-collapse: separate;、border-spacing: 5rem。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[coursera第二周]]></title>
    <url>%2F2017%2F08%2F26%2Fcoursera-2%2F</url>
    <content type="text"><![CDATA[说在前面的话最初对待语言的看法：相比语言更重要的是由编程思想，语言只是一种工具。所以对于只停留在Syntax阶段，没有去深究语言的内在。之前在学习C++的时候，老师也讲过一些内存方面…例如一段很简单的代码，在C++中会造成死循环…代码片段我还是没找到…在学编译原理的时候，也学过词法分析、语法树等等…但是总是来说对于语言还是又一个模糊的概念近期在coursera看一门课程，收获很大。刚开始看视频，因为自己的英语能力薄弱，刚开始看的时候，恨不得每句话都Google tanslate一遍，看多了就习惯了，因为大部分的术语你已经知道意思了，所以能知道大概的意思。Google翻译的意思，因为不知道术语所以翻译出来也很奇特。目前是以ML为例讲解的 variable binding变量的绑定主要包括两个环境：静态环境记录了变量的类型；动态环境记录了变量的值 val x = 34 (* static env : x : int *) (* dynamic env : x -> 34 *) rules to expressions它共有三个部分：语法检查、类型检查和评估规则 Syntax: if el then e2 else e3 where if, then, and else are keywords and e1, e2, and e3 are subespressions Type-checking: first el must have bool type e2 and e3 can hav any type(let`s call it t), but they must have the same type t the type of the entire expression is also t Evalustion rules: first evalustion el to a value call it v1 if it`s true, evaluate e2 and that result is the whole expression`s result else, evaluate e3 and that result is the whole expression`s result shadowing当你重复声明相同的变量时，之前声明的值就会被覆盖，当你在REPL中看它的值的时候，就会变成hidden value，所以不建议重复声明变量 val x = 34 val x = 45 (* this is not assiginment statement *) 递归ML语言没有for循环，所以在对于list类型的数据，会尝试使用递归去解决问题，但是小心哦，不恰当的使用递归，会使运行次数呈指数式增长。下面是求list中的最大值，可以简单粗暴的理解成求数组中的最大值 fun bad_max(numbers: int list) = if null numbers then 0 else if null tl numbers then hd numbers else if hd numbers > bad_max(tl numbers) then hd numbers else bad_max(tl numbers) 上面代码逻辑清晰，通俗易懂，但是使用的时候，假如数组中的数是从大到小排列时，程序运行速度很快；相反，数组中的数若是从小到大排列，当数组是[1,…30]时，你就会发现有延迟…讲师用了一张图给你讲解 优化的方法是：你可以将bad_max(tl numbers)的值赋予一个变量，这样，每次程序运行时bad_max(tl numbers)只会执行一遍。这里使用了let...in...end，在这个课程中，作者也讲解了作用域的问题，例如子作用域的值回覆盖父作用域的值… 关键字每门语言都会提供关键字来提高代码的可读性，在适当的地方记得使用 调试错误调试错误时，一定要有耐心…]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本周总结]]></title>
    <url>%2F2017%2F08%2F20%2Fweek4%2F</url>
    <content type="text"><![CDATA[只想睡觉...]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在npm上发布自己的包]]></title>
    <url>%2F2017%2F08%2F17%2Fnpm-package%2F</url>
    <content type="text"><![CDATA[写包的初衷项目中很多地方用到相同的代码段，做其他项目的时候，也会用到这个功能，于是，大哥让我写一个包，供目前以及以后的项目使用 提供的功能在机器之心这个页面，上面的nav会根据滚动条的位置进而改变active状态，同时，点击nav中的每个链接，页面也会滚动到相应的section。这个功能很常见。目前，包提供的两种形式： 使用锚链接：你通过点击nav中的链接，通过锚点来使页面滚动到相应的section；同时，滚动条的位置改变时，会更改页面的hash，nav的active也会改变。 使用点击事件：你通过点击nav中的链接，通过获得元素的data-index来确定相应的section，所以你必须为nav中的item添加data-index属性；同时，滚动条的位置改变时，nav的active也会改变。 项目的地址点击这去仓库具体的参数请查看readme 项目发布的过程 新建一个文件夹，npm init来填写包的信息 编写代码 完成代码编写，若你使用ES6或者ES7的语法，需要使用babel转换一下 npm login npm publish 到这你的包发布成功，若更新包，记得要改package.json中的version 遇到的坑 完成代码编写后，直接发布了，使用的时候报错：import那报错；我以为是因为没有因为代码压缩，于是进行了代码的压缩，发现并没有什么软用；因为项目使用webpack打包，就想是不是因为没有打包，于是就开始了打包，结果项目还是报错。边上网边查，我还以为是代码写错了…；最后，看了其他包的样子，发现是使用babel打包的，解决了这个大问题。 若你安装不上一个包，报错说是因为名字重复了：不是文件夹的名字和包的名字重复了，而是你的项目的package.json中的name和包的名字重复了… 自己坑自己，代码变量拼写错误，最近老是犯这个错误😔 终结～]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES7-decorator]]></title>
    <url>%2F2017%2F08%2F13%2FES7-decorator%2F</url>
    <content type="text"><![CDATA[装饰模式对于装饰模式，现在还剩下鸡腿堡+香菜+辣椒的记忆。这个是装饰模式的一个例子：有一个汉堡的抽象构件，鸡腿堡是具体构件，香菜和辣椒都是具体的装饰角色。现在我想计算鸡腿堡+香菜+辣椒的价格 针对的问题你想要动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。不改变接口的前提下，增强所考虑的类的性能。何时使用： 需要扩展一个类的功能，或给一个类增加附加责任。 需要动态的给一个对象增加功能，这些功能可以再动态地撤销。 需要增加一些基本功能的排列组合而产生的非常大量的功能，从而使继承变得不现实。 es7中的装饰器es7新增的decorator 属性，它借鉴自 Python，在 Python 里，decorator 实际上是一个 wrapper，它作用于一个目标函数，对这个目标函数做一些额外的操作，然后返回一个新的函数。 装饰propertyES2016装饰器是一个返回函数的表达式，可以将target，name和property描述符作为参数。你可以通过在装饰器前加一个“@”字符来应用它，并将其放置在您想要装饰的顶部。可以为类或属性定义装饰器。 class Cat { meow() { return `${this.name} say meow`; } } // 如果给meow方法加上可读属性 // 定义一个装饰器 function readonly (target, name, descriptor) { descriptor.writeable = false; return descriptor; } class Cat { @readonly meow() { return `${this.name} say meow`; } } // 此时你尝试修改meow，就会报错 // // 在这里推荐一个module： core-decorators 装饰class在这种情况下，装饰器将使用目标target的构造函数。 function hero(target) { target.isHero = true } @hero class MyHero {} console.log(MyHero.isHero); // true 还可以进一步扩展，为装饰功能提供参数。 function hero(isHero) { return function(target) { target.isHero = isHero; } } // 你可以写成ES6的形式 // const hero = isHero => target => target.isHero = isHero; @hero(false) class MyHero {} console.log(MyHero.isHero); // false 参考参考链接]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>es7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本周总结]]></title>
    <url>%2F2017%2F08%2F13%2Fweek3%2F</url>
    <content type="text"><![CDATA[❓psd转html首先你拿到设计图应该做什么？我的做法是浏览一下整个页面，找出每个模块的共同点。之后开始搭建html，再写css，最后写js。昨天拿到设计图，按照这样的模式去做。可是在最后添加icon时犯了难，因为在icon库里面没有找到合适的，就想着在psd中直接导出icon，可是这时候去看psd的时候，发现整个模块是一个图层，这个时候犯了难，我不知道设计者这样做的意图？再接着我将整个模块作为一个png导出，直接放在页面上，我感觉这样做是不对的，最后的方法是将需要的图标裁剪出来，多个图标但在一个png中。这次给我一个提示：你拿到设计图第一件事是需要干什么？浏览页面的时候，是不是需要将每个模块的所在的图层全都要过一遍以及注意事项… ❓一个带有渐变颜色的圆形边框首先为了使div带有渐变颜色的边框，于是设置它的border-image是一个渐变颜色，虽然边框是渐变的了，当时它没有圆角，即使再改变它的border-radius也不会有作用。👉我在stackoverflow上找到了解决方法点击这里。但是这种实现还是有个缺点，就是div必须设置一个背景色，进而来掩盖它的after伪元素的背景色。但是我想要的效果是它的背景色是透明的，没有找到好的解决办法，就找了一个和背景色相近的颜色去代替😔。这个偷懒的方法，期待完美的解决方案… ❓css画出文件夹📁的轮廓这个问题最难的部分是画出文件夹📁上方那个弧度，没有什么好的办法，就是用两个元素的border-radius连接而成，理所当然的，画出的轮廓有些奇怪…因为border-radius越大，边框的弧度久越大，可见的border宽度会越来越窄，所以会有一种不圆滑的感觉。感觉我的想法有些奇怪… 如何做出宽高成比例的div父容器设置width和padding，padding设置百分比，padding设置百分比之后和width相关。子容器飘在父容器上width和height等于父容器即可。 ❓es7装饰器大哥说：没有什么是包不能解决的。查看了代码是使用了装饰器。 js中的offsetTop和jq中的offset()、position()使用起来还是不等同的，具体的得去查看源码… rails on ruby在查询的时候，能进行include的就不要在jbuilder里面再去查询一遍。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本周总结]]></title>
    <url>%2F2017%2F08%2F05%2Fweek2%2F</url>
    <content type="text"><![CDATA[分页插件写分页插件，我开始的想法是： 判断是否显示“上一页” 判断是否显示“第一页” 判断是否显示“…”、”current-2”、”current-1” 判断是否显示 current页面 判断是否显示”current+1”、”current+2”、“…” 判断是否显示“最后一页” 判断是否显示“最后一页” 我的目的是最少要显示cuurent周围的四个number，按照这个想法写出来，当cuurent为1时，只会显示123三个number，而我的预期是现实12345这五个number😔调整一下做法，将上面的3-5合并，left和right表示current-2和current+2，在left&lt;0时候，将right加上left的相反数，right&gt;total同理最后，我还是找了一个插件用在项目中，👉插件的名字是：react-paginate，css部分需要你自己去写… react and jquery目前有一个container的组件，它的子组件是list和detail，list的子组件是item，点击item，detail组件会显示，显示效果是通过增加删除类名实现的。想着组件传值比较麻烦，于是就在方法里面直接使用jq早啊道元素控制。大哥告诉我，这个解决办法是不推荐的。👉正确的做法是使用state。通过改变state的值，进而改变元素的class。 redis还记得之前的一个面试问题：视频有最热视频、点赞最多视频、其他视频，每次去服务器要十个数据…由于用户使用量很多，每次去数据库查询，访问量太大。这样的话，👉可以使用redis去做缓存，这样取数据库可以直接取缓存中取，设置一个时间去更新redis即可。现在又一个需求，是记录每天用户登录网站的数量。👉方法一：给用户表增加一个最后登录时间的列，每天定时执行程序，统计一下最后登录时间是昨天的用户数量。这个方法中，选择什么时候去执行程序很重要，要不然就会有漏网之鱼。👉方法二：最粗暴的办法是，在redis中创建一个字段，它是一个数组，每次知道用户登录的时候，就将用户的idpush进数组，每天用户的登录的数量，直接通过数组的长度就可以得到。这个方法的缺点就是：用户的id字段也是一串很长的字符串，数组会特别大。👉方法三：在redis中创建一个字段，它是一个字符串，默认是长度是用户的数量的0，若用户登录，就将对应的位置为1。在这三个方法中，第三个方法是最优方法。还有一个可以做缓存的数据库叫memcache，它和redis的区别就是，redis可以持久化。 插件js-base64Graphql中自带的分页，after字段是base64的字符串。前端传值就需要将数字转化成base64位的字符串。 import { Base64 } from &#39;js-base64&#39;; const cursor = Base64.encode(number); 最后说句题外话，任何炒作都不能改变一个东西没落的事实，与其去炒作，还不如用脑子把东西做的更好。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[豆瓣评分前250部电影数据爬取]]></title>
    <url>%2F2017%2F08%2F02%2Fdouban%2F</url>
    <content type="text"><![CDATA[在千里码刷题的时候看到了这个题目题目要求是爬取豆瓣评分最高的250部电影的总分… 分析爬数据，首先是实用http模块去爬取全部的HTML然后使用cheerio去得到HTML中自己想要的数据最后每页得到的总分相加 题目中的坑1、因为豆瓣是https开头，使用https模块，具体的方法没看，使用还是按照http模块来的2、如果按照正常的逻辑去写代码，最后得到的总分是0，因为https抓取数据是异步进行的3、使用promise来进行处理，首先需要等到25页的数据全部抓取完毕，再进行计算总分，这时候想到了promise.all这个方法。4、第一次尝试将使用promise，我在getData中直接将resolve(res)，等到下面使用的时候，res又是一个异步执行，这下尴尬😅了，于是调整顺序，在res执行end事件的时候再resolve5、js中浮点类型计算的坑，我直接暴力的*10，最后在／10 代码爬评分时，顺便把电影名也爬下来了，我准备把没看的都补上😄 const https = require('https') const cheerio = require('cheerio') let sumScore = 0 let allMovie = [] function filterMovie(html) { let $ = cheerio.load(html) let movieList = $('.grid_view li') let total = 0 let movies = [] movieList.each(function(index, item) { let score = $(item).find('.bd .rating_num').text() let movieName = $(item).find('.hd a').text().replace(/\s+/g,"") movies.push({ name: movieName, score }) total += Number(score) * 10 }) return { total, movies } } function getData(url) { return new Promise(function(resolve, reject) { https .get(url, function(res) { let html = '' res .on('data', function(data) { html += data }) .on('end', function() { resolve(filterMovie(html)) }) }) .on('error', function(err) { reject(err) }) }) } let funcArr = [] for(let i = 0; i &lt;= 225; i=i + 25) { let url = `https://movie.douban.com/top250?start=${i}` funcArr.push(getData(url)) } Promise .all(funcArr) .then(res => { res.forEach(list => { const { total, movies } = list sumScore += total allMovie = allMovie.concat(movies) }) console.log("总分：" + sumScore / 10) allMovie.forEach(movie => { const { name, score } = movie; console.log("评分：" + score + "，影片名：" + name) }) }) .catch(err => { console.log(err) console.log("出错了") }) 如果你有更好的想法，欢迎交流👏]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本周总结]]></title>
    <url>%2F2017%2F07%2F28%2Fweek1%2F</url>
    <content type="text"><![CDATA[收获一turbolinks是一款将网站变成spa的一个插件，看到文档的的某些地方和ionic有些许相似之处，于是就将之前做webApp的疑问提了出来：打开页面刚开始进的页面是主页还是登录页？经过讨论后，👉是主页；为App添加一个拦截器，对于用户登录后才能使用的页面，进入时，首先在拦截器中判断有无用户登录…另外，两者之间还有相同的一点：都会提前缓存页面。之前做app的时候，添加了拦截器，因为app首先打开进入主页（这时候开始缓存和主页相关的页面），判断用户未登录，会重定向到用户登录页，这时候就会发生页面的闪烁，关于这个问题我没有查😶，我很暴力的加了一个spash….另外，关于支付宝账单页，数据是如何传递，数据格式如何设计，尝试去爬数据也没看到数据长什么样子的😑，于是目前的想到的方法是，👉后端每次去数据库取count条数据，在按照日期分组后，传到前端；前端的处理方式是：判断得到的第一个月数据与本地现有的最后一个月的数据时候是同年同月，如果是就concat第一个月的数据，剩下的数据直接push。 收获二在将加载更多全都迁移至react的过程中，我在大哥的基础上，比这葫芦画瓢，完成了页面的重构…但是现在有一个问题是：假如全用react去渲染，那么爬虫就爬不到数据，于是采用的方式是：render的时候，会在页面上先渲染一部分数据，剩下的就交给react来做；但是apollo目前提供的解决方案是：假如你将数据渲染到页面上时，会先查找cache中有没有数据，如果有就将数据渲染到页面上；否则发出网络请求。这意味着，只要我将插件渲染到页面上，就会发出网络请求，这一条网络请求是不需要的。因为用户可能不会浏览很多数据，于是想到的办法是：👉等用户去点击加载更多的时候，再去发送网络请求。查找apollo的文档，能想到的办法是：👉预先向cache中写去空数据，这样渲染时，在cache中找到数据，就不发送请求了，但是我不知如何写入数据😖，这是一个预留问题😞很忧伤的一个问题…待续… 收获三知道了reduce这个优雅的方法，promise也提供了这个方法…. 收获四在还原原型图时，更多的时间应该花费在如何设计HTML的结构上，再接下来再写css，最后再写js。这次做的时候，本来是设计好了还能符合要求的HTML结构，结果在写css的时候，发现现在的HTML不能达到预期，于是开始设计调整HTML，幸亏样式使用scss写的😉…还有一个，我看到排排站的元素，首先想到的不是ul&gt;li，而是直接用a标签去尝试解决… 收获五再看文档的时候，看到了一个新的名词：Vanilla JS；用Google translate翻译了叫奶味js😀，于是就去查它到底是何方神圣，原来它的另一个名字叫做javascript😅 收获六因为sublimen并没有完整配置，push上去的代码就跑不过测试。这次找到了eslint检测js的package,叫做SublimeLinter-contrib-eslingt，代码不通过有红色标识…]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array的reduce方法]]></title>
    <url>%2F2017%2F07%2F28%2Freduce%2F</url>
    <content type="text"><![CDATA[初识第一次听说Array的reduce方法是在面试的时候这次看到大哥写的一个函数，里面用了reduce，哇，真的好优雅。因为代码的重复片段太多，我尝试去封装一个通用函数，没有成功。于是大哥出动了。目的是这样的：我可能需要data.user.article的值，或者需要data.article的值，或者需要data.categories.article的值，于是封装一个方法每次取到article的值。 // 封装一个函数reg，参数为belongto，传递的参数分别是：['user'] [] [categories] // 函数内部的主要代码是 return belongto.reduce((p,c) => p[c], data).article reduce文档Syntaxarr.reduce(callback[, initialValue]) 参数callback有四个参数：分别是accumulator(它是callback上一次返回的值或者是initialValue，前提是initialValue存在)、currentValue(正在使用的值)、currentIndex(正在使用的值在数组中的索引)、array(这个是循环的数组)；initialValue：用作第一次调用回调的初始值，如果不提供此参数，则第一次调用回调的初始值是数组的第一个元素。为了保证安全，最好提供这个值 tip: 当数组为空时，若提供initialValue，则最后的返回值是initialValue，否则，报错； 当数组不为空时，若提供initialValue，则循环从index为0开始；否则循环从index为1开始，accumulator此时为index为0的值。 返回值回调函数的最后的返回值 用法求数组元素的总和（告别for循环） var sum = [0, 1, 2, 3].reduce((a, b) => a + b, 0); // sum is 6 连接数组 [[0, 1], [2, 3], [4, 5]].reduce((a, b) => a.concat(b), []); // result is [0, 1, 2, 3, 4, 5] 相同元素在数组中出现几次 var names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice']; var countedNames = names.reduce( (allNames, name) => { if (name in allNames) { allNames[name]++; } else { allNames[name] = 1; } return allNames; }, {}); // countedNames is: // { 'Alice': 2, 'Bob': 1, 'Tiff': 1, 'Bruce': 1 }]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用relay和apollo的感觉]]></title>
    <url>%2F2017%2F07%2F23%2Frelay-apollo%2F</url>
    <content type="text"><![CDATA[使用relay的感受初次接触relay，感觉上很臃肿，因为必须为每个组件设置container；若query层级嵌套很深，为了组件化，就必须将每一个react的component全部分开，在项目中，我写了六个组件，那么每个组件都需要container，写起来感觉满满的恶意。 使用Apollo再次接触Apollo，看了文档，感觉和relay大同小异，与relay的不同是：无需为每个component设置container，最后写一个query就ok👌了。query也可以由多个fragment组成。另外，apollo也为angularjs提供了解决方案，有点想不明白🤔，angularjs本身就是双向数据绑定，为什么要对它提供解决方案…另外，Apollo虽然自身内部集成了redux，假如你的项目中使用了redux，你可以使用redux而不用Apollo内部的redux。 relay 因为container的存在，数据划分的比较严密，你只能在当前的container访问fragment中的的属性，不能访问父或子fragment的属性。而apollo直接使用的是请求得到的Object…Apollo也可以和项目原有的redux相结合使用，relay不可以…待续…这次写的很匆忙，假如有不正确的地方，请指正，谢谢😊。]]></content>
      <categories>
        <category>graphql</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
        <tag>react</tag>
        <tag>graphql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用git的那些年]]></title>
    <url>%2F2017%2F07%2F22%2Fgit%2F</url>
    <content type="text"><![CDATA[使用git想要去合并两个commit今天好不容易完成了工作，睡觉的时候突然想到还有些小瑕疵，就想改正。但是改动范围很小，不好意思在commit一次，于是就想将两次commit合并在一起，但是我没有将最新的commit推送到远程分支，就直接合并了两个commit成了一个新的commit，在推送到远程时，也没有先进行pull的动作（👉每次push之前一定要进行pull的动作），导致远程commit和我合并的commit发生冲突，最后还需要手动merge。看了一下提交记录，吓坏了，本来我想合并commit，预计的commit只会在之前的基础上多一次commit，但是现在多了三次commit，这下坏了。于是，上网查询，试了好几种办法。找到了一个很合适的办法 git reset HEAD^ --hard //彻底回退到上次提交 git push origin 分支名 -f // 强制推送到远程 这样操作以后，我的问题解决了 待续… -补充—最好不要不要强行push😕]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-relay的探索历程]]></title>
    <url>%2F2017%2F07%2F22%2Freact-relay%2F</url>
    <content type="text"><![CDATA[上次写感想还是2014的时候，那个时候是老师布置的作业（尴尬)队长看到GraphQL很好，于是先拿一个功能来试手😊。前端要使用GraphQL，最简单的方法是使用ajax发送query字符串。这个方法，若query嵌套层级太深，会导致query很长，长的让人接受不了；再者，假如数据变化，需要你手动的去改变DOM。项目中使用了react，于是队长给推荐了react-relay来配合GraphQL。首先给的时间是看GraphQL和react-relay的文档，先瞄一眼relay的文档，感觉是层层嵌套，就先去看GraphQL的文档，relay的文档没有看完…😶 第一天开始在队长的鼓励下开始写relay，到了relay的官网上，看到有一个Demo，就把代码给copy下来，再根据文档理解了代码的意思，就开始尝试着写代码。写代码的过程有点别扭，刚开始接触，会犯一些错误。但是又不知道错误发生的原因，于是就开始google解决。也想吐槽一下文档，文档上说，fragment的name建议是fileName_propsName，于是为了名字短点，就全部改了，结果编译的时候，告诉我是must be。😢代码终于不报错了，但是需要一个schema的文件。我想手写schema太繁琐了，也是去查有没有自动生成schema的插件，但是很遗憾，我找到都是配合node使用的（假如你有好的插件，请推荐给我，谢谢）。找啊找，找啊找，也没找到合适的，最终是队长上网找了一个工具生成的🤗。schema的问题解决。schema的存在是为了映射fragment的type。这个时候，大哥过来问问我怎么样了，我告诉他，虽然安装了react-relay，可是文档上的方法不存在，我就很暴力的改了源码，将方法暴露出来。他告诉我relay现在有两个版本：classic和modern，modern是最新的。我弱弱的问一句，咱们用哪个版本，他说当然是最新的。我的内心在哭泣😭。既然只是版本的迭代，思想肯定没有太大的变化，于是打起精神来看文档。👉这里是我太心急了，直接看了Demo，就ctrl+f去直接搜方法了，没有整体的先浏览一下文档，要不然也不会有这个不可预料的情况。 第二天边看文档，边改我的代码。👉刚开始报错是“没有配置babel或者graphql写错了”，假如你的babel配置是按照文档来的，那最有可能的就是你的fragment或者query写错了。最简单的query可以正常的渲染出来了，因为是query中需要有参数，所以开始看如何使用参数。在查资料的时候，这个链接给了我很大的帮助。但是在这个过程中，下面的错误伴随了我十个小时，我一直在尝试解决这个错误，于是上网查啊查 查啊查 查啊查也没找到答案 第三天大哥说他写出来了，我看了他的代码，对比我的代码，唯一的不同是，我将edges和node要写在不同的fragment中。我尝试在正确的代码上改成我设计的fragment，功能就报错了。我意识到，需要将edges和node写在同一个fragment中。👉出现这个错误的原因是，我已经封装好的fragment，出现这个错误，我全部的心思都放在了index.js，没有检查我封装好的组件。假如再来一次，我也会被困在这个error上出不来。之后因为还有一个加载更多的动作，于是我开始完成这个功能，在这个过程中，我学会了react父子组件如何传递消息。 测试功能完成好了。但是在进行测试的时候，再看network时，加载更多这个按钮是通过first这个参数来进行请求数据，first的意思就是取前first数据，后端限制first只能取到50，即使可以取到1000，但是在网络上传输1000条数据，也是一笔庞大的负担。relay也提供了分页的container，但是没有研究出来是怎样使用的。于是relay需要更换….所以，没有一个很好的方式来解决这个问题。👉队长又给推荐了Apollo，接下来要去看Apollo了待续…]]></content>
      <categories>
        <category>graphql</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>graphql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号搭建]]></title>
    <url>%2F2017%2F03%2F29%2FwechatPHP%2F</url>
    <content type="text"><![CDATA[使用apache+php5.4n1、打开apache配置文件httpd.conf 搜索httpd-vhosts.conf，打开这一行的注释2、打开apache所在目录下的，conf/extra/httpd-vhost.conf 增加以下代码，保存 &lt;VirtualHost *:80&gt; DocumentRoot &quot;D:\WWW\car-xxxx\car&quot; ServerName www.car-zones.com &lt;/VirtualHost&gt; &lt;Directory &quot;D:\WWW\car-xxxx\car&quot;&gt; Options Indexes FollowSymLinks Includes ExecCGI AllowOverride All Order allow,deny Allow from all &lt;/Directory&gt; 3、重启apache4、打开c:/windows/system32/drivers/etc/hots最后一行加入：www.car-xxxx.com5、访问 www.car-xxxx.com6、完成配置 第一次学习，记录一下]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>微信公众号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dataTable插件的使用]]></title>
    <url>%2F2017%2F03%2F26%2FdataTable%2F</url>
    <content type="text"><![CDATA[偶然发现一个叫 dataTable 的组件，觉得很好用，于是研究了一番，下面是代码 var lang = { "sProcessing": "处理中...", "sLengthMenu": "每页 _MENU_ 项", "sZeroRecords": "没有匹配结果", "sInfo": "当前显示第 _START_ 至 _END_ 项，共 _TOTAL_ 项。", "sInfoEmpty": "当前显示第 0 至 0 项，共 0 项", "sInfoFiltered": "(由 _MAX_ 项结果过滤)", "sInfoPostFix": "", "sSearch": "搜索:", "sUrl": "", "sEmptyTable": "表中数据为空", "sLoadingRecords": "载入中...", "sInfoThousands": ",", "oPaginate": { "sFirst": "首页", "sPrevious": "上页", "sNext": "下页", "sLast": "末页", "sJump": "跳转" }, "oAria": { "sSortAscending": ": 以升序排列此列", "sSortDescending": ": 以降序排列此列" } }; var table = $("#sample").dataTable({ language:lang, //提示信息 autoWidth: false, //禁用自动调整列宽 processing: true, //隐藏加载提示,自行处理 serverSide: true, //启用服务器端分页 searching: true, //禁用原生搜索 search: { "search": "" }, ordering:false, renderer: "bootstrap", //渲染样式：Bootstrap和jquery-ui lengthChange: false, pageLength:15, rowId: '_id', pagingType: "simple_numbers", //分页样式：simple,simple_numbers,full,full_numbers columnDefs: [{ "targets": 'nosort', //列的样式名 "orderable": false //包含上样式名‘nosort’的禁止排序 }], ajax: function (data, callback, settings) { //封装请求参数 var param = {}; param.keyword = data.search.value; param.limit = data.length;//页面显示记录条数，在页面显示每页显示多少项的时候 param.start = data.start;//开始的记录序号 param.page = (data.start / data.length)+1;//当前页码 //console.log(param); //ajax请求数据 $.ajax({ type: "POST", url: "/payment/result", cache: false, //禁用缓存 data: param, //传入组装的参数 dataType: "json", success: function (result) { //封装返回数据 var returnData = {}; returnData.draw = data.draw;//这里直接自行返回了draw计数器,应该由后台返回 returnData.recordsTotal = result.totalCount;//返回数据全部记录 returnData.recordsFiltered = result.totalCount;//后台不实现过滤功能，每次查询均视作全部结果 returnData.data = result.payment;//返回的数据列表 //调用DataTables提供的callback方法，代表数据已封装完成并传回DataTables进行渲染 //此时的数据需确保正确无误，异常判断应在执行此回调前自行处理完毕 callback(returnData); } }); }, //列表表头字段 columns: [ { className: "center", orderable : false, bSortable : false, data : "_id", render : function(data, type, row, meta) { var content = '&lt;label class="position-relative">'; content += '&lt;input type="checkbox" class="ace" value="' + data + '" />'; content += '&lt;span class="lbl">&lt;/span>'; content += '&lt;/label>'; return content; } }, { "data": "type", render:function(date,type,full) { var content = null; if(date == 1) { content = '收入'; } else { content = '支出'; } return content; } }, { "data": "name" }, { "data": "price" }, { "data": "product_type" }, { "data": "meta.createAt", render:function(date,type,full) { return date.slice(0,10); } }, { bSortable : false, visible : true, data : "_id", render : function(data, type, full) { var content = '&lt;div class="hidden-sm hidden-xs action-buttons">'+ '&lt;a href="/payment/detail/' + data + '" class="blue">'+ '&lt;i class="ace-icon fa fa-search-plus bigger-130">&lt;/i>'+ ' &lt;/a>'+ '&lt;a href="javascript:void(0);" data-id="' + data + '" class="delete_btn red">'+ '&lt;i class="ace-icon fa fa-trash-o bigger-130">&lt;/i>'+ '&lt;/a>'+ '&lt;/div>'+ '&lt;div class="hidden-md hidden-lg">'+ ' &lt;div class="inline position-relative">'+ ' &lt;button data-toggle="dropdown" data-position="auto" class="btn btn-minier btn-yellow dropdown-toggle">&lt;i class="ace-icon fa fa-caret-down icon-only bigger-120">&lt;/i>&lt;/button>'+ '&lt;ul class="dropdown-menu dropdown-only-icon dropdown-yellow dropdown-menu-right dropdown-caret dropdown-close">'+ ' &lt;li>&lt;a href="/payment/detail/' + data + '" data-rel="tooltip" title="" data-original-title="View" class="tooltip-info">&lt;span class="blue">&lt;i class="ace-icon fa fa-search-plus bigger-120">&lt;/i>&lt;/span>&lt;/a>'+ '&lt;li>&lt;a data-rel="tooltip" title="" data-original-title="Delete" data-id="' + data + '" class="delete_btn tooltip-error">&lt;span class="red">&lt;i class="ace-icon fa fa-trash-o bigger-120">&lt;/i>&lt;/span>&lt;/a>&lt;/li>'+ '&lt;/ul>&lt;/div>&lt;/div>'; return content; } } ] }).api(); //此处需调用api()方法,否则返回的是JQuery对象而不是DataTables的API对象 });]]></content>
      <categories>
        <category>前端</category>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[moment格式化时间]]></title>
    <url>%2F2016%2F12%2F11%2Fmoment%2F</url>
    <content type="text"><![CDATA[首先，好久没有来多博客了 今天在学习MongoDB时，需要格式化时间，上网查了一下，nodejs中的moment模块可以格式化时间。首先，mongodb中有一个字段是Date类型需要一个默认值，就是当前时间，可以使用以下代码来格式化时间 moment().format('YYYY-MM-DD HH:mm:ss') 使用以下代码也是可以的 moment(Date.now()).format('YYYY-MM-DD HH:mm:ss') 目前只使用这两个方法，以后再来补充——————————————————分割线———————————-在存入数据库时，我已经格式化日期了，取出来发现是没有格式的数据，很纳闷，不知道原因，找到了解决办法。express我是用的jade模板，在app.js中加入 app.locals.moment = require('moment') 在jade中读取日期数据使用 #{moment(friend.createTime).format('YYYY-MM-DD HH:mm:ss')} 取出来的日期是格式化的]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs中使用mongoose保存数据]]></title>
    <url>%2F2016%2F12%2F11%2FuseMongoDB%2F</url>
    <content type="text"><![CDATA[最近在学习mongdb 以下是使用mongoose模块来保存数据 var mongoose = require('mongoose'); var moment = require('moment'); // 连接字符串格式为mongodb://主机/数据库名 mongoose.connect('mongodb://localhost/test'); var db = mongoose.connection; //输出连接日志 db.on('error', function callback() { console.log("Connection error"); }); db.once('open', function callback() { console.log("Mongo working!"); }); // 创建schema var Schema = mongoose.Schema; var userSchema = new Schema({ name: String, age: Number, createTime: { type: Date, default: moment().format('YYYY-MM-DD HH:mm:ss') }, updateTime: { type: Date, default: moment().format('YYYY-MM-DD HH:mm:ss') }, telphone: String }); // 构建model var User = mongoose.model('User', userSchema); //构建model实例 var userData = new User({ name: 'root', age: 21, telphone: '18766560229' }); // 保存数据 userData.save(function(err) { if (err) { console.log(err) } else { console.log('Save success'); } }) 还有，输出信息有以下信息：(node:7780) DeprecationWarning: Mongoose: mpromise (mongoose’s default promise library) is deprecated, plug in your own promise library instead: http://mongoosejs.com/docs/promises.html也不不知道是什么意思，需要补充]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs中使用mongoose保存数据]]></title>
    <url>%2F2016%2F12%2F11%2Fmongodb-use-in-node%2F</url>
    <content type="text"><![CDATA[最近在学习mongdb 以下是使用mongoose模块来保存数据 var mongoose = require('mongoose'); var moment = require('moment'); // 连接字符串格式为mongodb://主机/数据库名 mongoose.connect('mongodb://localhost/test'); var db = mongoose.connection; //输出连接日志 db.on('error', function callback() { console.log("Connection error"); }); db.once('open', function callback() { console.log("Mongo working!"); }); // 创建schema var Schema = mongoose.Schema; var userSchema = new Schema({ name: String, age: Number, createTime: { type: Date, default: moment().format('YYYY-MM-DD HH:mm:ss') }, updateTime: { type: Date, default: moment().format('YYYY-MM-DD HH:mm:ss') }, telphone: String }); // 构建model var User = mongoose.model('User', userSchema); //构建model实例 var userData = new User({ name: 'root', age: 21, telphone: '18766560229' }); // 保存数据 userData.save(function(err) { if (err) { console.log(err) } else { console.log('Save success'); } })]]></content>
      <categories>
        <category>nodejs</category>
        <category>数据库</category>
        <category>mongoDB</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[moment格式化时间]]></title>
    <url>%2F2016%2F12%2F11%2Fmoment-format-time%2F</url>
    <content type="text"><![CDATA[首先，好久没有来多博客了 今天在学习mongodb时，需要格式化时间，上网查了一下，nodejs中的moment模块可以格式化时间。首先，mongodb中有一个字段是Date类型需要一个默认值，就是当前时间，可以使用以下代码来格式化时间 moment().format(&#39;YYYY-MM-DD HH:mm:ss&#39;) 使用以下代码也是可以的 moment(Date.now()).format(&#39;YYYY-MM-DD HH:mm:ss&#39;)目前只使用这两个方法，以后再来补充 —————————分割线———————————- 在存入数据库时，我已经格式化日期了，取出来发现是没有格式的数据，很纳闷，不知道原因，找到了解决办法。express我是用的jade模板，在app.js中加入app.locals.moment = require(&#39;moment&#39;)在jade中读取日期数据使用#{moment(friend.createTime).format(&#39;YYYY-MM-DD HH:mm:ss&#39;)}取出来的日期是格式化的]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularjs中的$interpolate服务]]></title>
    <url>%2F2016%2F09%2F17%2FngInterpolate%2F</url>
    <content type="text"><![CDATA[$interpolate服务返回一个函数，用来在特定的上下文中运算表达式。示例：html代码： &lt;div ng-controller="myController"> &lt;input ng-model="to" type="email" placeholder="email" /> &lt;textarea ng-model="emailBody">&lt;/textarea> &lt;pre>{{previewText}}&lt;/pre> &lt;/div> js代码： angular.module('myApp', []) .controller('myController',['$scope','$interpolate', function($scope,$interpolate) { $scope.$watch('emailBody',function(body) { if(body) { var template = $interpolate(body); $scope.previewText = template({to:$scope.to}) } }) } ]) 使用：在输入框中输入你的email地址，在文本框中输入，previewText中的值即为to的值]]></content>
      <categories>
        <category>前端</category>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularjs中的$interpolate服务]]></title>
    <url>%2F2016%2F09%2F17%2Fangular-interpolate%2F</url>
    <content type="text"><![CDATA[$interpolate服务返回一个函数，用来在特定的上下文中运算表达式。示例： &lt;div ng-controller="myController"> &lt;input ng-model="to" type="email" placeholder="email" /> &lt;textarea ng-model="emailBody">&lt;/textarea> &lt;pre>{{previewText}}&lt;/pre> &lt;/div> angular.module('myApp', []) .controller('myController',['$scope','$interpolate', function($scope,$interpolate) { $scope.$watch('emailBody',function(body) { if(body) { var template = $interpolate(body); $scope.previewText = template({to:$scope.to}) } }) } ]) 使用：在输入框中输入你的email地址，在文本框中输入，previewText中的值即为to的值]]></content>
      <categories>
        <category>前端</category>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Java实现扑克牌洗牌]]></title>
    <url>%2F2016%2F07%2F20%2Fjava-poker%2F</url>
    <content type="text"><![CDATA[Java已经忘了差不多了，最近又需要重新捡起Java。对于一副扑克牌共有54张，扑克牌洗牌就是将这54张牌没有规律的输出出来，用ArrayList实现，本质是54个数的随机输出，穿了身衣服，输出出来就好看多了 public class Poker { public static String poker(int num) { String str = ""; String[] huase = {"红桃","黑桃","梅花","方块"}; String[] number = {"A","2","3","4","5","6","7","8","9","10","J","Q","K"}; if(num/4 > 12) { if(num%4 == 0) { str += "小鬼"; } else if(num%4 == 1) { str += "大鬼"; } } else { str += huase[num%4] + number[num/4] ; } return str; } } public class Client { public static void main(String[] args) { // 定义变量 ArrayList list = new ArrayList(); Random random = new Random(); Poker poker = new Poker(); int i = 0; // 向数组中增加数字 for(i=0;i&lt;54;i++) { list.add(poker.poker(i)); } // 随机输出数组中的每个数字 int length = list.size(); for(i=0;i&lt;length;i++) { //随机生成数组下标 int num = random.nextInt(list.size()); //取出数字 System.out.println(list.get(num)); //将数字从数组中移除 list.remove(num); } } } 看起来舒服多了]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css中margin的巧妙使用]]></title>
    <url>%2F2016%2F07%2F16%2Fcss-margin%2F</url>
    <content type="text"><![CDATA[今天在慕课上看了张大神又一力作，整理了一下margin的巧妙使用：1、margin实现自适应的宽高比为2：1的矩形 &lt;div id="container"> &lt;div class="box"> &lt;div>&lt;/div> &lt;/div> &lt;/div> &lt;style type=&quot;text/css&quot;&gt; #container { width: 400px; height: 250px; } .box { background-color: olive; overflow: hidden; } .box &gt; div { margin: 50%; } &lt;/style&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css+js实现图片反转效果]]></title>
    <url>%2F2016%2F07%2F16%2Fpicture-reversal%2F</url>
    <content type="text"><![CDATA[一个图片，点击图片图片反转180deg后，出现图片的简介 &lt;div class="container"> &lt;div class="photo-wrap photo-front"> &lt;div class="side side-front"> &lt;img src="img/banner.jpg"> &lt;/div> &lt;div class="side side-back"> &lt;p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Dolorem aliquid laboriosam a ipsam ducimus ea nobis officiis dignissimos consequuntur asperiores fuga illum saepe rem eius ipsa vel, atque eos optio?&lt;/p> &lt;/div> &lt;/div> &lt;/div> * { margin: 0; padding: 0; font-family: 'microsoft yahei'; } .container { width: 220px; height: 280px; margin: 0 auto; margin-top: 50px; } .photo-wrap,.side { width: 100%; height: 100%; } .photo-wrap { transform-style: preserve-3d; transition: all .3s; position: relative; } .photo-wrap.photo-front { transform: rotateY(0deg); } .photo-wrap.photo-back { transform: rotateY(180deg); } .side { position: absolute; top: 0; left: 0; } .side img{ width: 100%; height: 100%; backface-visibility:hidden; } .side-front { transform: rotateY(0deg); } .side-back { background-color: #fff; box-sizing: border-box; border: 5px solid #000; padding: 5px; transform: rotateY(180deg); } var photo_wrap = document.querySelector('.photo-wrap'); photo_wrap.onclick = function() { var str = this.className; if(/photo-front/.test(str)) { this.className = str.replace(/photo-front/,'photo-back'); } else if(/photo-back/.test(str)) { this.className = str.replace(/photo-back/,'photo-front'); } } }]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lineheight使图片多行文字垂直居中]]></title>
    <url>%2F2016%2F06%2F27%2Flineheight-vertical-middle%2F</url>
    <content type="text"><![CDATA[多行文字垂直居中 &lt;p class="mulit_line" style="width: 500px"> &lt;span style="font-size:12px;">Lorem ipsum dolor sit amet, consectetur adipisicing elit. Nemo voluptatum beatae officiis doloribus culpa et autem velit voluptatem quidem non, tempora, pariatur veritatis quaerat. Iste nisi nemo omnis, repellendus facilis.Lorem ipsum dolor sit amet, consectetur adipisicing elit. Nemo voluptatum beatae officiis doloribus culpa et autem velit voluptatem quidem non, tempora, pariatur veritatis quaerat. Iste nisi nemo omnis, repellendus facilis. &lt;/span> &lt;i>&amp;nbsp;&lt;/i> &lt;/p> .mulit_line{line-height:150px; border:1px dashed #cccccc; padding-left:5px;} .mulit_line span{display:-moz-inline-stack; display:inline-block; line-height:1.4em; vertical-align:middle;} .mulit_line i{width:0; display:-moz-inline-stack; display:inline-block; vertical-align:middle; font-size:0;} &lt;ul class="zxx_ul_image"> &lt;li>&lt;img src="http://image.zhangxinxu.com/image/study/s/s128/mm1.jpg" />&lt;/li> &lt;li>&lt;img src="http://image.zhangxinxu.com/image/study/s/s128/mm2.jpg" />&lt;/li> &lt;li>&lt;img src="http://image.zhangxinxu.com/image/study/s/s128/mm3.jpg" />&lt;/li> &lt;li>&lt;img src="http://image.zhangxinxu.com/image/study/s/s128/mm4.jpg" />&lt;/li> &lt;li>&lt;img src="http://image.zhangxinxu.com/image/study/s/s128/mm5.jpg" />&lt;/li> &lt;li>&lt;img src="http://image.zhangxinxu.com/image/study/s/s128/mm6.jpg" />&lt;/li> &lt;/ul> ```css .zxx_ul_image{overflow:hidden; zoom:1;} .zxx_ul_image li{float:left; width:150px; height:150px; text-align:center; line-height:150px; *font-size:125px;} .zxx_ul_image li:after{content:' '; vertical-align:middle;} .zxx_ul_image li img{vertical-align:middle;} 转载而来。。。]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Canvas+js实现贪吃蛇(4)]]></title>
    <url>%2F2016%2F06%2F25%2Fcanvas%2Bjs-4%2F</url>
    <content type="text"><![CDATA[将贪吃蛇改造成面向对象，类似插件的东西。 过程中，要把握好this的指向，因为这个，调试了好大会将randFood进行了修正，添加了一个配置参数与默认参数合并方法，其他的都还是一样的。html代码没有改，在第一篇文章里 function tanchishe(options) { this.canvas = options.canvas; this.span_score = options.span_score; this.context = this.canvas.getContext('2d'); this.snake = new Array(); //蛇身数组 this.snakeLength = 1; //蛇身长度 this.direct = options.direct || 37; //移动方向 this.food_x; //食物的坐标 可以改为object对象 this.food_y; this.score = 0; // 得分 this.timer; //setInterval var defaults = { maxNumber: 630, // 最大长宽，这里的画布是正方形 stride: 15, //每个小方块的长宽， speed: 300 // 移动速度 } this.settings(options, defaults); this.init(); this.update(); var self = this; document.onkeydown = function(event) { console.log(self.direct) var event = event || window.event; clearInterval(self.timer); // 37:左 38:上 39:右 40:下 var newDir = (event.keyCode > 36 &amp;&amp; event.keyCode &lt; 41) ? event.keyCode : 40; // 处理反方向 if (Math.abs(self.direct - newDir) == 2) { alert("头碰到身体了，Game over!"); } else { self.direct = newDir; self.update(); } } } // 将配置参数和默认参数合并 tanchishe.prototype.settings = function(options, defaults) { this.ops = options || {}; for (var i in defaults) { if (typeof options[i] === 'undefined') { options[i] = defaults[i]; } else if (typeof options[i] === 'object') { for (var deepDef in defaults[i]) { if (typeof options[i][j] === 'undefined') { options[i][j] = defaults[i][j]; } } } } } // 随机生成食物 tanchishe.prototype.randFood = function() { // 保证生成的食物会在小方格里 // 小方格的个数 var shang = this.ops.maxNumber / this.ops.stride; // 小方格个数的整数部分 var zheng = shang / 10; // 小方格的个位 var yu = shang % 10; do { this.food_x = Math.ceil(Math.random() * zheng + yu) * this.ops.stride + 1; this.food_y = Math.ceil(Math.random() * zheng + yu) * this.ops.stride + 1; } while (this.isBody(this.food_x, this.food_y)); } // 判断食物是否在蛇的身体上 tanchishe.prototype.isBody = function(param_x, param_y) { // 判断蛇头是否碰到了蛇身 for (var i = 0; i &lt; this.snakeLength - 1; i++) { if (this.snake[i].x === param_x &amp;&amp; this.snake[i].y === param_y) { return true; } } // 判断食物是否在蛇的身体上 var snakeLast = this.snake[this.snakeLength - 1]; if (snakeLast) { if (snakeLast.x === param_x &amp;&amp; snakeLast.y === param_y) { return true; } } return false; } // 定时更新画面 tanchishe.prototype.update = function() { var self = this; self.timer = setInterval(function() { // 到达边界 if (self.snake[0].x &lt; 1 || self.snake[0].y &lt; 1 || self.snake[0].x > self.ops.maxNumber || self.snake[0].y > self.ops.maxNumber) { clearInterval(self.timer); alert('出边界了，Game over!'); } else { // 重新绘制贪吃蛇 self.drawSnake(); // 检测是否吃到食物 self.checkFood(); } }, self.ops.speed) } // 绘制贪吃蛇 tanchishe.prototype.drawSnake = function() { // 擦出蛇尾巴 var snakeLast = this.snake[this.snakeLength - 1], snakeHead = this.snake[0]; this.clear(snakeLast.x, snakeLast.y); // 删除尾巴 this.snake.pop(); // 增加头 this.addHead(snakeHead.x, snakeHead.y); } // 增加头 tanchishe.prototype.addHead = function(param_x, param_y) { var newX, newY; // 37:左 38:上 39:右 40:下 switch (this.direct) { case 37: newX = param_x - this.ops.stride; newY = param_y; break; case 38: newY = param_y - this.ops.stride; newX = param_x; break; case 39: newX = param_x + this.ops.stride; newY = param_y; break; case 40: newY = param_y + this.ops.stride; newX = param_x; break; } // 增加蛇头 // 检测头是否 碰到身体 if (this.snakeLength > 3 &amp;&amp; this.isBody(newX, newY)) { clearInterval(this.timer); alert("头碰到身体了，Game over!"); } else { this.snake.unshift({ x: newX, y: newY }); this.draw(this.snake[0].x, this.snake[0].y); } } // 检测是否吃到食物 tanchishe.prototype.checkFood = function() { if (this.snake[0].x === this.food_x &amp;&amp; this.snake[0].y === this.food_y) { // 增加头 this.snakeLength += 1; this.addHead(this.food_x, this.food_y); // 改变分数 this.score += 10; this.span_score.innerHTML = this.score; // 改变速度 this.speed = (this.speed > 100) ? (this.speed - 20) : this.speed; this.randFood(); console.log(this.snake) console.log(this.food_x) console.log(this.food_y) this.draw(this.food_x, this.food_y); } } // 清除 tanchishe.prototype.clear = function(param_x, param_y) { this.context.clearRect(param_x, param_y, this.ops.stride - 2, this.ops.stride - 2); } // 画小方块 tanchishe.prototype.draw = function(param_x, param_y) { this.context.fillRect(param_x, param_y, this.ops.stride - 2, this.ops.stride - 2); } // 初始化函数 tanchishe.prototype.init = function() { this.canvas.width = this.ops.maxNumber; this.canvas.height = this.ops.maxNumber; this.context.lineWidth = 1; this.context.fillStyle = '#69D69E'; this.context.strokeStyle = "#89EFA3"; var i = 0; while (i &lt;= this.ops.maxNumber) { this.context.moveTo(0, i); this.context.lineTo(this.ops.maxNumber, i); this.context.stroke(); this.context.moveTo(i, 0); this.context.lineTo(i, this.ops.maxNumber); this.context.stroke(); i += this.ops.stride; } this.snake.push({ x: 31, y: 61 }); this.randFood(); this.draw(this.food_x, this.food_y); this.draw(this.snake[0].x, this.snake[0].y); } function tcs(options) { return new tanchishe(options); } 在html中调用就行了 window.onload=function(){ tcs({ canvas : document.getElementById('myCanvas'), span_score : document.getElementById('score'), maxNumber : 630, // 最大长宽，这里的画布是正方形 stride : 30, //每个小方块的长宽， speed : 300 // 移动速度 }); }]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js面向对象]]></title>
    <url>%2F2016%2F06%2F25%2Fjs-oop%2F</url>
    <content type="text"><![CDATA[今天看了一些js面向对象的视频，js做的事真的好多1、// 模拟重载2、// 调用子类的方法3、// 链式调用4、// 抽象类 代码奉上 // 模拟重载 function Person() { var args = arguments; if (typeof args[0] === 'object' &amp;&amp; args[0]) { if (args[0].name) { this.name = args[0].name; } if (args[0].age) { this.age = args[0].age; } } else { if (args[0]) { this.name = args[0]; } if (args[1]) { this.age = args[1]; } } } Person.prototype.toString = function() { var str = 'name=' + this.name + ',age=' + this.age; console.log(str) return str; } var bosn = new Person('Bosn', 27); bosn.toString(); var bosnO = new Person({ name: 'bosnO', age: 38 }); bosnO.toString(); // 调用子类的方法 function Person(name) { this.name = name; } function Student(name, className) { this.className = className; Person.call(this, name); } var bosn = new Student('Bosn', 'sw2'); Person.prototype.init = function() { }; Student.prototype.init = function() { // do sth Person.prototype.init.apply(this, arguments); } // 链式调用 function classManager() { // } classManager.prototype.addClass = function(str) { console.log('Class:' + str + 'added'); return this; }; classManager.addClass('classA').addClass('classB').addClass('classC'); // 抽象类 function DetectorBase() { throw new Error('Abstract class can not be invoked directly!'); } DetectorBase.detect = function() { console.log('Detection starting...'); }; DetectorBase.stop = function() { console.log('Detector stopping...'); }; DetectorBase.init = function() { throw new Error('Error'); }; function LinkDetector() { // } LinkDetector.prototype = Object.create(Detector.prototype); LinkDetector.prototype.constructor = LinkDetector; // add methods to LinkDetector...]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js面向对象与继承]]></title>
    <url>%2F2016%2F06%2F23%2Fjs-oop-2%2F</url>
    <content type="text"><![CDATA[直接来代码 function Person(name, age) { this.name = name; this.age = age; } Person.prototype.hi = function() { console.log('Hi,my name is' + this.name + ',I`m ' + this.age + ' years old now.'); }; Person.prototype.LESS_NUM = 2; Person.prototype.ARMS_NUM = 2; Person.prototype.walk = function() { console.log(this.name + 'is walking...'); }; function Student(name, age, className) { Person.call(this, name, age); this.className = className; } Student.prototype = Object.create(Person.prototype); Student.prototype.constructor = Student; Student.prototype.hi = function() { console.log('Hi,my name is' + this.name + ',I`m ' + this.age + ' years old now,and from ' + this.className + '.'); }; Student.prototype.learn = function(subject) { console.log(this.name + ' is learning ' + subject + 'at ' + this.className + '.'); }; // test var bosn = new Student('Bosn', 27, 'class 2,Grade 2'); bosn.hi(); console.log(bosn.LESS_NUM); bosn.walk(); bosn.learn('math'); 结果如下： 补充：Object.create是在ES5以后才开始支持的，处理优化时可以使用以下代码if (!Object.create) { Object.create = function(proto) { function F() {} F.prototype = proto; return new F; } }]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Canvas+js实现贪吃蛇(3)]]></title>
    <url>%2F2016%2F06%2F23%2Fcanvas%2Bjs-3%2F</url>
    <content type="text"><![CDATA[想了想，蛇向下走的时候按上键，如果直接将蛇头变蛇身，好像不符合常理，所以处理这种情况，应当做蛇头碰到蛇身。。另外，实现蛇头碰蛇身的功能界面就不美化了。。。下一步就是封装成面向对象的插件了。。。 ```jswindow.onload = function() { var canvas = document.getElementById(‘myCanvas’), span_score = document.getElementById(‘score’), context = canvas.getContext(‘2d’), maxNumber = 630, // 最大长宽，这里的画布是正方形 stride = 15, //每个小方块的长宽， snakeLength = 1, //蛇身长度 snake = new Array(), //蛇身数组 speed = 300, // 移动速度 direct = 37, //移动方向 food_x = 31, //食物的坐标 可以改为object对象 food_y = 121, score = 0, // 得分 timer; //setInterval init(); update(); document.onkeydown=function(event) { clearInterval(timer); // 37:左 38:上 39:右 40:下 // 改为以下 内容 ，处理反方向的bug var newDir = (event.keyCode &gt; 36 &amp;&amp; event.keyCode &lt; 41) ? event.keyCode : 40; // 处理反方向 if(Math.abs(direct - newDir) == 2) { alert(“头碰到身体了，Game over!”); } else { direct = newDir; update(); } } // 随机生成食物 function randFood() { do{ food_x = Math.ceil(Math.random() 40 + 2) 15 + 1; food_y = Math.ceil(Math.random() 40 + 2) 15 + 1; }while(isBody(food_x,food_y)); } // 判断食物是否在蛇的身体上 function isBody(param_x,param_y) { // 判断蛇头是否碰到了蛇身 for (var i = 0; i &lt; snakeLength - 1; i++) { if(snake[i].x === param_x &amp;&amp; snake[i].y === param_y) { return true; } } // 判断食物是否在蛇的身体上 var snakeLast = snake[snakeLength-1]; if(snakeLast) { if(snakeLast.x === param_x &amp;&amp; snakeLast.y === param_y) { return true; } } return false; } // 定时更新画面 function update() { timer = setInterval(function() { // 到达边界 if(snake[0].x &lt; 1 || snake[0].y &lt; 1 || snake[0].x &gt; maxNumber || snake[0].y &gt; maxNumber) { clearInterval(timer); alert(‘出边界了，Game over!’); } else { // 重新绘制贪吃蛇 drawSnake(); // 检测是否吃到食物 checkFood(); } },speed) } // 绘制贪吃蛇 function drawSnake() { // 擦出蛇尾巴 var snakeLast = snake[snakeLength-1], snakeHead = snake[0]; clear(snakeLast.x,snakeLast.y); // 删除尾巴 snake.pop(); // 增加头 addHead(snakeHead.x,snakeHead.y); } // 增加头 function addHead(param_x,param_y) { var newX,newY; // 37:左 38:上 39:右 40:下 switch (direct) { case 37: newX = param_x - stride; newY = param_y; break; case 38: newY = param_y - stride; newX = param_x; break; case 39: newX = param_x + stride; newY = param_y; break; case 40: newY = param_y + stride; newX = param_x; break; } // 增加蛇头 // 检测头是否 碰到身体 if(snakeLength &gt; 3 &amp;&amp; isBody(newX,newY)) { clearInterval(timer); alert(&quot;头碰到身体了，Game over!&quot;); } else { snake.unshift({x:newX,y:newY}); draw(snake[0].x,snake[0].y); } } // 检测是否吃到食物 function checkFood() { if(snake[0].x === food_x &amp;&amp; snake[0].y === food_y) { // 增加头 snakeLength += 1; addHead(food_x,food_y); // 改变分数 score += 10; span_score.innerHTML = score; // 改变速度 speed = (speed &gt; 100) ? (speed - 20) : speed; randFood(); draw(food_x,food_y); } } // 清除 function clear(param_x,param_y) { context.clearRect(param_x,param_y,stride - 2,stride - 2); } // 画小方块 function draw(param_x,param_y) { context.fillRect(param_x,param_y,stride - 2,stride - 2); } // 初始化函数 function init() { context.lineWidth = 1; context.fillStyle = ‘#69D69E’; context.strokeStyle=”#89EFA3”; var i = 0; while(i &lt;= maxNumber) { context.moveTo(0, i); context.lineTo(maxNumber,i); context.stroke(); context.moveTo(i,0); context.lineTo(i,maxNumber); context.stroke(); i += stride; } snake.push({x:31,y:61}); randFood(); draw(food_x,food_y); draw(snake[0].x,snake[0].y); }} ps：所有测试都是在最新版本的谷歌浏览器下进行]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Canvas+js实现贪吃蛇(2)]]></title>
    <url>%2F2016%2F06%2F19%2Fcanvas%2Bjs-2%2F</url>
    <content type="text"><![CDATA[相比1 来说，增加了，以下功能：1、蛇每次一次食物，蛇身就增加 2、吃一次食物，速度就加快20毫秒未实现：蛇头碰到蛇身时，游戏结束。。。。bug：在它向上移动时，按 向下键，身体出问题了，不过 不影响继续游戏 。。同理，上下左右都有这个问题(已解决) 参数： var canvas = document.getElementById('myCanvas'), span_score = document.getElementById('score'), context = canvas.getContext('2d'), maxNumber = 630, // 最大长宽，这里的画布是正方形 stride = 15, //每个小方块的长宽， snakeLength = 1, //蛇身长度 snake = new Array(), //蛇身数组 speed = 500, // 移动速度 direct = 37, //移动方向 food_x = 31, //食物的坐标 可以改为object对象 food_y = 121, score = 0, // 得分 timer; //setInterval ```js document.onkeydown=function(event) { clearInterval(timer); // 将下面一行改为 direct = (event.keyCode &gt; 36 &amp;&amp; event.keyCode &lt; 41) ? event.keyCode : 40; // 改 为以下 内容 ，处理反方向的bug var newDir = (event.keyCode &gt; 36 &amp;&amp; event.keyCode &lt; 41) ? event.keyCode : 40; // 处理反方向 if(Math.abs(direct - newDir) === 2) { snake.reverse(); } direct = newDir; update();}// 随机生成食物function randFood() { do{ food_x = Math.ceil(Math.random() 40 + 2) 15 + 1; food_y = Math.ceil(Math.random() 40 + 2) 15 + 1; }while(isBody(food_x,food_y)); } // 判断食物是否在蛇的身体上 function isBody(param_x,param_y) { for (var i = 0; i &lt; snakeLength; i++) { if(snake[i].x === param_x &amp;&amp; snake[i].y === param_y) { return true; } } return false; } // 定时更新画面 function update() { timer = setInterval(function() { // 到达边界 if(snake[0].x &lt; 1 || snake[0].y &lt; 1 || snake[0].x &gt; maxNumber || snake[0].y &gt; maxNumber) { clearInterval(timer); alert(“Game over!”); } else { // 重新绘制贪吃蛇 drawSnake(); // 检测是否吃到食物 checkFood(); } },speed) } // 绘制贪吃蛇 function drawSnake() { // 擦出蛇尾巴 var snakeLast = snake[snakeLength-1], snakeHead = snake[0], newX,newY; clear(snakeLast.x,snakeLast.y); // 删除尾巴 snake.pop(); // 增加头 addHead(snakeHead.x,snakeHead.y); console.log(snake); } // 增加头 function addHead(param_x,param_y) { var newX,newY; // 37:左 38:上 39:右 40:下 switch (direct) { case 37: newX = param_x - stride; newY = param_y; break; case 38: newY = param_y - stride; newX = param_x; break; case 39: newX = param_x + stride; newY = param_y; break; case 40: newY = param_y + stride; newX = param_x; break; } // 增加蛇头 snake.unshift({x:newX,y:newY}); draw(snake[0].x,snake[0].y); } // 检测是否吃到食物 function checkFood() { if(snake[0].x === food_x &amp;&amp; snake[0].y === food_y) { // 增加头 snakeLength += 1; addHead(food_x,food_y); // 改变分数 score += 10; span_score.innerHTML = score; // 改变速度 speed = (speed &gt; 100) ? (speed - 20) : speed; randFood(); draw(food_x,food_y); } } // 清除 function clear(param_x,param_y) { context.clearRect(param_x,param_y,stride - 2,stride - 2); } // 画小方块 function draw(param_x,param_y) { context.fillRect(param_x,param_y,stride - 2,stride - 2); } // 初始化函数 function init() { context.lineWidth = 1; context.fillStyle = ‘#69D69E’; context.strokeStyle=”#89EFA3”; var i = 0; while(i &lt;= maxNumber) { context.moveTo(0, i); context.lineTo(maxNumber,i); context.stroke(); context.moveTo(i,0); context.lineTo(i,maxNumber); context.stroke(); i += stride; } snake.push({x:31,y:61}); randFood(); draw(food_x,food_y); draw(snake[0].x,snake[0].y); }} PS：所有测试都是在最新版本的谷歌浏览器下进行]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Canvas+js实现贪吃蛇(1)]]></title>
    <url>%2F2016%2F06%2F12%2Fcanvas%2Bjs-1%2F</url>
    <content type="text"><![CDATA[今天想写一个贪吃蛇的页面，于是就选择了Canvs，不过只实现蛇身的长度是1的情况，对于蛇身大于2的情况，我还没想出来 如何绘制蛇，等查资料后，再来实现下面是源码部分： &lt;div style=" text-align: center"> &lt;canvas id="myCanvas" width="630" height="630">&lt;/canvas> &lt;/div> &lt;div style="position: absolute;top: 300px;left: 30px;"> score:&lt;span id="score">0&lt;/span> &lt;/div> window.onload = function() { var canvas = document.getElementById('myCanvas'), span_score = document.getElementById('score'), context = canvas.getContext('2d'), maxNumber = 630, stride = 15, x = 31, y = 61, SnakeLen = 1, speed = 500, direct = 37, food_x = Math.ceil(Math.random() * 40 + 2) * 15 + 1, food_y = Math.ceil(Math.random() * 40 + 2) * 15 + 1, score = 0, timer; init(); update(); document.onkeydown=function(event) { clearInterval(timer) direct = event.keyCode; update(); } // 定时更新画面 function update() { timer = setInterval(function() { var _x = x, _y = y; // 37:左 38:上 39:右 40:下 switch (direct) { case 37: x = x - stride; break; case 38: y = y - stride; break; case 39: x = x + stride; break; case 40: y = y + stride; break; default: x = x - stride; break; } // 到达边界 if(x < 1 || y < 1 || x > maxNumber || y > maxNumber) { clearInterval(timer); alert("Game over!"); } else { // 擦除贪吃蛇 clear(_x,_y); // 重新绘制贪吃蛇 draw(x,y); // 检测是否吃到食物 checkFood(); } },speed) } // 绘制贪吃蛇 function drawSnake() { // } // 检测是否吃到食物 function checkFood() { if(x === food_x && y === food_y) { food_x = Math.ceil(Math.random() * 40 + 2) * 15 + 1; food_y = Math.ceil(Math.random() * 40 + 2) * 15 + 1; draw(food_x,food_y); SnakeLen++; score += 10; span_score.innerHTML = score; } } // 清除 function clear(x,y) { context.clearRect(x,y,stride - 2,stride - 2); } // 画食物 function draw(x,y) { context.fillRect(x,y,stride - 2,stride - 2); } // 初始化函数 function init() { context.lineWidth = 1; context.fillStyle = '#69D69E'; context.strokeStyle="#89EFA3"; var i = 0; while(i]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3实现炫酷进度条]]></title>
    <url>%2F2016%2F06%2F10%2Fcss-progress-bar%2F</url>
    <content type="text"><![CDATA[看了一个进度条很漂亮，所以自己试试看 &lt;div class="load-container"> &lt;span class="run">&lt;/span> &lt;div class="meter">0&lt;/div> &lt;/div> * { margin: 0; padding: 0; font-family: 'microsoft yahei'; } html,body { width: 100%; height: 100%; background-color: #222; } .load-container { width: 600px; height: 6px; margin: 0 auto; margin-top: 200px; background-image: -webkit-linear-gradient(left,#5bd8ff, #ff0000); border-radius: 5px; position: relative; } .run { position: absolute; width: 0px; height: 6px; right: 0px; background: #000; border-radius: 5px; animation: runnAnimation 10s linear; } @keyframes runnAnimation { 0% { width: 600px; } 100% { width: 0px; } } .run:after { content: ""; display: block; width: 16px; height: 16px; border-radius: 50%; background-color: #f00; margin-left: -4px; margin-top: -4px; animation: destination 10s linear; } @keyframes destination { 0% { background-color: #5bd8ff; } 100% { background-color: red; } } .meter { float: right; margin-top: 10px; font-size: 40px; color: red; animation: fontColor 10s linear; } @keyframes fontColor { 0% { color: #5bd8ff; } 100% { color: red; } } .meter:after { content: "%" } ```jswindow.onload = function() { var meter = document.querySelector(‘.meter’); run(meter,100); function run(el,time) { time = time ? time : 100; el = el ? el : document; var i = 0; var timer = setInterval(function() { if(i&lt;100) { i++; el.innerHTML = i; } else { clearInterval(timer); } },time) } } 如果想要调整进度时间，需要修改css样式中animation的时间和js中的时间 PS：css未做前缀处理，所有测试都在最新谷歌浏览器下进行]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3中-webkit-text-size-adjust]]></title>
    <url>%2F2016%2F06%2F08%2Fwebkit-text-size-adjust%2F</url>
    <content type="text"><![CDATA[1、当样式表里font-size&lt;12px时，chrome浏览器里字体显示仍为12px，这时可以用 html{-webkit-text-size-adjust:none;} 2、-webkit-text-size-adjust放在body上会导致页面缩放失效 3、body会继承定义在html的样式 4、用-webkit-text-size-adjust不要定义成可继承的或全局的]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3中的display(box)]]></title>
    <url>%2F2016%2F06%2F08%2Fcss-display-box%2F</url>
    <content type="text"><![CDATA[今天看源码时，看到了display: -webkit-box;display: box; 似乎是第一次见，上网搜寻： display: box;的声明其实就是弹性盒子模型的声明，此声明下的子元素的行为与表现与CSS2中的传统盒子模型的表现是有显著的差异的。 毕竟属于CSS3的东西，目前而言，仅Firefox/Chrome/Safari浏览器支持弹性盒子模型（IE9不详，Opera尚未），且使用的时候，需要附带私有前缀。就是诸如-moz-, -webkit-之类。 父元素使用display:box;子元素就可以使用box-flex瓜分父元素的地方了 1、之前要实现横列的web布局，通常就是float或者display：inline-block;，但是都不能做到真正的流体布局。至少width要自己去算百分比。2.flexible box就可以实现真正意义上的流体布局。只要给出相应属性，浏览器会帮我们做额外的计算。 提供的关于盒模型的几个属性： box-orient 子元素排列方向，值为horizontal | vertical | inline-axis | block-axis | inherit box-flex 兄弟元素之间比例，仅作一个系数 box-align 剩余空间如何使用 box-direction 子元素的排列顺序，值为：normal | reverse | inherit box-flex-group 以组为单位的流体系数 box-lines 子元素是否换行显示 box-ordinal-group 以组为单位的子元素排列方向box-pack 父元素水平遗留空间的使用 参考来源]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window.onload，body onload，document.onreadystatechange]]></title>
    <url>%2F2016%2F06%2F08%2Fjavascript-onload%2F</url>
    <content type="text"><![CDATA[1、window.onload 页面全部加载完成，甚至包括图片 2、body.onload 等doucment加载完成再加载相应的脚本 3、document.onreadystatechange 当页面加载状态改变的时候执行这个方法。 document.onreadystatechange = subSomething;//当页面加载状态改变的时候执行这个方法. function subSomething() { if(document.readyState == "complete"){ //当页面加载状态为完全结束时进入 //你要做的操作。 } }]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3实现二级菜单]]></title>
    <url>%2F2016%2F06%2F08%2Fcss-secondary-menu%2F</url>
    <content type="text"><![CDATA[今天看了一个demo，原demo虽说是CSS3实现，但其中也使用了js，再一个里面的代码有些地方，我觉得还可以优化 ，所以自己就尝试着用css3实现一下 我想说: 不论写一个什么样的demo，z-index的值都最好不要超过2下面是源码： &lt;div class="sidebar"> &lt;h1>&lt;i class="fa fa-bars push">&lt;/i>Animated &lt;span class="color">Menu&lt;/span>&lt;/h1> &lt;ul> &lt;li>&lt;a href="#">&lt;i class="fa fa-dashboard push">&lt;/i>Dashboard&lt;i class="fa fa-angle-right">&lt;/i>&lt;/a>&lt;span class="hover">&lt;/span> &lt;/li> &lt;li>&lt;a href="#">&lt;i class="fa fa-user push">&lt;/i>Users&lt;i class="fa fa-angle-right">&lt;/i>&lt;/a>&lt;span class="hover">&lt;/span> &lt;ul class="sub-menu"> &lt;li>&lt;a href="#">Add User&lt;i class="fa fa-angle-right">&lt;/i>&lt;/a>&lt;span class="hover">&lt;/span>&lt;/li> &lt;li>&lt;a href="#">Manage Users&lt;i class="fa fa-angle-right">&lt;/i>&lt;/a>&lt;span class="hover">&lt;/span>&lt;/li> &lt;/ul> &lt;/li> &lt;li>&lt;a href="#">&lt;i class="fa fa-cog push">&lt;/i>Settings&lt;i class="fa fa-angle-right">&lt;/i>&lt;/a>&lt;span class="hover">&lt;/span> &lt;ul class="sub-menu"> &lt;li>&lt;a href="#">Dashboard Settings&lt;i class="fa fa-angle-right">&lt;/i>&lt;/a>&lt;span class="hover">&lt;/span>&lt;/li> &lt;li>&lt;a href="#">Profile Settings&lt;i class="fa fa-angle-right">&lt;/i>&lt;/a>&lt;span class="hover">&lt;/span>&lt;/li> &lt;li>&lt;a href="#">Manage Menu&lt;i class="fa fa-angle-right">&lt;/i>&lt;/a>&lt;span class="hover">&lt;/span>&lt;/li> &lt;li>&lt;a href="#">User Profiles&lt;i class="fa fa-angle-right">&lt;/i>&lt;/a>&lt;span class="hover">&lt;/span>&lt;/li> &lt;/ul> &lt;/li> &lt;li>&lt;a href="#">&lt;i class="fa fa-picture-o push">&lt;/i>appearance&lt;i class="fa fa-angle-right">&lt;/i>&lt;/a>&lt;span class="hover">&lt;/span> &lt;ul class="sub-menu"> &lt;li>&lt;a href="#">Change Theme&lt;i class="fa fa-angle-right">&lt;/i>&lt;/a>&lt;span class="hover">&lt;/span> &lt;/li> &lt;li>&lt;a href="#">Theme Options&lt;i class="fa fa-angle-right">&lt;/i>&lt;/a>&lt;span class="hover">&lt;/span>&lt;/li> &lt;/ul> &lt;/li> &lt;li>&lt;a href="#">&lt;i class="fa fa-file push">&lt;/i>Information&lt;i class="fa fa-angle-right">&lt;/i>&lt;/a>&lt;span class="hover">&lt;/span> &lt;ul class="sub-menu"> &lt;li>&lt;a href="#">Latest News&lt;i class="fa fa-angle-right">&lt;/i>&lt;/a>&lt;span class="hover">&lt;/span> &lt;/li> &lt;li>&lt;a href="#">Recent Articles&lt;i class="fa fa-angle-right">&lt;/i>&lt;/a>&lt;span class="hover">&lt;/span>&lt;/li> &lt;/ul> &lt;/li> &lt;li>&lt;a href="#">&lt;i class="fa fa-plane push">&lt;/i>Contact&lt;i class="fa fa-angle-right">&lt;/i>&lt;/a>&lt;span class="hover">&lt;/span>&lt;/li> &lt;/ul> &lt;/div> * { padding: 0; margin: 0; font-family: "microsoft yahei" } a { color: #000; text-decoration: none; } ul { list-style: none } li { margin-right: 15px; } html,body { background-color: #808080; height: 100%; } .sidebar { background: url(img/menu_pattern_1.png); width: 200px; height: 100%; border-right: 10px solid #d00355; color: #fff; padding-left: 40px; } .sidebar h1 { font-size: 16px; height: 80px; line-height: 80px; } .sidebar h1 .color { color: #d00355; } .sidebar ul li { padding: 8px; } .sidebar ul li a { color: #6B6363; position: relative; z-index: 1; } .sidebar ul li a .fa-angle-right { position: absolute; left: 160px; top: 4px; } .sidebar ul li .hover { display: block; position: absolute; width: 0; height: 37px; margin-top: -30px; margin-left: -8px; z-index: 0; background-color: #d00355; opacity: 0; transition: all .5s .1s; } .sidebar ul li .sub-menu { display: block; background: url(img/menu_pattern_1.png); position: absolute; margin-left: 192px; margin-top: -31px; width: 200px; opacity: 0; } .sidebar > ul > li:hover ul { opacity: 1; } .sidebar ul li:hover .hover { width: 200px; opacity: 1; } .sidebar > ul > li:hover a{ color: #fff; } 1、在li标签中有两个元素，a标签和span标签，对于span标签，我使用了绝对定位，当然这个绝对定位和平常使用的绝对定位元素是不一样的，因为在li标签上没有相对定位这个属性，这个小技巧是来源于一个博客。而a标签中的class为fa-angle-right使用了绝对定位，与span标签是一种想法，a标签上我也不想给它加上相对定位这个包袱。可是，问题出现了，无论我怎样调整a标签和span标签的z-index，span标签都会把a标签给盖住，去网上搜了一下解决办法，于是给a加上了绝对定位这个属性，于是可以达到我想要的效果了，所以我就把fa-angle-right的属性改为了平常使用的绝对定位。。。真是不甘心呀。。2、对于class为sub-menu的ul中的span，当我将鼠标滑过li标签时，li标签会出现span的宽度由0到200的效果，但是class为sub-menu的ul中的span却不会出现类似的效果，在测试时，如果将sub-menu的display属性设置为block，那麽滑过相应的li时，sub-menu中的span会出现想要的效果，当时很是着急，想来想去，问题可能出现在display这个属性上，虽然找不到具体的原因是什么，只能找对应的解决办法，有其他的属性，可以让一个元素从无变有吗？有opcity属性，于是将display的变化，改为了opcity的变化，想要的效果就出现了，用display，出现不了想要的效果，得原因是什么？需要去查查。。。 PS：css未做前缀的处理，所有的测试在最新版本的谷歌浏览器下进行 补充：修改一下二级菜单中的字体大小，text-transform 属性控制文本的大小写，值none/capitalize/uppercase/lowercase/inherit]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js点击列表的第一个元素，不起作用，最后一个元素起作用(闭包)]]></title>
    <url>%2F2016%2F06%2F06%2Fjs-closure%2F</url>
    <content type="text"><![CDATA[在网上看到 手风琴菜单的demo，就想来模仿着做一个 &lt;div class="container"> &lt;ul> &lt;li class="dropdown"> &lt;a href="#" data-toggle="dropdown">First Menu &lt;i class="icon-arrow">&lt;/i>&lt;/a> &lt;ul class="dropdown-menu"> &lt;li>&lt;a href="#">Home&lt;/a>&lt;/li> &lt;li>&lt;a href="#">About Us&lt;/a>&lt;/li> &lt;li>&lt;a href="#">Services&lt;/a>&lt;/li> &lt;li>&lt;a href="#">Contact&lt;/a>&lt;/li> &lt;/ul> &lt;/li> &lt;li class="dropdown"> &lt;a href="#" data-toggle="dropdown">Second Menu &lt;i class="icon-arrow">&lt;/i>&lt;/a> &lt;ul class="dropdown-menu"> &lt;li>&lt;a href="#">Home&lt;/a>&lt;/li> &lt;li>&lt;a href="#">About Us&lt;/a>&lt;/li> &lt;li>&lt;a href="#">Services&lt;/a>&lt;/li> &lt;li>&lt;a href="#">Contact&lt;/a>&lt;/li> &lt;/ul> &lt;/li> &lt;li class="dropdown"> &lt;a href="#" data-toggle="dropdown">Third Menu &lt;i class="icon-arrow">&lt;/i>&lt;/a> &lt;ul class="dropdown-menu"> &lt;li>&lt;a href="#">Home&lt;/a>&lt;/li> &lt;li>&lt;a href="#">About Us&lt;/a>&lt;/li> &lt;li>&lt;a href="#">Services&lt;/a>&lt;/li> &lt;li>&lt;a href="#">Contact&lt;/a>&lt;/li> &lt;/ul> &lt;/li> &lt;/ul> &lt;/div> window.onload = function() { var dropdown = document.querySelectorAll('.dropdown'); for (var i = 0; i &lt; dropdown.length; i++) { var button = dropdown[i].querySelector('a[data-toggle="dropdown"]'), menu = dropdown[i].querySelector('.dropdown-menu'), icon = button.querySelector('.icon-arrow'); addEvent(button, "click",function(event) { // var menu = this.nextElementSibling, // icon = this.querySelector('.icon-arrow'); if(hasClass(menu,"show")) { menu.classList.remove("show"); icon.classList.remove("open") ; } else { menu.classList.add("show"); icon.classList.add("open"); } event.preventDefault(); }); } function hasClass(ele,className) { return ele.className &amp;&amp; new RegExp("(^|\\s)" + className + "(\\s|$)").test(ele.className); } } 发现错误，无论我点击那一个li列表，有效果的 总是最后一个，那麽出错原因应是 menu、 icon的获取，但是我还是没找到 原因，于是就修改了一下，改为在button事件中获取menu、button，这次对了，可是我还是不知道我的错在哪？求各位指点。。。。。 原因是：当为button绑定时间时，for循环早就走完了，于是改正一下，将for循环中的内容放在闭包中，改为一下写法： for (var i = 0; i &lt; dropdown.length; i++) { (function() { var button = dropdown[i].querySelector('a[data-toggle="dropdown"]'), menu = dropdown[i].querySelector('.dropdown-menu'), icon = button.querySelector('.icon-arrow'); addEvent(button, "click",function(event) { // var menu = this.nextElementSibling, // icon = this.querySelector('.icon-arrow'); if(hasClass(menu,"show")) { menu.classList.remove("show"); icon.classList.remove("open") ; } else { menu.classList.add("show"); icon.classList.add("open"); } event.preventDefault(); }); })(i); } ```css * { margin: 0; padding: 0; font-family: "microsoft yahei"; box-sizing: border-box;; } a { color: #000; text-decoration: none; } ul { list-style: none; } .container { width: 100%; height: auto; } .container> ul { width: 320px; height: auto; margin: 50px auto; } .container ul .dropdown { width: 100%; position: relative; } .container ul .dropdown a { display: block; width: 100%; height: 100%; background-color: #2980b9; line-height: 40px; padding-left: 10px; color: #fff; box-shadow: 0 -1px 0px #409ad5 inset,0 -1px 0px #20638f inset; } .container ul .dropdown a .icon-arrow { position: absolute; right: 10px; top: 17px; width: 12px; height: 12px; transition: all .3s; } .container ul .dropdown a .icon-arrow:after { content: ""; border:6px solid transparent; border-top: 6px solid #fff; } .container ul .dropdown a .icon-arrow.open { transform: rotate(-180deg) } .container ul .dropdown .dropdown-menu { display: none } .container ul .dropdown .dropdown-menu.show{ display: block } .container ul .dropdown .dropdown-menu a { background-color: #EEEEEE; color: #6e6e6e; box-shadow: 0 -1px 0px #C3C3C3 inset; }]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript删除元素]]></title>
    <url>%2F2016%2F06%2F03%2Fjs-delete-dom%2F</url>
    <content type="text"><![CDATA[有一段html代码 &lt;div> &lt;div id="div1">div1&lt;/div> &lt;div id="div2">div2&lt;/div> &lt;div id="div3">div3&lt;/div> &lt;div id="div4">div4&lt;/div> &lt;div id="div5">div5&lt;/div> &lt;/div> 假如我想删除div中的第二个div，我需要找到这个元素，在找到父元素，用removeChild进行删除。但是，看到一个办法，就是使用 outerHTML = ‘’ 这个方法，outerHTML可以获得含标签在内的字符串，将字符串置空，div就消失了。 不知道这个方法有什么后遗症，待实际使用后，再来补充。 PS：所有的测试都是在谷歌浏览器上进行的]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript文档中常用的集合]]></title>
    <url>%2F2016%2F06%2F02%2FjavaScript-set%2F</url>
    <content type="text"><![CDATA[1、forms集合2、elements集合3、options集合4、rows集合5、cells集合6、images集合7、links集合8、anchors集合9、frames集合使用：假如想获得 一个html中所有img标签的元素，你可以使用document.getElementsByTagName(‘img’)，更简单的办法是document.images]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[offsetTop和offset().top]]></title>
    <url>%2F2016%2F06%2F01%2FoffsetTop-and-offset-top.top%2F</url>
    <content type="text"><![CDATA[前段时间写了一个视觉差滚动的demo，是用js实现的。第二次看这个例子，我想封装一个jquery插件。首先demo中有两个button需要在jq中对它们进行定位，然而问题来了 我先得到第一张图片的位置，对图片中的button的top进行定位时，想法是将css样式中的top设置成this.img.offset().top + this.img.height() / 2 - this.prev.height() / 2 + &#39;px&#39;，然而却出现了上图的效果，button跑到了下方。将this.img.offset().top改为this.img.position().top依然无法出现我想要的效果 ，什么原因呢？在用js实现时，也是采用的这种思想，用的是img.offsetTop + img.clientHeight/2 - prev.clientHeight/2 + &#39;px&#39;，这个是正常显示的。于是在例子中我打印出来this.img.offset().top和 img.offsetTop和this.img.position().top 的值，分别是185，35，0，这个 是什么原因呢？经过测试，offset()得到的结果永远是相对于文档的偏移值，它会忽略元素所有的父元素；查了一下资料，其中position()属性是获取它最近的具有相对位置（position:relative）的父级元素的距离，如果找不到这样的元素，则返回相对于浏览器的距离。可是，这样得出的0值不符合我的预期，在html结构中，离img最近的relative元素是.wrap元素（请参见另一篇文章http://blog.csdn.net/u013742084/article/details/51339213），想象中应该是35才对，这一次是怎么也想不通了。。。。待后续补充。。。offsetTop获取它最近的具有相对位置（position:relative）的父级元素的距离，如果找不到这样的元素，则返回相对于浏览器的距离。这是一个相当纠结的属性；我做了一个测试。 &lt;h1 style="text-align: center;background-color: #222;">这是一个大大的标题&lt;/h1> &lt;div id="container"> &lt;div class="panel" id="panel1">&lt;/div> &lt;div class="panel" id="panel2">&lt;/div> &lt;div class="panel" id="panel3">&lt;/div> &lt;/div> * { margin: 0; padding: 0; font-family: 'Microsoft Yahei' } a { color: #000; text-decoration: none; } .panel { margin:20px auto 20px auto; width:80%; height: 500px; transition: all .3s; } #panel1 {background-color: red;} #panel2 {background-color: green;} #panel3 {background-color: blue;} 打印id为panel1的offsetTop、offset().top、position().top的值为62 62 42我为id为container的div添加样式： style=&quot;position: relative;&quot;结果是 0 62 -20，百思不得其解我有尝试了一个新的思路，在原有的上面的html结构上，添加两个操作：为id为container的div添加样式： style=&quot;position: relative;&quot;，在container中，panel1之上添加了一个h1的标签，panel的三个值变为了 62 104 42，请大大的关注offsetTop这一属性，原先没有h1标签时，它的值是0，可是添加了h1后他的值变为了62，请注意h1的高度只有42，那个20 是从哪来的，唯一的解释是panel1的margin-top是20px，这么一想，脑袋又乱了，margin-top怎么又起作用了？想不通，，，先写到这，等后续补充。]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3实现立体菜单]]></title>
    <url>%2F2016%2F05%2F31%2Fcss-stereo-menu%2F</url>
    <content type="text"><![CDATA[&lt;div class="nav"> &lt;a href="#" class="highlight">Home&lt;/a> &lt;a href="#">About&lt;/a> &lt;a href="#">Servics&lt;/a> &lt;a href="#">Portfolio&lt;/a> &lt;a href="#">Blog&lt;/a> &lt;a href="#">Contact&lt;/a> &lt;/div> ```css { margin:0; padding: 0; font-family: ‘Microsoft Yahei’}a { color: #fff; text-decoration: none;}body { background-color: #222930;}.nav { margin:10%;}.nav a { padding: 15px 20px; margin-left: -4px; border: 1px solid #121212; border-right: none; color: #777; cursor: pointer; font-size: 14px; box-shadow: 0 2px 3px rgba(255,255,255,0.1) inset, 0 1px 0px rgba(255,255,255,0.1) ; }.nav a:first-child { border-radius:6px 0 0 6px;}.nav a:last-child { border-radius: 0 6px 6px 0; border-right: 1px solid #121212;}.nav a.highlight { color: #fff;}]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3中的部分属性]]></title>
    <url>%2F2016%2F05%2F30%2Fcss-any-property%2F</url>
    <content type="text"><![CDATA[box-shadow1、阴影box-shadow:x轴偏移量 y轴偏移量 [阴影模糊半径] [阴影扩展半径] [阴影颜色] [投影方式]注意：inset（内阴影） 可以写在参数的第一个或最后一个，其它位置是无效的实例正值表示在对象的底部，负值表示在对象的顶部。 .boxshadow-outset{ width:100px;height:100px; box-shadow:4px 4px 6px blue,4px 4px 6px red inset; } .boxshadow-inset{ width:100px; height:100px; box-shadow:4px 4px 6px #666 inset; } 阴影模糊半径与阴影扩展半径的区别阴影模糊半径：此参数可选，其值只能是为正值，如果其值为0时，表示阴影不具有模糊效果，其值越大阴影的边缘就越模糊；阴影扩展半径：此参数可选，其值可以是正负值，如果值为正，则整个阴影都延展扩大，反之值为负值时，则缩小； X轴偏移量和Y轴偏移量值可以设置为负数1、为边框应用图片 border-image 顾名思义就是为边框应用背景图片，它和我们常用的background属性比较相似 background:url(xx.jpg) 10px 20px no-repeat; 另有属性round、stretch。 用法：border-image:url(borderimg.png) 70 stretch 2、颜色之RGBA：在RGB的基础上增加了控制alpha透明度的参数 语法color：rgba(R,G,B,A) 3、渐变色彩 CSS3 Gradient 分为线性渐变(linear)和径向渐变(radial) background-image:linear-gradient(to left, red, orange,yellow,green,blue,indigo,violet); 4、text-overflow 与 word-wrap text-overflow用来设置是否使用一个省略标记（…）标示对象内文本的溢出 属性clip（表示剪切）和ellipsis（表示显示省略标记） 但是text-overflow只是用来说明文字溢出时用什么方式显示，要实现溢出时 产生省略号的效果，还须定义强制文本在一行内显示（white-space:nowrap） 及溢出内容为隐藏（overflow:hidden），只有这样才能实现溢出文本显示省 略号的效果，代码如下：text-overflow:ellipsis;overflow:hidden;white-space:nowrap;同时，word-wrap也可以用来设置文本行为，当前行超过指定容器的边界时是否断开转行。属性：normal（表示控制连续文本换行）和break-word（表示内容将在边界内换行） 6、嵌入字体@font-face@font-face能够加载服务器端的字体文件，让浏览器端可以显示用户电脑里没有安装的字体。@font-face { font-family : 字体名称; src : 字体文件在服务器上的相对或绝对路径;} 7、文本阴影text-shadow可以设置文本的阴影效果 text-shadow: X-Offset Y-Offset（阴影的垂直偏移距离） blur（模糊程度） color（阴影的颜色）; 8、background-origin设置元素背景图片的原始起始位置。 background-origin ： border-box | padding-box | content-box; 参数分别表示背景图片是从边框，还是内边距（默认值），或者是内容区域开 始显示。需要注意的是，如果背景不是no-repeat，这个属性无效，它会从边框开始显示。 9、background-clip用来将背景图片做适当的裁剪以适应实际需要。 background-clip ： border-box | padding-box | content-box | no-clip 参数分别表示从边框、或内填充，或者内容区域向外裁剪背景。no-clip表示不裁切，和参数border-box显示同样的效果。backgroud-clip默认值为border-box。 10、background-size设置背景图片的大小，以长度值或百分比显示，还可以通过cover和contain来对图片进行伸缩。 background-size: auto | &lt;长度值&gt; | &lt;百分比&gt; | cover | contain1、auto：默认值，不改变背景图片的原始高度和宽度；2、&lt;长度值&gt;：成对出现如200px 50px，将背景图片宽高依次设置为前面两个值，当设置一个值时，将其作为图片宽度值来等比缩放；3、&lt;百分比&gt;：0％~100％之间的任何值，将背景图片宽高依次设置为所在元素宽高乘以前面百分比得出的数值，当设置一个值时同上；4、cover：顾名思义为覆盖，即将背景图片等比缩放以填满整个容器；5、contain：容纳，即将背景图片等比缩放至某一边紧贴容器边缘为止。11、multiple backgrounds多重背景，也就是CSS2里background的属性外加origin、clip和size组成的新background的多次叠加，缩写时为用逗号隔开的每组值；用分解写法时，如果有多个背景图片，而其他属性只有一个（例如background-repeat只有一个），表明所有背景图片应用该属性值。background ： [background-color] | [background-image] | [background-position][/background-size] | [background-repeat] | [background-attachment] | [background-clip] | [background-origin],…12、属性选择器 &lt;a href="xxx.pdf">我链接的是PDF文件&lt;/a> &lt;a href="#" class="icon">我类名是icon&lt;/a> &lt;a href="#" title="我的title是more">我的title是more&lt;/a> a[class^=icon]{ background: green; color:#fff; } a[href$=pdf]{ background: orange; color: #fff; } a[title*=more]{ background: blue; color: #fff; } 13、结构性伪类选择器–root：:root选择器，从字面上我们就可以很清楚的理解是根选择器，他的意思就是匹配元素E所在文档的根元素。在HTML文档中，根元素始终是。“:root”选择器等同于元素，简单点说：:root{background:orange}==html {background:orange;}14、结构性伪类选择器—not:not选择器称为否定选择器，和jQuery中的:not选择器一模一样，可以选择除某个元素之外的所有元素。就拿form元素来说，比如说你想给表单中除submit按钮之外的input元素添加红色边框，CSS代码可以写成： form { width: 200px; margin: 20px auto;} div { margin-bottom: 20px; } input:not([type="submit"]){ border:1px solid red; } 15、结构性伪类选择器—empty:empty选择器表示的就是空。用来选择没有任何内容的元素，这里没有内容指的是一点内容都没有，哪怕是一个空格。比如说，你的文档中有三个段落p元素，你想把没有任何内容的P元素隐藏起来。我们就可以使用“:empty”选择器来控制。 &lt;p>我是一个段落&lt;/p> &lt;p> &lt;/p> &lt;p>&lt;/p> p{ background: orange; min-height: 30px; } p:empty { display: none; } 16、结构性伪类选择器—target:target选择器称为目标选择器，用来匹配文档(页面)的url的某个标志符的目标元素。我们先来上个例子，然后再做分析。示例展示点击链接显示隐藏的段落。 &lt;h2>&lt;a href="#brand">Brand&lt;/a>&lt;/h2> &lt;div class="menuSection" id="brand"> content for Brand &lt;/div> .menuSection{ display: none; } :target{/*这里的:target就是指id="brand"的div对象*/ display:block; } 17、结构性伪类选择器—first-child“:first-child”选择器表示的是选择父元素的第一个子元素的元素E。简单点理解就是选择元素中的第一个子元素，记住是子元素，而不是后代元素。 18、结构性伪类选择器—last-child“:last-child”选择器与“:first-child”选择器作用类似，不同的是“:last-child”选择器选择的是元素的最后一个子元素。 19、结构性伪类选择器—nth-child(n)“:nth-child(n)”选择器用来定位某个父元素的一个或多个特定的子元素。其中“n”是其参数，而且可以是整数值(1,2,3,4)，也可以是表达式(2n+1、-n+5)和关键词(odd、even)，但参数n的起始值始终是1，而不是0。也就是说，参数n的值为0时，选择器将选择不到任何匹配的元素。 20、结构性伪类选择器—nth-last-child(n)“:nth-last-child(n)”选择器和前面的“:nth-child(n)”选择器非常的相似，只是这里多了一个“last”，所起的作用和“:nth-child(n)”选择器有所区别，从某父元素的最后一个子元素开始计算，来选择特定的元素。 21、first-of-type选择器“:first-of-type”选择器类似于“:first-child”选择器，不同之处就是指定了元素的类型,其主要用来定位一个父元素下的某个类型的第一个子元素。 22、nth-of-type(n)选择器“:nth-of-type(n)”选择器和“:nth-child(n)”选择器非常类似，不同的是它只计算父元素中指定的某种类型的子元素。当某个元素中的子元素不单单是同一种类型的子元素时，使用“:nth-of-type(n)”选择器来定位于父元素中某种类型的子元素是非常方便和有用的。在“:nth-of-type(n)”选择器中的“n”和“:nth-child(n)”选择器中的“n”参数也一样，可以是具体的整数，也可以是表达式，还可以是关键词n的参数也可以为odd 和 even 是可用于匹��下标是奇数或偶数的子元素的关键词 23、last-of-type选择器“:last-of-type”选择器和“:first-of-type”选择器功能是一样的，不同的是他选择是父元素下的某个类型的最后一个子元素 24、nth-last-of-type(n)选择器“:nth-last-of-type(n)”选择器和“:nth-of-type(n)”选择器是一样的，选择父元素中指定的某种子元素类型，但它的起始方向是从最后一个子元素开始，而且它的使用方法类似于上节中介绍的“:nth-last-child(n)”选择器一样。 25、only-child选择器“:only-child”选择器选择的是父元素中只有一个子元素，而且只有唯一的一个子元素。也就是说，匹配的元素的父元素中仅有一个子元素，而且是一个唯一的子元素。 26、only-of-type选择器“:only-of-type”选择器用来选择一个元素是它的父元素的唯一一个相同类型的子元素。这样说或许不太好理解，换一种说法。“:only-of-type”是表示一个元素他有很多个子元素，而其中只有一种类型的子元素是唯一的，使用“:only-of-type”选择器就可以选中这个元素中的唯一一个类型子元素。 27、:enabled选择器在Web的表单中，有些表单元素有可用（“:enabled”）和不可用（“:disabled”）状态，比如输入框，密码框，复选框等。在默认情况之下，这些表单元素都处在可用状态。那么我们可以通过伪选择器“:enabled”对这些表单元素设置样式。 28、:disabled选择器“:disabled”选择器刚好与“:enabled”选择器相反，用来选择不可用表单元素。要正常使用“:disabled”选择器，需要在表单元素的HTML中设置“disabled”属性。 29、:checked选择器在表单元素中，单选按钮和复选按钮都具有选中和未选中状态。（大家都知道，要覆写这两个按钮默认样式比较困难）。在CSS3中，我们可以通过状态选择器“:checked”配合其他标签实现自定义样式。而“:checked”表示的是选中状态。 30、::selection选择器“::selection”伪元素是用来匹配突出显示的文本(用鼠标选择文本时的文本)。浏览器默认情况下，用鼠标选择网页文本是以“深蓝的背景，白色的字体”显示的，效果如下图所示： 31、:read-only选择器“:read-only”伪类选择器用来指定处于只读状态元素的样式。简单点理解就是，元素中设置了“readonly=’readonly’ 32、:read-write选择器“:read-write”选择器刚好与“:read-only”选择器相反，主要用来指定当元素处于非只读状态时的样式。 33、::before和::after::before和::after这两个主要用来给元素的前面或后面插入内容，这两个常和”content”配合使用，使用的场景最多的就是清除浮动。 34、变形–旋转 rotate()旋转rotate()函数通过指定的角度参数使元素相对原点进行旋转。它主要在二维空间内进行操作，设置一个角度值，用来指定旋转的幅度。如果这个值为正值，元素相对原点中心顺时针旋转；如果这个值为负值，元素相对原点中心逆时针旋转 35、变形–旋转 rotate()旋转rotate()函数通过指定的角度参数使元素相对原点进行旋转。它主要在二维空间内进行操作，设置一个角度值，用来指定旋转的幅度。如果这个值为正值，元素相对原点中心顺时针旋转；如果这个值为负值，元素相对原点中心逆时针旋转。 36、变形–扭曲 skew()扭曲skew()函数能够让元素倾斜显示。它可以将一个对象以其中心位置围绕着X轴和Y轴按照一定的角度倾斜。这与rotate()函数的旋转不同，rotate()函数只是旋转，而不会改变元素的形状。skew()函数不会旋转，而只会改变元素的形状。1、skew(x,y)使元素在水平和垂直方向同时扭曲2、skewX(x)仅使元素在水平方向扭曲变形（X轴扭曲变形）3、skewY(y)仅使元素在垂直方向扭曲变形（Y轴扭曲变形） 37、变形–缩放 scale()缩放 scale()函数 让元素根据中心原点对对象进行缩放1、 scale(X,Y)使元素水平方向和垂直方向同时缩放。若只有一个参数，则xy同时缩放2、scaleX(x)元素仅水平方向缩放（X轴缩放）3、scaleY(y)元素仅垂直方向缩放（Y轴缩放） 38、变形–位移 translate()translate()函数可以将元素向指定的方向移动，类似于position中的relative。或以简单的理解为，使用translate()函数，可以把元素从原来的位置移动，而不影响在X、Y轴上的任何Web组件。1、translate(x,y)水平方向和垂直方向同时移动2、translateX(x)仅水平方向移动（X轴移动）3、translateY(Y)仅垂直方向移动（Y轴移动） 39、变形–矩阵 matrix()matrix() 是一个含六个值的(a,b,c,d,e,f)变换矩阵，用来指定一个2D变换，相当于直接应用一个[a b c d e f]变换矩阵。就是基于水平方向（X轴）和垂直方向（Y轴）重新定位元素,此属性值使用涉及到数学中的矩阵，我在这里只是简单的说一下CSS3中的transform有这么一个属性值，如果需要深入了解，需要对数学矩阵有一定的知识。 40、变形–原点 transform-origin在没有重置transform-origin改变元素原点位置的情况下，CSS变形进行的旋转、位移、缩放，扭曲等操作都是以元素自己中心位置进行变形。但很多时候，我们可以通过transform-origin来对元素进行原点位置改变，使元素原点不在元素的中心位置，以达到需要的原点位置。对于x轴的调整：left|center|right对于y轴的调整：top|center|bottom对于z轴的调整：length px 41、动画–过渡属性 transition-property早期在Web中要实现动画效果，都是依赖于JavaScript或Flash来完成。但在CSS3中新增加了一个新的模块transition，它可以通过一些简单的CSS事件来触发元素的外观变化，让效果显得更加细腻。简单点说，就是通过鼠标的单击、获得焦点，被点击或对元素任何改变中触发，并平滑地以动画效果改变CSS的属性值。在CSS中创建简单的过渡效果可以从以下几个步骤来实现：第一，在默认样式中声明元素的初始状态样式；第二，声明过渡元素最终状态样式，比如悬浮状态；第三，在默认样式中通过添加过渡函数，添加一些不同的样式。CSS3的过度transition:属性名称|过渡所用时间|过渡模式:，主要包括以下几个子属性：transition-property:none/all/某一属性名称指定过渡或动态模拟的CSS属性transition-duration:指定完成过渡所需的时间transition-duration属性主要用来设置一个属性过渡到另一个属性所需的时间，也就是从旧属性过渡到新属性花费的时间长度，俗称持续时间。transition-timing-function:指定过渡函数，transition-timing-function：ease(缓慢开始，缓慢结束)|linear(匀速)|ease-in(缓慢开始)|ease-out(缓慢结束)|ease-in-out(缓慢开始，缓慢结束)。默认easetransition-delay:指定开始出现的延迟时间，transition-delay属性和transition-duration属性极其类似，不同的是transition-duration是用来设置过渡动画的持续时间，而transition-delay主要用来指定一个动画开始执行的时间，也就是说当改变元素属性值后多长时间开始执行。有时我们想改变两个或者多个css属性的transition效果时，只要把几个transition的声明串在一起，用逗号（“，”）隔开，然后各自可以有各自不同的延续时间和其时间的速率变换方式。但需要值得注意的一点：第一个时间的值为 transition-duration，第二个为transition-delay。 42、Keyframes介绍Keyframes被称为关键帧，其类似于Flash中的关键帧。在CSS3中其主要以“@keyframes”开头，后面紧跟着是动画名称加上一对花括号“{…}”，括号中就是一些不同时间段样式规则。@keyframes changecolor{ 0%{ background: red; } 100%{ background: green; }}在一个“@keyframes”中的样式规则可以由多个百分比构成的，如在“0%”到“100%”之间创建更多个百分比，分别给每个百分比中给需要有动画效果的元素加上不同的样式，从而达到一种在不断变化的效果。经验与技巧：在@keyframes中定义动画名称时，其中0%和100%还可以使用关键词from和to来代表，其中0%对应的是from，100%对应的是to。aniamtion:name|duration|timing-function|delay|iteration-count|direction|play-state|fill-mode 43、调用动画animation-name属性主要是用来调用 @keyframes 定义好的动画。需要特别注意: animation-name 调用的动画名需要和“@keyframes”定义的动画名称完全一致（区分大小写），如果不一致将不具有任何动画效果。语法：animation-name: none | IDENT[,none|DENT]*; 44、设置动画播放时间animation-duration主要用来设置CSS3动画播放时间，其使用方法和transition-duration类似，是用来指定元素播放动画所持续的时间长，也就是完成从0%到100%一次动画所需时间。单位：S秒语法规则animation-duration: [,]*取值为数值，单位为秒，其默认值为“0”，这意味着动画周期为“0”，也就是没有动画效果（如果值为负值会被视为“0”）。 45、设置动画播放方式animation-timing-function属性主要用来设置动画播放方式。主要让元素根据时间的推进来改变属性值的变换速率，简单点说就是动画的播放方式。语法规则：animation-timing-function:ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(, , , ) [, ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(, , , )]*它和transition中的transition-timing-function一样，具有以下几种变换方式：ease,ease-in,ease-in-out,ease-out,linear和cubic-bezier。对应功如下： 46、设置动画开始播放的时间animation-delay属性用来定义动画开始播放的时间，用来触发动画播放的时间点。和transition-delay属性一样，用于定义在浏览器开始执行动画之前等待的时间。语法规则：animation-delay:[,]* 47、设置动画播放次数animation-iteration-count属性主要用来定义动画的播放次数。语法规则：animation-iteration-count: infinite | [, infinite | ]*1、其值通常为整数，但也可以使用带有小数的数字，其默认值为1，这意味着动画将从开始到结束只播放一次。2、如果取值为infinite，动画将会无限次的播放注意：Chrome或Safari浏览器，需要加入-webkit-前缀！ 48、设置动画播放方向（需加前缀）animation-direction属性主要用来设置动画播放方向，其语法规则如下：animation-direction:normal | alternate [, normal | alternate]*其主要有两个值：normal、alternate1、normal是默认值，如果设置为normal时，动画的每次循环都是向前播放；2、另一个值是alternate，他的作用是，动画播放在第偶数次向前播放，第奇数次向反方向播放。 49、设置动画的播放状态animation-play-state属性主要用来控制元素动画的播放状态。参数：其主要有两个值：running和paused。其中running是其默认值，主要作用就是类似于音乐播放器一样，可以通过paused将正在播放的动画停下来，也可以通过running将暂停的动画重新播放，这里的重新播放不一定是从元素动画的开始播放，而是从暂停的那个位置开始播放。另外如果暂停了动画的播放，元素的样式将回到最原始设置状态。 50、设置动画时间外属性animation-fill-mode属性定义在动画开始之前和结束之后发生的操作。主要具有四个属性值：none、forwards、backwords和both。其四个属性值对应效果如下：none：默认值，表示动画将按预期进行和结束，在动画完成其最后一帧时，动画会反转到初始帧forwards：表示动画在结束后继续应用最后的关键帧的位置backwards：会在向元素应用动画样式时迅速应用动画的初始帧both：元素动画同时具有forwards和backwards效果在默认情况之下，动画不会影响它的关键帧之外的属性，使用animation-fill-mode属性可以修改动画的默认行为。简单的说就是告诉动画在第一关键帧上等待动画开始，或者在动画结束时停在最后一个关键帧上而不回到动画的第一帧上。或者同时具有这两个效果。 51、多列布局——Columns为了能在Web页面中方便实现类似报纸、杂志那种多列排版的布局，W3C特意给CSS3增加了一个多列布局模块（CSS Multi Column Layout Module）。它主要应用在文本的多列布局方面，这种布局在报纸和杂志上都使用了几十年了，但要在Web页面上实现这样的效果还是有相当大的难度，庆幸的是，CSS3的多列布局可以轻松实现。接下来咱们一起学习多列布局相关的知识。语法：columns： || 52、多列布局——column-widthcolumn-width的使用和CSS中的width属性一样，不过不同的是，column-width属性在定义元素列宽的时候，既可以单独使用，也可以和多列属性中其他属性配合使用。其基本语法如下所示：column-width: auto | 53、多列布局——column-countcolumn-count属性主要用来给元素指定想要的列数和允许的最大列数。其语法规则：column-count：auto | 54、列间距column-gapcolumn-gap主要用来设置列与列之间的间距，其语法规则如下：column-gap: normal || 注意：normal默认值为1em，如果你的字号是px，则默认值为字体的大小 55、列表边框column-rulecolumn-rule主要是用来定义列与列之间的边框宽度、边框样式和边框颜色。简单点说，就有点类似于常用的border属性。但column-rule是不占用任何空间位置的，在列与列之间改变其宽度不会改变任何列的位置。语法规则：column-rule:||三个属性类似于border的属性 56、跨列设置column-spancolumn-span主要用来定义一个分列元素中的子元素能跨列多少。column-width、column-count等属性能让一元素分成多列，不管里面元素如何排放顺序，他们都是从左向右的放置内容，但有时我们需要基中一段内容或一个标题不进行分列，也就是横跨所有列，此时column-span就可以轻松实现，此属性的语法如下��column-span: none | all 注意：none为默认值，表示不跨越任何列，all表示跨越所有列 57、盒模型在CSS3中新增加了box-sizing属性，能够事先定义盒模型的尺寸解析方式，其语法规则如下：box-sizing: content-box | border-box | inheritcontent-box：默认值，其让元素维持W3C的标准盒模型，也就是说元素的宽度和高度（width/height）等于元素边框宽度（border）加上元素内距（padding）加上元素内容宽度或高度（content width/ height），也就是element width/height = border + padding + content width / heightborder-box：重新定义CSS2.1中盒模型组成的模式，让元素维持IE传统的盒模型（IE6以下版本和IE6-7怪异模式），也就是说元素的宽度或高度等于元素内容的宽度或高度。从上面盒模型介绍可知，这里的内容宽度或高度包含了元素的border、padding、内容的宽度或高度（此处的内容宽度或高度＝盒子的宽度或高度—边框—内距）。inherit：使元素继承父元素的盒模型模式 58、伸缩布局（一）CSS3引入了一种新的布局模式——Flexbox布局，即伸缩布局盒模型（Flexible Box），用来提供一个更加有效的方式制定、调整和分布一个容器里项目布局，即使它们的大小是未知或者动态的，这里简称为Flex。Flexbox布局常用于设计比较复杂的页面，可以轻松的实现屏幕和浏览器窗口大小发生变化时保持元素的相对位置和大小不变，同时减少了依赖于浮动布局实现元素位置的定义以及重置元素的大小。Flexbox布局在定义伸缩项目大小时伸缩容器会预留一些可用空间，让你可以调节伸缩项目的相对大小和位置。例如，你可以确保伸缩容器中的多余空间平均分配多个伸缩项目，当然，如果你的伸缩容器没有足够大的空间放置伸缩项目时，浏览器会根据一定的比例减少伸缩项目的大小，使其不溢出伸缩容器。综合而言，Flexbox布局功能主要具有以下几点：第一，屏幕和浏览器窗口大小发生改变也可以灵活调整布局；第二，可以指定伸缩项目沿着主轴或侧轴按比例分配额外空间（伸缩容器额外空间），从而调整伸缩项目的大小；第三，可以指定伸缩项目沿着主轴或侧轴将伸缩容器额外空间，分配到伸缩项目之前、之后或之间；第四，可以指定如何将垂直于元素布局轴的额外空间分布到该元素的周围；第五，可以控制元素在页面上的布局方向；第六，可以按照不同于文档对象模型（DOM）所指定排序方式对屏幕上的元素重新排序。也就是说可以在浏览器渲染中不按照文档流先后顺序重排伸缩项目顺序。Flexbox规范版本众多，浏览器对此语法支持度也各有不同，接下来的内容以最新语法版本为例向大家展1.创建一个flex容器任何一个flexbox布局的第一步是需要创建一个flex容器。为此给元素设置display属性的值为flex。在Safari浏览器中，你依然需要添加前缀-webkit，.flexcontainer{ display: -webkit-flex; display: flex; }2.Flex项目显示Flex项目是Flex容器的子元素。他们沿着主要轴和横轴定位。默认的是沿着水平轴排列一行。你可以通过flex-direction来改变主轴方向修改为column，其默认值是row。4.Flex项目移动到顶部如何将flex项目移动到顶部，取决于主轴的方向。如果它是垂直的方向通过align-items设置；如果它是水平的方向通过justify-content设置。5.Flex项目移到左边flex项目称动到左边或右边也取决于主轴的方向。如果flex-direction设置为row，设置justify-content控制方向；如果设置为column，设置align-items控制方向。-webkit-align-items: flex-start/flex-end/center;8.Flex项目实现自动伸缩您可以定义一个flex项目，如何相对于flex容器实现自动的伸缩。需要给每个flex项目设置flex属性设置需要伸缩的值。.bigitem{ -webkit-flex:200; flex:200; } .smallitem{ -webkit-flex:100; flex:100; } 59、Media Queries——媒体类型（一）随着科学技术不断的向前发展，网页的浏览终端越来越多样化，用户可以通过：宽屏电视、台式电脑、笔记本电脑、平板电脑和智能手机来访问你的网站。尽管你无法保证一个网站在不同屏幕尺寸和不同设备上看起来完全一模一样，但至少要让你的Web页面能适配用户的终端，让他更好的呈现在你的用户面前。在本节中，将会学到如何使用CSS3中的Media Queries模块来让一个页面适应不同的终端（或屏幕尺寸），从而让你的页面让用户有一个更好的体验。一、媒体类型媒体类型（Media Type）在CSS2中是一个常见的属性，也是一个非常有用的属性，可以通过媒体类型对不同的设备指定不同的样式。见图片见素材/图片 60、responsive布局技巧方法。你首先禁掉你页面中所有的样式（以及与样式相关的信息），在浏览器中打开，如果你的内容排列有序，方便阅读，那么你的这个结构不会差到哪里去。 61、自由缩放属性resizeresize属性主要是用来改变元素尺寸大小的，其主要目的是增强用户体验。但使用方法却是极其的简单，先从其语法入手。resize: none | both | horizontal | vertical | inheritnone用户不能拖动元素尺寸大小，both用户可以拖动元素，同时可以修改元素的宽度和高度，horizontal用户可以拖放元素，仅可以修改元素的宽度，但不能修改元素的高度，vertical用户可以拖放元素，尽可以修改元素的高度，但不能修改元素的宽度，inherit继承父元素的属性值 62、CSS3外轮廓属性外轮廓outline在页面中呈现的效果和边框border呈现的效果极其相似，但和元素边框border完全不同，外轮廓线不占用网页布局空间，不一定是矩形，外轮廓是属于一种动态样式，只有元素获取到焦点或者被激活时呈现。outline属性早在CSS2中就出现了，主要是用来在元素周围绘制一条轮廓线，可以起到突出元素的作用。但是并未得到各主流浏览器的广泛支持，在CSS3中对outline作了一定的扩展，在以前的基础上增加新特性。outline属性的基本语法如下：outline: ［outline-color］ || [outline-style] || [outline-width] || [outline-offset] || inherit从语法中可以看出outline和border边框属性的使用方法极其类似。outline-color相当于border-color、outline-style相当于border-style，而outline-width相当于border-width，只不过CSS3给outline属性增加了一个outline-offset属性outline-color：定义轮廓线的颜色，属性值为CSS中定义的颜色值。在实际应用中，可以将此参数省略，省略时此参数的默认值为黑色。outline-style：定义轮廓线的样式，属性为CSS中定义线的样式。在实际应用中，可以将此参数省略，省略时此参数的默认值为none，省略后不对该轮廓线进行任何绘制。outline-width：定义轮廓线的宽度，属性值可以为一个宽度值。在实际应用中，可以将此参数省略，省略时此参数的默认值为medium，表示绘制中等宽度的轮廓线。outline-offset：定义轮廓边框的偏移位置的数值，此值可以取负数值。当此参数的值为正数值，表示轮廓边框向外偏离多少个像素；当此参数的值为负数值，表示轮廓边框向内偏移多少个像素。inherit：元素继承父元素的outline效果。 63、CSS生成内容在Web中插入内容，在CSS2.1时代依靠的是JavaScript来实现。但进入CSS3进代之后我们可以通过CSS3的伪类“:before”，“:after”和CSS3的伪元素“::before”、“::after”来实现，其关键是依靠CSS3中的“content”属性来实现。不过这个属性对于img和input元素不起作用。content配合CSS的伪类或者伪元素，一般可以做以下四件事情：none：不生成任何内容attr：插入标签属性值url：使用指定的绝对或相对地址插入一个外部资源（图像，声频，视频或浏览器支持的其他任何资源）string：插入字符串在CSS中有一种清除浮动的方法叫“clearfix” 64、CSS3 perspective 属性定义3D元素距视图的距离，以像素计。该属性允许你改变3D元素查看3D元素的试图，当为元素定义perspective属性是，其子元素会获得透视效果，而不是元素本身。注释：perspective 属性只影响 3D 转换元素。perspective: number|none; 65、CSS3 transform-style 属性transform-style 属性规定如何在 3D 空间中呈现被嵌套的元素。注释：该属性必须与 transform 属性一同使用。transform-style: flat|preserve-3d;flat子元素将不保留3D位置，preserve-3d子元素将保留其3D位置 66、CSS3 transform 属性transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜translate系列单位是px， rotate系列单位是deg;translate和rotate顺序不同，效果也会不同transform-origin属性定义变形的原点，默认是文件的中心。可以使用这个属性来改变变形的原点。 67、CSS vertical-align 属性vertical-align 属性设置元素的垂直对齐方式。 68、CSS strong 属性用于强调，和标签一样，用于强调文本，但它强调的程度更强一下。通常使用加粗的字体来显示其中的内容 69、CSS display 属性display属性规定元素应该生成的框的类型。这个属性用于定义建立布局时元素生成的显示框类型。对于 HTML 等文档类型，如果使用 display 不谨慎会很危险，因为可能违反 HTML 中已经定义的显示层次结构。对于 XML，由于 XML 没有内置的这种层次结构，所有 display 是绝对必要的。70、CSS 属性cursor:指示鼠标到达元素时的鼠标形态71、font-smoothing属性css3种用于设置字体的抗锯齿或者光滑度的属性语法规则：font-smoothing:subpixel-antialiased(浏览器默认)|none(小像素文本)|antialiased(反锯齿)72、如何隐藏一个元素，使其不可见display:none;position:absolute;left:-999999px;visibility:hidden;opacity:0opacity设置div元素的不透明级别。opacity: value(0.0完全透明-1.0完全不透明)|inherit(父类继承);73、backface-visibility:定义当元素不面向屏幕是是否可见backface-visibility:visible(背面是可见的)|hidden(背面是不可见的);74、@font-face是css中的一个模块，主要用于将自己定义的web字体嵌入网页中@font-face { font-family: ; src: [][, []]*; [font-weight: ]; [font-style: ]; }取值说明1、YourWebFontName:此值指的就是你自定义的字体名称，最好是使用你下载的默认字体，他将被引用到你的Web元素中的font-family。如“font-family:”YourWebFontName”;”2、source:此值指的是你自定义的字体的存放路径，可以是相对路径也可以是绝路径；3、format：此值指的是你自定义的字体的格式，主要用来帮助浏览器识别，其值主要有以下几种类型：truetype,opentype,truetype-aat,embedded-opentype,avg等；4、weight和style:这两个值大家一定很熟悉，weight定义字体是否为粗体，style主要定义字体样式，如斜体。css shake: 具体样式： 75、box-sizing属性允许您以特定的方式定义匹配某个区域的特定元素。box-sizing: content-box|border-box|inherit;content-box:这是由 CSS2.1 规定的宽度高度行为。宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。border-box:为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。inherit 规定应从父元素继承 box-sizing 属性的值。]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime 使用的快捷键以及小技巧]]></title>
    <url>%2F2016%2F05%2F30%2Fsublime-hot-key%2F</url>
    <content type="text"><![CDATA[Ctrl+D 选词 （反复按快捷键，即可继续向下同时选中下一个相同的文本进行同时编辑）Ctrl+G 跳转到相应的行Ctrl+J 合并行（已选择需要合并的多行时）Ctrl+L 选择整行（按住-继续选择下行）Ctrl+M 光标移动至括号内开始或结束的位置Ctrl+T 词互换Ctrl+U 软撤销Ctrl+P 查找当前项目中的文件和快速搜索；输入 @ 查找文件主标题/函数；或者输入 : 跳转到文件某行；Ctrl+R 快速列出/跳转到某个函数Ctrl+K Backspace 从光标处删除至行首Ctrl+K+B 开启/关闭侧边栏Ctrl+KK 从光标处删除至行尾Ctrl+K+T 折叠属性Ctrl+K+U 改为大写Ctrl+K+L 改为小写Ctrl+K+0 展开所有Ctrl+Enter 插入行后（快速换行）Ctrl+Tab 当前窗口中的标签页切换Ctrl+Shift+A 选择光标位置父标签对儿Ctrl+Shift+D 复制光标所在整行，插入在该行之前ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找Ctrl+Shift+K 删除整行Ctrl+Shift+L 鼠标选中多行（按下快捷键），即可同时编辑这些行Ctrl+Shift+M 选择括号内的内容（按住-继续选择父括号）Ctrl+Shift+P 打开命令面板Ctrl+Shift+/ 注释已选择内容Ctrl+Shift+↑可以移动此行代码，与上行互换Ctrl+Shift+↓可以移动此行代码，与下行互换Ctrl+Shift+[ 折叠代码Ctrl+Shift+] 展开代码Ctrl+Shift+Enter 光标前插入行Ctrl+PageDown 、Ctrl+PageUp 文件按开启的前后顺序切换Ctrl+Z 撤销Ctrl+Y 恢复撤销Ctrl+F2 设置/取消书签Ctrl+/ 注释整行（如已选择内容，同“Ctrl+Shift+/”效果）Ctrl+鼠标左键 可以同时选择要编辑的多处文本Shift+鼠标右键（或使用鼠标中键）可以用鼠标进行竖向多行选择Shift+F2 上一个书签Shift+Tab 去除缩进Alt+Shift+1（非小键盘）窗口分屏，恢复默认1屏Alt+Shift+2 左右分屏-2列Alt+Shift+3 左右分屏-3列Alt+Shift+4 左右分屏-4列Alt+Shift+5 等分4屏Alt+Shift+8 垂直分屏-2屏Alt+Shift+9 垂直分屏-3屏Ctrl+Shift+分屏序号 将当前焦点页分配到分屏序号页Alt+. 闭合当前标签Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑Tab 缩进 自动完成F2 下一个书签F6 检测语法错误F9 行排序(按a-z)F11 全屏模式 在更换主题的时候，你会发现没有更换完全。单单更改theme不行，必须在preference &gt;Settings - User 中添加以下代码：例如，我安装的是Piatto主题，所以添加”theme”: “Piatto Light.sublime-theme”，保存后，你会发现整个界面就改变了。]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOMReady的实现]]></title>
    <url>%2F2016%2F05%2F29%2Fdom-ready%2F</url>
    <content type="text"><![CDATA[function myReady(fn) { // 对于现代浏览器，对DOMContentLoaded事件的处理采用标准的事件绑定方式 if (document.addEventListener) { //通过能力检测区分 document.addEventListener("DOMContentLoaded", fn, false); } else { IEContentLoaded(fn); } // IE模拟DOMContentLoaded function IEContentLoaded(fn) { var d = window.document; var done = false; // 只执行一次用户的回调函数init() var init = function() { if (!done) { done = true; fn(); } }; (function() { try { // DOM树未创建完之前调用doScroll会抛出错误 d.documentElement.doScroll('left'); } catch (e) { // 延迟在试一次 setTimeout(arguments.callee, 50); return; } // 没有错误就表示DOM树创建完毕，然后立马执行用户回调 init(); })(); // 监听docuemnt的加载状态 d.onreadystatechange = function() { // 如果用户是在domReady之后绑定的函数，就立马执行 if (d.readyState == 'complete') { d.onreadystatechange = null; init(); } } } }]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodeName - nodeValue]]></title>
    <url>%2F2016%2F05%2F29%2FnodeName%20-%20nodeValue%2F</url>
    <content type="text"><![CDATA[html 这是一个元素节点 jsvar container = document.getElementById(‘container’)console.log(container.nodeName + “/“ +container.nodeValue)var attrNode = container.attributes[0]console.log(attrNode.nodeName + “” +attrNode.nodeValue)var textNode = container.childNodes[0]console.log(textNode.nodeName + “” +textNode.nodeValue)var commentNode = document.body.childNodes[1]console.log(commentNode.nodeName + “” +commentNode.nodeValue)console.log(document.doctype.nodeName + “” +document.doctype.nodeValue) var frag = document.createDocumentFragment()console.log(frag.nodeName + “” +frag.nodeValue)]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[document的createDocumentFragment()方法]]></title>
    <url>%2F2016%2F05%2F29%2FcreateDocumentFragment%2F</url>
    <content type="text"><![CDATA[假如你想动态的向html中添加十个段落，使用常规的方式可能会写出这样的代码： for(var i = 0 ; i &lt; 10; i ++) { var p = document.createElement("p"); var oTxt = document.createTextNode("段落" + i); p.appendChild(oTxt); document.body.appendChild(p); } 当然，这段代码运行是没有问题，但是它调用了十次document.body.appendChild()，每次都要产生一次页面渲染。这时碎片就十分有用了： var oFragment = document.createDocumentFragment(); for(var i = 0 ; i &lt; 10; i ++) { var p = document.createElement("p"); var oTxt = document.createTextNode("段落" + i); p.appendChild(oTxt); oFragment.appendChild(p); } document.body.appendChild(oFragment); 在这段代码中，每个新的元素都被添加到文档碎片中，然后这个碎片被作为参数传递给appendChild()。这里对appendChild()的调用实际上并不是把文档碎片本省追加到body元素中，而是仅仅追加碎片中的子节点，然后可以看到明显的性能提升，document.body.appenChild()一次替代十次，这意味着只需要进行一个内容渲染刷新]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中的立即执行函数]]></title>
    <url>%2F2016%2F05%2F29%2Fjs-execute-function-immediately%2F</url>
    <content type="text"><![CDATA[(function(){…} )()和(function (){…} ())是两种javascript立即执行函数的常见写法 函数声明：function fnName (){…};使用function关键字声明一个函数，再指定一个函数名，叫函数声明。 函数表达式 var fnName = function () {…};使用function关键字声明一个函数，但未给函数命名，最后将匿名函数赋予一个变量，叫函数表达式，这是最常见的函数表达式语法形式。 匿名函数：function () {}; 使用function关键字声明一个函数，但未给函数命名，所以叫匿名函数，匿名函数属于函数表达式，匿名函数有很多作用，赋予一个变量则创建函数，赋予一个事件则成为事件处理程序或创建闭包等等。 函数声明和函数表达式不同之处在于，一、Javascript引擎在解析javascript代码时会‘函数声明提升’（Function declaration Hoisting）当前执行环境（作用域）上的函数声明，而函数表达式必须等到Javascirtp引擎执行到它所在行时，才会从上而下一行一行地解析函数表达式，二、函数表达式后面可以加括号立即调用该函数，函数声明不可以，只能以具体形式调用 。 使用这种方法的好处： javascript中没用私有作用域的概念，如果在多人开发的项目上，你在全局或局部作用域中声明了一些变量，可能会被其他人不小心用同名的变量给覆盖掉，根据javascript函数作用域链的特性，可以使用这种技术可以模仿一个私有作用域，用匿名函数作为一个“容器”，“容器”内部可以访问外部的变量，而外部环境不能访问“容器”内部的变量，所以( function(){…} )()内部定义的变量不会和外部的变量发生冲突，俗称“匿名包裹器”或“命名空间”。]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs抓取网页的源码，并保存到本地文件]]></title>
    <url>%2F2016%2F05%2F29%2Fnode-fecth-html%2F</url>
    <content type="text"><![CDATA[var http = require('http') var fs = require('fs'); // 要抓取的网页地址 var url = 'http://www.imooc.com/learn/348' http.get(url, function(res) { var html = '' res.on('data', function(data) { html += data; }) res.on('end', function() { // 将抓取的内容保存到本地文件中 fs.writeFile('index.html', html, function(err) { if (err) { console.log('出现错误!') } console.log('已输出至index.html中') }) }) }).on('error', function(err) { console.log('错误信息：' + err) }) 2017-07-16 新增：如果想处理抓取的html,可以使用cheerio模块，进行过滤，使用起来和jq类似，示例代码： let $ = cheerio.load(html) let movieList = $('.grid_view li')]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoDb的基本使用]]></title>
    <url>%2F2016%2F05%2F28%2Fmongodb%2F</url>
    <content type="text"><![CDATA[MongoDB基本使用 成功启动MongoDB后，再打开一个命令行窗口输入mongo，就可以进行数据库的一些操作。输入help可以看到基本操作命令：show dbs:显示数据库列表show collections：显示当前数据库中的集合（类似关系数据库中的表）show users：显示用户use ：切换当前数据库，这和MS-SQL里面的意思一样db.help()：显示数据库操作命令，里面有很多的命令db.foo.help()：显示集合操作命令，同样有很多的命令，foo指的是当前数据库下，一个叫foo的集合，并非真正意义上的命令db.foo.find()：对于当前数据库中的foo集合进行数据查找（由于没有条件，会列出所有数据）db.foo.find( { a : 1 } )：对于当前数据库中的foo集合进行查找，条件是数据中有一个属性叫a，且a的值为1MongoDB没有创建数据库的命令，但有类似的命令。如：如果你想创建一个“myTest”的数据库，先运行use myTest命令，之后就做一些操作（如：db.createCollection(‘user’)）,这样就可以创建一个名叫“myTest”的数据库。数据库常用命令1、Help查看命令提示 help db.help(); db.yourColl.help(); db.youColl.find().help(); rs.help();2、切换/创建数据库 use yourDB; 当创建一个集合(table)的时候会自动创建当前数据库3、查询所有数据库 show dbs;4、删除当前使用数据库 db.dropDatabase();5、从指定主机上克隆数据库 db.cloneDatabase(“127.0.0.1”); 将指定机器上的数据库的数据克隆到当前数据库6、从指定的机器上复制指定数据库数据到某个数据库 db.copyDatabase(“mydb”, “temp”, “127.0.0.1”);将本机的mydb的数据复制到temp数据库中7、修复当前数据库 db.repairDatabase();8、查看当前使用的数据库 db.getName(); db; db和getName方法是一样的效果，都可以查询当前使用的数据库9、显示当前db状态 db.stats();10、当前db版本 db.version();11、查看当前db的链接机器地址 db.getMongo();Collection聚集集合1、创建一个聚集集合（table） db.createCollection(“collName”, {size: 20, capped: 5, max: 100});2、得到指定名称的聚集集合（table） db.getCollection(“account”);3、得到当前db的所有聚集集合 db.getCollectionNames();4、显示当前db所有聚集索引的状态 db.printCollectionStats(); 用户相关1、添加一个用户 db.addUser(“name”); db.addUser(“userName”, “pwd123”, true); 添加用户、设置密码、是否只读2、数据库认证、安全模式 db.auth(“userName”, “123123”);3、显示当前所有用户 show users;4、删除用户 db.removeUser(“userName”);其他1、查询之前的错误信息 db.getPrevError();2、清除错误记录 db.resetError(); 查看聚集集合基本信息 1、查看帮助 db.yourColl.help();2、查询当前集合的数据条数 db.yourColl.count();3、查看数据空间大小 db.userInfo.dataSize();4、得到当前聚集集合所在的db db.userInfo.getDB();5、得到当前聚集的状态 db.userInfo.stats();6、得到聚集集合总大小 db.userInfo.totalSize();7、聚集集合储存空间大小 db.userInfo.storageSize();8、Shard版本信息 db.userInfo.getShardVersion()9、聚集集合重命名 db.userInfo.renameCollection(“users”); 将userInfo重命名为users10、删除当前聚集集合 db.userInfo.drop();聚集集合查询 1、查询所有记录db.userInfo.find();相当于：select* from userInfo;默认每页显示20条记录，当显示不下的情况下，可以用it迭代命令查询下一页数据。注意：键入it命令不能带“；”但是你可以设置每页显示数据的大小，用DBQuery.shellBatchSize= 50;这样每页就显示50条记录了。 2、查询去掉后的当前聚集集合中的某列的重复数据db.userInfo.distinct(“name”);会过滤掉name中的相同数据相当于：select distict name from userInfo; 3、查询age = 22的记录db.userInfo.find({“age”: 22});相当于： select * from userInfo where age = 22; 4、查询age &gt; 22的记录db.userInfo.find({age: {$gt: 22}});相当于：select * from userInfo where age &gt;22; 5、查询age &lt; 22的记录db.userInfo.find({age: {$lt: 22}});相当于：select * from userInfo where age &lt;22; 6、查询age &gt;= 25的记录db.userInfo.find({age: {$gte: 25}});相当于：select * from userInfo where age &gt;= 25; 7、查询age &lt;= 25的记录db.userInfo.find({age: {$lte: 25}}); 8、查询age &gt;= 23 并且 age &lt;= 26db.userInfo.find({age: {$gte: 23, $lte: 26}}); 9、查询name中包含 mongo的数据db.userInfo.find({name: /mongo/});//相当于%%select * from userInfo where name like ‘%mongo%’; 10、查询name中以mongo开头的db.userInfo.find({name: /^mongo/});select * from userInfo where name like ‘mongo%’; 11、查询指定列name、age数据db.userInfo.find({}, {name: 1, age: 1});相当于：select name, age from userInfo;当然name也可以用true或false,当用ture的情况下河name:1效果一样，如果用false就是排除name，显示name以外的列信息。 12、查询指定列name、age数据, age &gt; 25db.userInfo.find({age: {$gt: 25}}, {name: 1, age: 1});相当于：select name, age from userInfo where age &gt;25; 13、按照年龄排序升序：db.userInfo.find().sort({age: 1});降序：db.userInfo.find().sort({age: -1}); 14、查询name = zhangsan, age = 22的数据db.userInfo.find({name: ‘zhangsan’, age: 22});相当于：select * from userInfo where name = ‘zhangsan’ and age = ‘22’; 15、查询前5条数据db.userInfo.find().limit(5);相当于：selecttop 5 * from userInfo; 16、查询10条以后的数据db.userInfo.find().skip(10);相当于：select from userInfo where id not in (selecttop 10 from userInfo); 17、查询在5-10之间的数据db.userInfo.find().limit(10).skip(5);可用于分页，limit是pageSize，skip是第几页*pageSize 18、or与 查询db.userInfo.find({$or: [{age: 22}, {age: 25}]});相当于：select * from userInfo where age = 22 or age = 25; 19、查询第一条数据db.userInfo.findOne();相当于：selecttop 1 * from userInfo;db.userInfo.find().limit(1); 20、查询某个结果集的记录条数db.userInfo.find({age: {$gte: 25}}).count();相当于：select count(*) from userInfo where age &gt;= 20; 21、按照某列进行排序db.userInfo.find({sex: {$exists: true}}).count();相当于：select count(sex) from userInfo; 索引 1、创建索引db.userInfo.ensureIndex({name: 1});db.userInfo.ensureIndex({name: 1, ts: -1}); 2、查询当前聚集集合所有索引db.userInfo.getIndexes(); 3、查看总索引记录大小db.userInfo.totalIndexSize(); 4、读取当前集合的所有index信息db.users.reIndex(); 5、删除指定索引db.users.dropIndex(“name_1”); 6、删除所有索引索引db.users.dropIndexes(); 修改、添加、删除集合数据 1、添加db.users.save({name: ‘zhangsan’, age: 25, sex: true});添加的数据的数据列，没有固定，根据添加的数据为准 2、修改db.users.update({age: 25}, {$set: {name: ‘changeName’}}, false, true);相当于：update users set name = ‘changeName’ where age = 25; db.users.update({name: ‘Lisi’}, {$inc: {age: 50}}, false, true);相当于：update users set age = age + 50 where name = ‘Lisi’; db.users.update({name: ‘Lisi’}, {$inc: {age: 50}, $set: {name: ‘hoho’}}, false, true);相当于：update users set age = age + 50, name = ‘hoho’ where name = ‘Lisi’; 3、删除db.users.remove({age: 132}); 4、查询修改删除db.users.findAndModify({ query: {age: {$gte: 25}}, sort: {age: -1}, update: {$set: {name: ‘a2’}, $inc: {age: 2}}, remove: true}); db.runCommand({ findandmodify : “users”, query: {age: {$gte: 25}}, sort: {age: -1}, update: {$set: {name: ‘a2’}, $inc: {age: 2}}, remove: true});update 或 remove 其中一个是必须的参数; 其他参数可选。语句块操作1、简单Hello Worldprint(“Hello World!”);这种写法调用了print函数，和直接写入”Hello World!”的效果是一样的； 2、将一个对象转换成jsontojson(new Object());tojson(new Object(‘a’)); 3、循环添加数据&gt; for (var i = 0; i &lt; 30; i++) {… db.users.save({name: “u“ + i, age: 22 + i, sex: i % 2});… };这样就循环添加了30条数据，同样也可以省略括号的写法&gt; for (var i = 0; i &lt; 30; i++) db.users.save({name: “u“ + i, age: 22 + i, sex: i % 2});也是可以的，当你用db.users.find()查询的时候，显示多条数据而无法一页显示的情况下，可以用it查看下一页的信息； 4、find 游标查询&gt;var cursor = db.users.find();&gt; while (cursor.hasNext()) { printjson(cursor.next()); }这样就查询所有的users信息，同样可以这样写var cursor = db.users.find();while (cursor.hasNext()) { printjson(cursor.next); }同样可以省略{}号 5、forEach迭代循环db.users.find().forEach(printjson);forEach中必须传递一个函数来处理每条迭代的数据信息 6、将find游标当数组处理var cursor = db.users.find();cursor[4];取得下标索引为4的那条数据既然可以当做数组处理，那么就可以获得它的长度：cursor.length();或者cursor.count();那样我们也可以用循环显示数据for (var i = 0, len = c.length(); i &lt; len; i++) printjson(c[i]); 7、将find游标转换成数组&gt; var arr = db.users.find().toArray();&gt; printjson(arr[2]);用toArray方法将其转换为数组 8、定制我们自己的查询结果只显示age &lt;= 28的并且只显示age这列数据db.users.find({age: {$lte: 28}}, {age: 1}).forEach(printjson);db.users.find({age: {$lte: 28}}, {age: true}).forEach(printjson);排除age的列db.users.find({age: {$lte: 28}}, {age: false}).forEach(printjson); 9、forEach传递函数显示信息db.things.find({x:4}).forEach(function(x) {print(tojson(x));});]]></content>
      <categories>
        <category>nodejs</category>
        <category>数据库</category>
        <category>mongoDB</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript取得当前元素的下一个元素]]></title>
    <url>%2F2016%2F05%2F28%2Fjs-get-prev-ele%2F</url>
    <content type="text"><![CDATA[如何取得当前元素的下一个元素呢？例如，这有两个div &lt;div id="wrap1" class="wrap">这是一个div&lt;/div> &lt;div class="wrap" style="margin-top: 20px">这是一个div&lt;/div> 我可以取得第一个div我想取得紧邻它的下一个元素，从网上获取的方法是：div1.nextSibling，然会我会得到一个#text 可是我想要的不是这个东西，我想得到像变量div1一样的div,经过测试下面两种方法都可以这样就得到了我想得到的下一个元素了如果某元素的紧邻的下一个元素不存在，则返回一个 null 注：只在谷歌浏览器下测试]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript中的事件代理]]></title>
    <url>%2F2016%2F05%2F28%2FjavaScript-event-agent%2F</url>
    <content type="text"><![CDATA[今天在看视频时，发现了 事件代理 这一方法。假设在一个div中，有很多button，很多li标签，它们需要绑定相应的方法，如果一个一个写就太麻烦了，这时候事件代理的优点就凸显出来了。下面看一下具体例子 ```jsfor (var i = 0; i &lt; boxs.length; i++) { // 1）在li上绑定点击事件代理 boxs[i].onclick = function(event) { // e = e || window.event; //1.获取触发元素，取得class。 var el = event.target || event.srcElement; // this 指的是box ，el指的是当前点击的元素 //2.根据class调用不同的函数。 switch (el.className) { case ‘close’: removeNode(this); break; case ‘praise’: praiseBox(this, el); break; case ‘btn’: replayBox(this, el); break; case ‘comment-praise’: praiseReply(el.parentNode); break; case ‘comment-operate’: operateReply(this, el); break; } }}这样就简单很多了吧。。。]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP中PDO的使用]]></title>
    <url>%2F2016%2F05%2F26%2Fphp-pdo%2F</url>
    <content type="text"><![CDATA[1.PDO连接MySQL数据库 $pdo = new PDO("mysql:host=localhost;dbname=db_demo",用户名,密码); 默认不是长连接，若要使用数据库长连接，需要在最后加如下参数: new PDO("mysql:host=localhost;dbname=db_demo","root","","array(PDO::ATTR_PERSISTENT => true) "); 2.PDO中常用的函数及其解释如下:PDO::query()主要是用于有记录结果返回的操作，特别是SELECT操作PDO::exec()主要是针对没有结果集合返回的操作，如INSERT、UPDATE等操作PDO::lastInsertId() 返回上次插入操作，主键列类型是自增的最后的自增IDPDOStatement::fetch()是用来获取一条记录 PDOStatement::fetchAll()是获取所有记录集到一个中 3.使用示例 $sql = "select price from shop where id=?"; $stmt = $pdo->prepare($sql); $stmt->execute($id); $data=$stmt->fetch(PDO::FETCH_ASSOC); $sql = "insert into shop(id,name,price) values(?,?,?)"; $stmt = $pdo->prepare($sql); $stmt->execute($id,$name,$price); $data=$stmt->rowCount();]]></content>
      <categories>
        <category>数据库</category>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[京东分类栏]]></title>
    <url>%2F2016%2F05%2F18%2Fjs-classification-column%2F</url>
    <content type="text"><![CDATA[今天把京东的分类栏给扒下来了，js部分是我自己写的，我不知道除了onmouseover和onmouseout之外，是否还有其他的方法，等以后遇到，会再来补充。 &lt;div id="category-2014" class="dropdown"> &lt;div class="dt"> &lt;a href="#" target="_blank">全部商品分类&lt;/a> &lt;/div> &lt;div class="dd"> &lt;div class="dd-inner"> &lt;div class="item fore1" data-index="1"> &lt;h3> &lt;a href="#" target="_blank">家用电器&lt;/a> &lt;/h3> &lt;i>>&lt;/i> &lt;/div> &lt;div class="item fore2" data-index="2"> &lt;h3>&lt;a target="_blank" href="//shouji.jd.com/">手机&lt;/a>、&lt;a target="_blank" href="//shuma.jd.com/">数码&lt;/a>、&lt;a target="_blank" href="//mobile.jd.com/">京东通信&lt;/a>&lt;/h3> &lt;i>>&lt;/i> &lt;/div> &lt;div class="item fore3" data-index="3"> &lt;h3>&lt;a target="_blank" href="//diannao.jd.com/">电脑、办公&lt;/a>&lt;/h3> &lt;i>>&lt;/i> &lt;/div> &lt;div class="item fore4" data-index="4"> &lt;h3> &lt;a target="_blank" href="#">家居&lt;/a>、 &lt;a target="_blank" href="#">家具&lt;/a>、 &lt;a target="_blank" href="#">家装&lt;/a>、 &lt;a target="_blank" href="#">厨具&lt;/a>&lt;/h3> &lt;i>>&lt;/i> &lt;/div> &lt;div class="item fore5" data-index="5"> &lt;h3> &lt;a target="_blank" href="#">男装&lt;/a>、 &lt;a target="_blank" href="#">女装&lt;/a>、 &lt;a target="_blank" href="#">童装&lt;/a>、 &lt;a target="_blank" href="#">内衣&lt;/a> &lt;/h3> &lt;i>>&lt;/i> &lt;/div> &lt;div class="item fore6" data-index="6"> &lt;h3> &lt;a target="_blank" href="#">个护化妆&lt;/a>、 &lt;a target="_blank" href="#">清洁用品&lt;/a>、 &lt;a target="_blank" href="#">宠物&lt;/a> &lt;/h3> &lt;i>>&lt;/i> &lt;/div> &lt;div class="item fore7" data-index="7"> &lt;h3> &lt;a target="_blank" href="#">鞋靴&lt;/a>、 &lt;a target="_blank" href="#">箱包&lt;/a>、 &lt;a target="_blank" href="#">珠宝&lt;/a>、 &lt;a target="_blank" href="#">奢侈品&lt;/a> &lt;/h3> &lt;i>>&lt;/i> &lt;/div> &lt;div class="item fore8" data-index="8"> &lt;h3> &lt;a target="_blank" href="#">运动户外&lt;/a>、 &lt;a target="_blank" href="#">钟表&lt;/a> &lt;/h3> &lt;i>>&lt;/i> &lt;/div> &lt;div class="item fore9" data-index="9"> &lt;h3> &lt;a target="_blank" href="#">汽车&lt;/a>、 &lt;a target="_blank" href="#">汽车用品&lt;/a> &lt;/h3> &lt;i>>&lt;/i> &lt;/div> &lt;div class="item fore10" data-index="10"> &lt;h3> &lt;a target="_blank" href="#">母婴&lt;/a>、 &lt;a target="_blank" href="#">玩具乐器&lt;/a> &lt;/h3> &lt;i>>&lt;/i> &lt;/div> &lt;div class="item fore11" data-index="11"> &lt;h3> &lt;a target="_blank" href="#">食品&lt;/a>、 &lt;a target="_blank" href="#">酒类&lt;/a>、 &lt;a target="_blank" href="#">生鲜&lt;/a>、 &lt;a target="_blank" href="#">特产&lt;/a> &lt;/h3> &lt;i>>&lt;/i> &lt;/div> &lt;div class="item fore12" data-index="12"> &lt;h3> &lt;a target="_blank" href="#">医药保健&lt;/a> &lt;/h3> &lt;i>>&lt;/i> &lt;/div> &lt;div class="item fore13" data-index="13"> &lt;h3> &lt;a target="_blank" href="#">图书&lt;/a>、 &lt;a target="_blank" href="#">音像&lt;/a>、 &lt;a target="_blank" href="#">电子书&lt;/a> &lt;/h3> &lt;i>>&lt;/i> &lt;/div> &lt;div class="item fore14" data-index="14"> &lt;h3> &lt;a target="_blank" href="#">彩票&lt;/a>、 &lt;a target="_blank" href="#">旅行&lt;/a>、 &lt;a target="_blank" href="#">充值&lt;/a>、 &lt;a target="_blank" href="#">票务&lt;/a> &lt;/h3> &lt;i>>&lt;/i> &lt;/div> &lt;div class="item fore15" data-index="15"> &lt;h3> &lt;a target="_blank" href="#">理财&lt;/a>、 &lt;a target="_blank" href="#">众筹&lt;/a>、 &lt;a target="_blank" href="#">白条&lt;/a>、 &lt;a target="_blank" href="#">保险&lt;/a> &lt;/h3> &lt;i>>&lt;/i> &lt;/div> &lt;div class="dropdown-layer"> &lt;div class="item-sub" id="category-item-1"> &lt;img src="img/pic01.jpg"> &lt;/div> &lt;div class="item-sub" id="category-item-2"> &lt;img src="img/pic02.jpg"> &lt;/div> &lt;div class="item-sub" id="category-item-2"> &lt;img src="img/pic03.jpg"> &lt;/div> &lt;div class="item-sub" id="category-item-2"> &lt;img src="img/1.jpg"> &lt;/div> &lt;div class="item-sub" id="category-item-2"> &lt;img src="img/2.jpg"> &lt;/div> &lt;div class="item-sub" id="category-item-2"> &lt;img src="img/3.jpg"> &lt;/div> &lt;div class="item-sub" id="category-item-2"> &lt;img src="img/4.jpg"> &lt;/div> &lt;div class="item-sub" id="category-item-2"> &lt;img src="img/banner.jpg"> &lt;/div> &lt;div class="item-sub" id="category-item-2"> &lt;img src="img/5.jpg"> &lt;/div> &lt;div class="item-sub" id="category-item-2"> &lt;img src="img/6.jpg"> &lt;/div> &lt;div class="item-sub" id="category-item-2"> &lt;img src="img/7.jpg"> &lt;/div> &lt;div class="item-sub" id="category-item-2"> &lt;img src="img/pic02.jpg"> &lt;/div> &lt;div class="item-sub" id="category-item-2"> &lt;img src="img/2.jpg"> &lt;/div> &lt;div class="item-sub" id="category-item-2"> &lt;img src="img/1.jpg"> &lt;/div> &lt;div class="item-sub" id="category-item-2"> &lt;img src="img/4.jpg"> &lt;/div> &lt;/div> &lt;/div> &lt;/div> &lt;/div> * { margin: 0; padding: 0; font-family: 'Microsoft Yahei','黑体'; -webkit-font-smoothing: antialiased; } a { color: #fff; text-decoration: none; } .dt a { display: block; width: 190px; height: 44px; padding: 0 10px; background: #B1191A; font: 600 15px/44px "microsoft yahei"; color: #fff; } .dd { width: 210px; height: 466px; background: #c81623; margin-top: 2px; } .dd .dd-inner .item { border-left: 1px solid #b61d1d; position: relative; z-index: 1; height: 31px; color: #fff; } .dd .dd-inner .item h3 { position: absolute; z-index: 2; height: 31px; padding: 0 10px; line-height: 31px; font-family: "microsoft yahei"; font-size: 14px; font-weight: 400; } .dd .dd-inner .item i { display: block; position: absolute; z-index: 1; top: 9px; right: 14px; width: 4px; height: 14px; font: 400 9px/14px consolas; } .dd .dropdown-layer{ display: none; position: absolute; left: 209px; top: 45px; width: 779px; height: 465px; background: #f7f7f7; border: 1px solid #b61d1d; overflow: hidden; } .dd .dropdown-layer .item-sub { display: none; } .dd .dropdown-layer .item-sub, .dd .dropdown-layer .item-sub img { width: 100%; height: 100%; } .dd .dd-inner .item-hover { background-color: #fff; color: #B61D1D; font-weight: bolder; } .dd .dd-inner .item-hover a { color: #B61D1D; } .dd .dd-inner .item-hover i { display: none; } .dd .dd-inner .item-hover ~ .dropdown-layer { display: block; } .dd .dropdown-layer .hover { display: block; } var item = document.querySelectorAll('.item'); var category_item = document.querySelectorAll('.item-sub'); var dropdown_layer = document.querySelector('.dropdown-layer'); for(var i=0;i&lt;item.length;i++) { item[i].index = i; item[i].onmouseover = function(event) { // 去除其他item的hover样式 for(var j=0;j&lt;item.length;j++) { item[j].className = "item"; } // 为当前item添加hover样式 this.className += ' item-hover'; // 去除其他category_item的hover样式 for(j=0;j&lt;category_item.length;j++) { category_item[j].className = "item-sub"; } // 为当前category_item添加hover样式 category_item[this.index].className += ' hover'; category_item[this.index].c_index = this.index; // 鼠标离开时去除样式 category_item[this.index].onmouseout = function() { item[this.c_index].className = 'item'; this.className = 'item-sub'; } } }]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用nodejs构建网站]]></title>
    <url>%2F2016%2F05%2F10%2Fnode-create-website%2F</url>
    <content type="text"><![CDATA[1、选择文件夹2、执行:express node（node是你指定的文件夹名，可随意指定），默认使用的是jade模块，如果想安装ejs模块，就使用这个命令：express -e node3、进入node （就是你刚才制定的文件夹名）目录：cd node4、执行 npm install 安装node所需要的依赖模块。如果执行此命令出现错误，就使用npm install -g，前提是你现在是管理员的身份5、至此，网站框架已搭建完成。各文件夹的含义还没有深入了解。以后学习后再来补充]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用视觉差实现图片滑动]]></title>
    <url>%2F2016%2F05%2F07%2Fjs-picture-slide%2F</url>
    <content type="text"><![CDATA[今天看了别人写的图片滑动，看起来很酷，读源码时，似乎有些困难，就模仿着写了一个，实现的效果与原网页相同，不过自己的js代码，逻辑简单，有待改进。ps：前两天写了旋转木马，那个兼容性不好，今天写这个网页的时候，也是按照这个思路，在谷歌浏览器上运行很好，火狐很多功能不能实现，由于wrap——panel使用了绝对定位，就将translate平移改为了left。改动后，各个浏览器运行的效果不错 &lt;div class="container"> &lt;h1>Parallax Slider&lt;/h1> &lt;div class="wrap"> &lt;div class="bg-img"> &lt;div id="bg_1" class="bg bg-1" style="left: 0px;">&lt;/div> &lt;div id="bg_2" class="bg bg-2" style="left: 0px;">&lt;/div> &lt;div id="bg_3" class="bg bg-3" style="left: 0px;">&lt;/div> &lt;/div> &lt;div id="wrap_panel" class="wrap-panel" style="left: 0px;"> &lt;div class="panel panel-1"> &lt;img id="img_1" src="images/1.jpg"> &lt;/div> &lt;div class="panel panel-2"> &lt;img src="images/2.jpg"> &lt;/div> &lt;div class="panel panel-3"> &lt;img src="images/3.jpg"> &lt;/div> &lt;div class="panel panel-4"> &lt;img src="images/4.jpg"> &lt;/div> &lt;div class="panel panel-5"> &lt;img src="images/5.jpg"> &lt;/div> &lt;div class="panel panel-6"> &lt;img src="images/6.jpg"> &lt;/div> &lt;/div> &lt;div class="navigation-button"> &lt;span id="perv_btn" class="perv-button">&lt;/span> &lt;span id="next_btn" class="next-button">&lt;/span> &lt;/div> &lt;div id="show_small" class="show-small"> &lt;ul> &lt;li>&lt;img src="images/thumbs/1.jpg">&lt;/li> &lt;li>&lt;img src="images/thumbs/2.jpg">&lt;/li> &lt;li>&lt;img src="images/thumbs/3.jpg">&lt;/li> &lt;li>&lt;img src="images/thumbs/4.jpg">&lt;/li> &lt;li>&lt;img src="images/thumbs/5.jpg">&lt;/li> &lt;li>&lt;img src="images/thumbs/6.jpg">&lt;/li> &lt;/ul> &lt;/div> &lt;/div> &lt;/div> * { margin: 0; padding: 0; } html, body, .container { width: 100%; height: 100%; font-family: 'Microsoft Yahei'; } .container { background-color: #222; overflow-x: hidden; } .container h1 { font-size: 50px; color: #ccc; text-align: center; font-weight: bolder; height: 120px; line-height: 120px; } .wrap { position: relative; width: 600%; height: 400px; border-top: 10px solid #333; border-bottom: 10px solid #333; margin-top: 20px; } .bg { position: absolute; width: 100%; height: 100%; left: 0; top: 0; -webkit-transition: all 1s;-moz-transition: all 1s;-ms-transition: all 1s;-o-transition: all 1s;transition: all 1s; } .bg-1 { background: url(images/bg1.png); } .bg-2 { background: url(images/bg2.png); } .bg-3 { background: url(images/bg3.png); } .wrap-panel { position: absolute; width: 100%; height: 100%; -webkit-transition: all 1s; -moz-transition: all 1s; -ms-transition: all 1s; -o-transition: all 1s; transition: all 1s; } .panel { width: 16.66%; height: 100%; float: left; } .panel img { display: block; margin: 0 auto; margin-top: 35px; border-radius: 10px; border: 10px solid rgba(143, 143, 143, 0.6); } .navigation-button span:hover { opacity: 0.8 } .perv-button, .next-button { position: absolute; width: 30px; height: 60px; background-color: #344133; border-radius: 10px; cursor: pointer; opacity: 0.4; } .perv-button { background: #000 url(images/prev.png) center center no-repeat; } .next-button { background: #000 url(images/next.png) center center no-repeat; } .show-small { position: absolute; width: 680px; bottom: 20px; } .show-small ul { list-style: none; } .show-small ul li { float: left; margin: 0 10px; border: 5px solid #fff; opacity: 0.7; cursor: pointer;-webkit-transition: all .3s; -moz-transition: all .3s; -ms-transition: all .3s;-o-transition: all .3s; transition: all .3s; } .show-small ul li:hover { margin-top: -15px; } window.onload = function() { // 得到元素 var getDOM = function (id){ return typeof id==="string"?document.getElementById(id):id; } // 得到对象 var img = getDOM('img_1'); var prev = getDOM("perv_btn"); var next = getDOM("next_btn"); var wrap_panel = getDOM('wrap_panel'); var bg_1 = getDOM("bg_1"); var bg_2 = getDOM("bg_2"); var bg_3 = getDOM("bg_3"); var show_small = getDOM("show_small"); var list = show_small.getElementsByTagName("li"); var wwidth; // 为元素绑定事件 var addEvent = function(id,event,fn) { var el = getDOM(id) || document; if(el.addEventListener){ el.addEventListener(event,fn,false); }else if(el.attachEvent){ el.attachEvent('on' + event,fn); } } function init() { // 对按钮进行定位 // 向前按钮的左边距离=图片的左距离+边框 prev.style.left = img.offsetLeft + 10 + 'px'; // 向前按钮的上边距离=图片的上距离+图片高度的一半-按钮高度的一半 prev.style.top = img.offsetTop + img.clientHeight/2 - prev.clientHeight/2 + 'px'; next.style.left = img.offsetLeft + img.clientWidth + 10 - next.clientWidth + 'px'; next.style.top =prev.style.top; // 对小图片的容器进行定位 wwidth = document.documentElement.clientWidth || document.body.clientWidth; show_small.style.left = (wwidth - show_small.clientWidth)/2 + 'px'; } // 小图片的处理 function small_img() { // 对图片进行旋转处理 for (var i = 0;i&lt; list.length; i++) { // 旋转方向 var direction = Math.pow(-1,parseInt(Math.random()*10)); list[i].style = "transform:rotate(" + (Math.random()*20*direction) + "deg)"; } list[0].style.opacity = 1; } function only_one(el,num) { for (var i = 0; i &lt; el.length; i++) { el[i].style.opacity = 0.7; } // console.log(num); el[num].style.opacity = 1; } // 浏览器缩放时 window.onresize = function() { init(); } // 执行函数 init(); small_img(); addEvent(prev,'click',function() { // 改变wrap-panel的left var oldPos = parseInt(wrap_panel.style.left); if(oldPos == 0) { // 背景平移 图片容器平移 bg_1.style.left=bg_2.style.left=bg_3.style.left=wrap_panel.style.left = -wwidth*(list.length-1) +'px'; // 更改对应小图片透明度 only_one(list,list.length-1); } else { // 背景平移 图片容器平移 wrap_panel.style.left = (oldPos + wwidth) +'px'; bg_1.style.left= (oldPos + wwidth - parseInt(-(oldPos/wwidth + 1))*100) +'px'; bg_2.style.left= (oldPos + wwidth - parseInt(-(oldPos/wwidth + 1))*300) +'px'; bg_3.style.left= (oldPos + wwidth - parseInt(-(oldPos/wwidth + 1))*500) +'px'; // 更改对应小图片透明度 only_one(list,parseInt(-(oldPos/wwidth + 1))); } }); addEvent(next,'click',function() { // 改变wrap-panel的left var oldPos = parseInt(wrap_panel.style.left); if(oldPos == -wwidth*(list.length-1)) { // 背景平移 图片容器平移 bg_1.style.left=bg_2.style.left=bg_3.style.left=wrap_panel.style.left = '0px'; // 更改对应小图片透明度 only_one(list,0); } else { // 背景平移 图片容器平移 wrap_panel.style.left = (oldPos - wwidth) +'px'; bg_1.style.left= (oldPos - wwidth + parseInt(-(oldPos/wwidth + 1))*100) +'px'; bg_2.style.left= (oldPos - wwidth + parseInt(-(oldPos/wwidth + 1))*300) +'px'; bg_3.style.left= (oldPos - wwidth + parseInt(-(oldPos/wwidth + 1))*500) +'px'; // 更改对应小图片透明度 only_one(list,parseInt(-(oldPos/wwidth - 1))); } }); }]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将json格式的字符串转化成object对象]]></title>
    <url>%2F2016%2F05%2F06%2Fjs-json-to-object%2F</url>
    <content type="text"><![CDATA[将一堆json数据的字符串，转换成js能认识的数据例如：var response = &quot;{&quot;state&quot;:1,&quot;msg&quot;:&quot;yes&quot;,&quot;count&quot;:1}&quot;;对其进行操作：response = eval(&#39;(&#39; + response + &#39;)&#39;); 或者$.parseJSON(response)这样在js中就可以访问response.state,response.msg,response.count]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP中操作MYSQL数据库常用函数]]></title>
    <url>%2F2016%2F05%2F05%2Fphp-mysql%2F</url>
    <content type="text"><![CDATA[1、mysql_connect()-建立数据库连接 格式： resource mysql_connect([string hostname [:port] [:/path/to/socket] [, string username] [, string password]]) 例： $conn = @mysql_connect(“localhost”, “username”, “password”) or die(“不能连接到Mysql Server”); 说明：使用该连接必须显示的关闭连接 2、mysql_pconnect()-建立数据库连接 格式： resource mysql_pconnect([string hostname [:port] [:/path/to/socket] [, string username] [, string password]]) 例： $conn = @mysql_pconnect(“localhost”, “username”, “password”) or dir(“不能连接到Mysql Server”); 说明：使用该连接函数不需要显示的关闭连接，它相当于使用了连接池 3、mysql_close()-关闭数据库连接 例： $conn = @mysql_connect(“localhost”, “username”, “password”) or die(“不能连接到Mysql Server”); @mysql_select_db(“MyDatabase”) or die(“不能选择这个数据库，或数据库不存在”); echo “你已经连接到MyDatabase数据库”; mysql_close(); 4、mysql_select_db()-选择数据库 格式： boolean mysql_select_db(string db_name [, resource link_id]) 例： $conn = @mysql_connect(“localhost”, “username”, “password”) or die(“不能连接到Mysql Server”); @mysql_select_db(“MyDatabase”) or die(“不能选择这个数据库，或数据库不存在”); 5、mysql_query()-查询MySQL 格式： resource mysql_query (string query, [resource link_id]) 例： $linkId = @mysql_connect(“localhost”, “username”, “password”) or die(“不能连接到Mysql Server”); @mysql_select_db(“MyDatabase”) or die(“不能选择这个数据库，或者数据库不存在”); $query = “select * from MyTable”; $result = mysql_query($query); mysql_close(); 说明：若SQL查询执行成功，则返回资源标识符，失败时返回FALSE。若执行更新成功，则返回TRUE，否则返回FALSE 6、mysql_db_query()-查询MySQL 格式： resource mysql_db_query(string database, string query [, resource link_id]) 例： $linkId = @mysql_connect(“localhost”, “username”, “password”) or die(“不能连接到MysqlServer”); $query = “select * from MyTable”; $result = mysql_db_query(“MyDatabase”, $query); mysql_close(); 说明：为了使代码清晰，不推荐使用这个函数调用 7、mysql_result()-获取和显示数据 格式： mixed mysql_result (resource result_set, int row [, mixed field]) 例： $query = “select id, name from MyTable order by name”; $result = mysql_query($query); for($count=0;$count&lt;=mysql_numrows($result);$count++) { $c_id = mysql_result($result, 0, “id”); $c_name = mysql_result($result, 0, “name”); echo $c_id,$c_name; } 说明：最简单、也是效率最低的数据获取函数 8、mysql_fetch_row()-获取和显示数据 格式： array mysql_fetch_row (resource result_set) 例： $query = “select id, name from MyTable order by name”; $result = mysql_query($query); while (list($id, $name) = mysql_fetch_row($result)) { echo(“Name: $name ($id) “); } 说明：函数从result_set中获取整个数据行，将值放在一个索引数组中。通常会结使list()函数使用 9、mysql_fetch_array()-获取和显示数据 格式： array mysql_fetch_array (resource result_set [, int result_type]) 例： $query = “select id, name from MyTable order by name”; $result = mysql_query($query); while($row = mysql_fetch_array($result, MYSQL_ASSOC)) { $id = $row[“id”]; $name = $row[“name”]; echo “Name: $name ($id) “; } 又 例： $query = “select id, name from MyTable order by name”; $result = mysql_query($query); while($row = mysql_fetch_array($result, MYSQL_NUM)) { $id = $row[0]; $name = $row[1]; echo “Name: $name ($id) “; } 说明： result_type的值有： MYSQL_ASSOC: 字段名表示键，字段内容为值 MYSQL_NUM: 数值索引数组，操作与mysql_fetch_ros()函数一样 MYSQL_BOTH: 即作为关联数组又作为数值索引数组返回。result_type的默认值。 10、mysql_fetch_assoc()-获取和显示数据 格式： array mysql_fetch_assoc (resource result_set) 相当于调用 mysql_fetch_array(resource, MYSQL_ASSOC); 11、mysql_fetch_object()-获取和显示数据 格式： object mysql_fetch_object(resource result_set) 例： $query = “select id, name from MyTable order by name”; while ($row = mysql_fetch_object($result)) { $id = $row-&gt;id; $name = $row-&gt;name; echo “Name: $name ($id) “; } 说明：返回一个对象，在操作上与mysql_fetch_array()相同 12、mysql_num_rows()-所选择的记录的个数 格式： int mysql_num_rows(resource result_set) 例： query = “select id, name from MyTable where id &gt; 65”; $result = mysql_query($query); echo “有”.mysql_num_rows($result).”条记录的ID大于65”; 说明：只在确定select查询所获取的记录数时才有用。 13、mysql_affected_rows()－受Insert,update,delete影响的记录的个数 格式： int mysql_affected_rows([resource link_id]) 例： $query = “update MyTable set name=’CheneyFu’ where id&gt;=5”; $result = mysql_query($query); echo “ID大于等于5的名称被更新了的记录数：”.mysql_affected_rows(); 说明：该函数获取受INSERT,UPDATE或DELETE更新语句影响的行数 14、mysql_list_dbs()-获取数据库列表信息 格式： resource mysql_list_dbs([resource link_id]) 例： mysql_connect(“localhost”, “username”, “password”); $dbs = mysql_list_dbs(); echo “Databases: “; while (list($db) = mysql_fetch_rows($dbs)) { echo “$db “; } 说明：显示所有数据库名称 15、mysql_db_name()-获取数据库名 格式： string mysql_db_name(resource result_set, integer index) 说明：该函数获取在mysql_list_dbs()所返回result_set中位于指定index索引的数据库名 16、mysql_list_tables()-获取数据库表列表 格式： resource mysql_list_tables(string database [, resource link_id]) 例： mysql_connect(“localhost”, “username”, “password”); $tables = mysql_list_tables(“MyDatabase”); while (list($table) = mysql_fetch_row($tables)) { echo “$table “; } 说明：该函数获取database中所有表的表名 17、mysql_tablename()-获取某个数据库表名 格式： string mysql_tablename(resource result_set, integer index) 例： mysql_connect(“localhost”, “username”, “password”); $tables = mysql_list_tables(“MyDatabase”); $count = -1; while (++$count &lt; mysql_numrows($tables)) { echo mysql_tablename($tables, $count).”“; } 说明：该函数获取mysql_list_tables()所返回result_set中位于指定index索引的表名 18、mysql_fetch_field()-获取字段信息 格式： object mysql_fetch_field(resource result [, int field_offset]) 例： mysql_connect(“localhost”, “username”, “password”); mysql_select_db(“MyDatabase”); $query = “select * from MyTable”; $result = mysql_query($query); $counts = mysql_num_fields($result); for($count = 0; $count &lt; $counts; $count++) { $field = mysql_fetch_field($result, $count); echo “$field-&gt;name $field-&gt;type ($field-&gt;max_length) “; } 说明： 返回的对象共有12个对象属性： name: 字段名 table: 字段所在的表 max_length:字段的最大长度 not_null: 如果字段不能为null,则为1,否则0 primary_key: 如果字段为主键，则为1，否则0 unique_key: 如果字段是唯一键，则为1， 否则0 multiple_key: 如果字段为非唯一，则为1，否则0 numeric: 如果字段为数值则为1，否则0 blob: 如果字段为BLOB则为1，否则为0 type: 字段的数据类型 unsigned: 如果字段为无符号数则为1，否则为0 zerofill: 如果字段为“零填充”则为1， 否则为0 19、mysql_num_fields()-获取查询的字段个数 格式： integer mysql_num_fields(resource result_set) 例： $query = “select id,name from MyTable order by name”; $result = mysql_query($query); echo “这个查询的字段数是：”.mysql_num_fields($result).”“; 20、mysql_list_fields()-获取指定表的所有字段的字段名 格式： resource mysql_list_fields (string database_name, string table_name [, resource link_id]) 例： $fields =mysql_list_fields(“MyDatabase”, “MyTable”); echo “数据库MyDatabase中表MyTable的字段数： “.mysql_num_fields($fields).”“; 21、mysql_field_flags()-获取指定的字段选项 格式： string mysql_field_flags (resource result_set, integer field_offset) 例： $query = “select id, name from MyTable order by name”; $result = mysql_query($query); $row=mysql_fetch_wor($row); 22、mysql_field_len()-获取指定的字段的最大长度 格式： integer mysql_field_len (resource result_set, integer field_offset) 例： $query = “select name from MyTable”; $result = mysql_query($query); $row = mysql_fetch_row($result); echo mysql_field_len($result, 0).”“; 说明： 如果mysql_field_len($reseult, 0) = 16777215 那么numer_format(mysql_field_len($result))等于16,777,215 23、mysql_field_name()-获取字段名 格式： string mysql_field_name (resource result_set, int field_offset) 例： $query = “select id as PKID, name from MyTable order by name”; $result = mysql_query($query); $row = mysql_fetch_row($result); echo mysql_field_name($result, 0); // Result: PKID 24、mysql_field_type()-获取字段类型 格式： string mysql_field_type (resource result_set, int field_offset) 例： $query = “select id, name from MyTable order by name”; $result = mysql_query($query); $row = mysql_fetch_row($result); echo mysql_field_type($result, 0); // Result: int 25、mysql_field_table()-获取字段所在表名 格式： string mysql_field_table (resource result_set, int field_offset) 例： $query = “select id as PKID, name from MyTable order by name”; $result = mysql_query($query); $row = mysql_fetch_row($result); echo mysql_field_table($result, 0); // Result: MyTable]]></content>
      <categories>
        <category>数据库</category>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式中的特殊字符]]></title>
    <url>%2F2016%2F05%2F04%2Fjs-regular-expression%2F</url>
    <content type="text"><![CDATA[字符/ 意义：对于字符，通常表示按字面意义，指出接着的字符为特殊字符，不作解释。 例如：/b/匹配字符’b’,通过在b 前面加一个反斜杠，也就是/\b/，则该字符变成特殊字符，表示匹配一个单词的分界线。 或者：对于几个字符，通常说明是特殊的，指出紧接着的字符不是特殊的，而应该按字面解释。例如：是一个特殊字符，匹配任意个字符(包括0个 字符)；例如：/a/意味匹配0个或多个a。为了匹配字面上的，在a前面加一个反斜杠；例如：/\a/匹配’a*’。字符^ 意义：表示匹配的字符必须在最前边。 例如：/^A/不匹配”an A,”中的’A’，但匹配”An A.”中最前面的’A’。 字符$ 意义：与^类似，匹配最末的字符。 例如：/t$/不匹配”eater”中的’t’，但匹配”eat”中的’t’。 字符 意义：匹配前面的字符0次或n次。 例如:/bo*/匹配”A ghost booooed”中的’boooo’或”A bird warbled”中的’b’，但不匹配”Agoat grunted”中的任何字符。 字符+ 意义：匹配+号前面的字符1次或n次。等价于{1,}。 例如：/a+/匹配”candy”中的’a’和”caaaaaaandy.”中的所有’a’。 字符? 意义：匹配?前面的字符0次或1次。 例如：/e?le?/匹配”angel”中的’el’和”angle.”中的’le’。 字符. 意义：(小数点)匹配除换行符外的所有单个的字符。 例如：/.n/匹配”nay, an apple is on the tree”中的’an’和’on’，但不匹配’nay’。字符{ n } 意义：这里的n是一个正整数。匹配前面的n个字符。 例如：/a{ 2 }/不匹配”candy,”中的’a’，但匹配”caandy,” 中的所有’a’和”caaandy.”中前面的两个’a’。字符{ n, } 意义：这里的n是一个正整数。匹配至少n个前面的字符。 例如：/a{ 2, }不匹配”candy”中的’a’，但匹配”caandy”中的所有’a’和”caaaaaaandy.”中的所有’a’字符{ n,m } 意义：这里的n和m都是正整数。匹配至少n个最多m个前面的字符。 例如：/a{ 1,3 }/不匹配”cndy”中的任何字符，但匹配 “candy,”中的’a’，”caandy,” 中的前面两个 ’a’和”caaaaaaandy”中前面的三个’a’，注意：即使”caaaaaaandy” 中有很多个’a’，但只匹配前面的三 个’a’即”aaa”。字符[xyz] 意义：一字符列表，匹配列出中的任一字符。你可以通过连字符-指出一个字符范围。 例如：[abcd]跟[a-c]一样。它们匹配”brisket”中的’b’和”ache”中的’c’。字符[^xyz] 意义：一字符补集，也就是说，它匹配除了列出的字符外的所有东西。 你可以使用连字符-指出一 字符范围。 例如：[^abc]和[^a-c]等价，它们最早匹配”brisket”中的’r’和”chop.”中的’h’。 字符 意义：匹配一个空格(不要与b混淆) 字符b 意义：匹配一个单词的分界线，比如一个空格(不要与混淆) 例如：/bnw/匹配”noonday”中的’no’，/wyb/匹配”possibly yesterday.”中的’ly’。 字符B 意义：匹配一个单词的非分界线 例如：/wBn/匹配”noonday”中的’on’，/yBw/匹配”possibly yesterday.”中的’ye’。 字符cX 意义：这里的X是一个控制字符。匹配一个字符串的控制字符。 例如：/cM/匹配一个字符串中的control-M。 字符ooctal和xhex意义：这里的ooctal是一个八进制的escape值，而xhex是一个十六进制的escape值，允许在一个正则表达式中嵌入ASCII码附:下表是元字符及其在正则表达式上下文中的行为的一个完整列表：字符 描述 \将下一个字符标记为一个特殊字符、或一个原义字符、或一个后向引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\’ 匹配 “” 而 “(“ 则匹配 “(“。 字符描述 ^在匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。 字符描述 $匹配输入字符串的结束位置，如果设置了RegExp 对象的 Multiline 属性，也匹配 ‘\n’ 或 ‘\r’ 之前的位置。 (pattern)：匹配pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 {CONTENT}… 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。 (?:pattern)：匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。 (?=pattern)：正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如， ‘Windows (?=95|98|NT|2000)’ 能匹配 “Windows 2000” 中的 “Windows” ，但不能匹配 “Windows 3.1” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern)：负向预查，在任何不匹配Negative lookahead matches the search string at any point where a string not matching pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。 例如’Windows (?!95|98|NT|2000)’ 能匹配 “Windows 3.1” 中的 “Windows”，但不能匹配 “Windows 2000” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符��后开始 x|y： 匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。 [xyz]：字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 [^xyz]：负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’。 [a-z]：字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 [^a-z]：负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。 \b：匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的’er’，但不能匹配 “verb” 中的 ‘er’。 \B：匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \cx匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。 x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 c 字符。 \d匹配一个数字字符。等价于 [0-9]。 \D匹配一个非数字字符。等价于 [^0-9]。 \f匹配一个换页符。等价于 \x0c 和 \cL \n匹配一个换行符。等价于 \x0a 和 \cJ \r匹配一个回车符。等价于 \x0d 和 \cM。 \s匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 \S匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 \t匹配一个制表符。等价于 \x09 和 \cI。 \v匹配一个垂直制表符。等价于 \x0b 和 \cK。 \w匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。 \W匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。 \xn匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如， ‘\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。 .\num匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)’ 匹配两个连续的相同字符。 \n标识一个八进制转义值或一个后向引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为后向引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 \nm标识一个八进制转义值或一个后向引用。如果 \nm 之前至少有is preceded by at least nm 个获取得子表达式，则 nm 为后向引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的后向引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。 \nml如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 \un匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (?)。]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript封装的常用函数（持续更新中）]]></title>
    <url>%2F2016%2F04%2F24%2Fjs-common-function%2F</url>
    <content type="text"><![CDATA[整理了一些有用的javaScript片段 // 2.通用函数 var g = function(id) { if (id.substr(0, 1) == '.') { return document.getElementsByClassName(id.substr(1)); } return document.getElementById(id); } // getElementById var $ = function(id) { return typeof id === "string" ? document.getElementById(id) : id; } // 为元素绑定事件 var addEvent = function(id, event, fn) { var el = $(id) || document; if (el.addEventListener) { el.addEventListener(event, fn, false); } else if (el.attachEvent) { el.attachEvent('on' + event, fn); } else { el['on' + event] = fn } } // 为元素绑定事件 var addEvent = function(el, event, fn) { if (el.addEventListener) { el.addEventListener(event, fn, false); } else if (el.attachEvent) { el.attachEvent('on' + event, fn); } else { el['on' + event] = fn } } // ajaxGet var ajaxGet = function(url,callback) { var _xhr = null; if (window.XMLHttpRequest) { _xhr = new XMLHttpRequest() } else { _xhr = new ActiveXObject("Microsoft.XMLHTTP") } // 3.获得数据 _xhr.onreadystatechange = function() { if (_xhr.readyState == 4 &amp;&amp; _xhr.status == 200) { callback(eval("(" + _xhr.responseText + ")")) } } // 2.用_xhr请求数据 _xhr.open("get",url) _xhr.send() } //判断一个元素是否含有某个className function hasClass(ele,className) { return ele.className &amp;&amp; new RegExp("(^|\\s)" + className + "(\\s|$)").test(ele.className); } // 如果想这样使用：el.hasClass('show'),可以用下列写法 Element.prototype.hasClass = function(className) { return this.className &amp;&amp; new RegExp("(^|\\s)" + className + "(\\s|$)").test(this.className); } // 移除某个元素的某个类名 function removeClass(ele, className) { var reg = new RegExp("(^|\\s)" + className + "(\\s|$)"); ele.className = ele.className.replace(reg, ''); } // 阻止事件冒泡 function stopDefault(e) { if (e &amp;&amp; e.preventDefault) { e.preventDefault(); } else { window.event.returnValue = false; } } function tag(name ,elem) { return (elem||document).getElementsByTagName(name); } //在某一个元素前面插入元素 function before(parent,before,elem) { if(elem==null){ elem=before; before=parent; parent=before.parentNode; } parent.insertBefore(elem,before); } //在某一个元素后面插入元素 function append(parent,elem){ var elems = document.createElement(elem); elems.id="het"; elems.innerHTML="nihao" parent.appendChild(elems); } //移除某元素 function remove(elem){ if(elem) elem.parentNode.removeChild(elem); } //清空元素 function empty(elem){ while(elem.firstChild){ remove(elem.firstChild); } } //获取元素文本的内容的通用函数 function text(element) { var t=""; //查看这个元素是否有子元素，没有的话就是一个单独的元素 element=element.childNodes||element; for(var j=0;j&lt;element.length;j++) { //console.log(element[j].nodeValue); t += element[j].nodeType == 3 ? element[j].nodeValue:text(element[j].childNodes); //console.log(j+","+t); } //console.log(t); return t; } //检查是否有用一个指定的特性 function hasAttribute(elem,name) { return elem.getAttribute(name)!=null; } //获取和设置元素特性的值 function attr(elem,name,value) { //判断这是不是一个合法字符串 if(!name||name.constructor!=String) return ''; name={'for':"htmlFor",'class':"className"}[name]||name; if(typeof value!='undefined'){ elem[name]=value; if(elem.setAttribute){ elem.setAttribute(name,value); } } return elem[name]||elem.getAttribute(name)||''; } // 通过元素名称获得元素 function tag(name ,elem) { return (elem||document).getElementsByTagName(name); } //查找相关元素的前一个兄弟元素的函数 function prev(elem) { do{ elem=elem.previousSibling; }while(elem &amp;&amp; elem.nodeType!=1); return elem; } //查找相关元素的下一个兄弟元素 function next(elem) { do{ elem=elem.nextSibling; }while(elem &amp;&amp;elem.nodeType!=1) return elem; } //查找第一个子元素的函数 function first(elem) { elem=elem.firstChild; return elem &amp;&amp;elem.nodeType!=1 ? next(elem):elem; } //查找最后一个子元素函数 function last(elem) { elem=elem.lastChild; return elem&amp;&amp; elem.nodeType!=1 ? prev(elem):elem; } //查找父元素 function parent(elem,num) { num=num||1; for(var i=0;i&lt;num;i++) if(elem!=null) elem=elem.parentNode; return elem; }function cleanWhitespace(element) { element=element||document.documentElement; var cur=element.firstChild; while(cur!=null) { var nextSibling = cur.nextSibling; if(cur.nodeType==3 &amp;&amp; !/\S/.test(cur.nodeValue)) { //这是一个文本节点，并且只包含空格 nodeType nodeValue 节点属性 element.removeChild(cur); }else if(cur.nodeType==1) { //是一个node节点 cleanWhitespace(cur); } cur = nextSibling; } }]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3 transform实现图片旋转木马3D浏览效果]]></title>
    <url>%2F2016%2F04%2F24%2Ftransform-carousel%2F</url>
    <content type="text"><![CDATA[首先DOM结构： 舞台&gt;容器&gt;图片为舞台设置样式： perspective: 800px;为容器设置样式：transform-style: preserve-3d;position: relative;transition: transform .8s;元素本身style属性设置为transform: rotateY(0deg);为后面容器旋转获得初始值为图片设置样式：position: absolute;为每个图片设置样式（此时又九张图片）： img:nth-child(1) { transform: rotateY( 0deg ) translateZ(195.839px); } img:nth-child(2) { transform: rotateY( 40deg ) translateZ(195.839px); } img:nth-child(3) { transform: rotateY( 80deg ) translateZ(195.839px); } img:nth-child(4) { transform: rotateY( 120deg ) translateZ(195.839px); } img:nth-child(5) { transform: rotateY( 160deg ) translateZ(195.839px); } img:nth-child(6) { transform: rotateY( 200deg ) translateZ(195.839px); } img:nth-child(7) { transform: rotateY( 240deg ) translateZ(195.839px); } img:nth-child(8) { transform: rotateY( 280deg ) translateZ(195.839px); } img:nth-child(9) { transform: rotateY( 320deg ) translateZ(195.839px); } rotateY的值为360/图片的个数，translateZ的值为（图片宽度/2）/ tan（rorateY/2）最后，在js代码中改变容器的rotateY的值：代码如下： var stage = document.getElementById("stage"); stage.addEventListener('click',function() { var rotateY = this.style.webkitTransform; // 由左向右：rotateY-40 var newPos = parseInt(rotateY)-40; this.style.webkitTransform = 'rotateY(' + newPos + 'deg)'; });]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript基本用法]]></title>
    <url>%2F2016%2F04%2F23%2FjavaScript-base-func%2F</url>
    <content type="text"><![CDATA[1、document.write() 可用于直接向 HTML 输出流写内容。简单的说就是直接在网页中输出内容。2、警告alert弹出框：alert（字符串或变量）3、确认（confirm 消息对话框）：confirm(str); 返回boolean值4、提问（prompt 消息对话框）：prompt(str1, str2); str1: 要显示在消息对话框中的文本，不可修改 str2：文本框中的内容，可以修改5、innerHTML 属性：Object.innerHTML 获得或修改元素内容6、改变 HTML 样式：Object.style.property=new style;7、控制类名（className 属性）：object.className = classname8、定义数组： var myarr=new Array();9、数组赋值： myarr[1]=” 张三”;10、事件：鼠标单击事件( onclick ）、鼠标经过事件（onmouseover）、鼠标移开事件（onmouseout）、光标聚焦事件（onfocus）、失焦事件（onblur）、内容选中事件（onselect）、文本框内容改变事件（onchange）、加载事件（onload）、卸载事件（onunload）11、日期对象：var Udate=new Date(); var d = new Date(2012, 10, 1);var d = new Date(‘Oct 1, 2012’);12、日期对象常用方法：get/setDate()、get/setFullYear()、get/setYear()、get/setMonth()、get/setHours()、get/setMinutes()、get/setSeconds()、get/setTime()、getDay()(星期)13、返回指定位置的字符：stringObject.charAt(index)14、返回指定的字符串首次出现的位置：stringObject.indexOf(substring, startpos)15、字符串分割：stringObject.split(separator,limit)16、提取字符串：stringObject.substring(starPos,stopPos)17、提取指定数目的字符：stringObject.substr(startPos,length)18、Math对象常用方法：向上取整：ceil()、向下取整floor()、四舍五入round()、随机数random()19、数组连接：arrayObject.concat(array1,array2,…,arrayN)20、指定分隔符连接数组元素：arrayObject.join(分隔符)21、颠倒数组元素顺序：arrayObject.reverse()22、选定元素：arrayObject.slice(start,end)23、数组排序：arrayObject.sort(方法函数)24、JavaScript 计时器：setTimeout() clearTimeout() setInterval() clearInterval()25、History对象：window.history.[属性|方法]，length|back() forword() go()26、Location对象：location用于获取或设置窗体的URL，并且可以用于解析URL。 location.[属性|方法]27、Navigator对象：Navigator 对象包含有关浏览器的信息，通常用于检测浏览器与操作系统的版本。28、DOM中的方法：getElementsByName(name)、getElementsByTagName(Tagname)、elementNode.set/getAttribute(name)、elementNode.childNodes、node.firstChild、node.lastChild、elementNode.parentNode、nodeObject.nextSibling、nodeObject.previousSibling、appendChild(newnode)、insertBefore(newnode,node)、removeChild()、node.replaceChild (newnode,oldnew )、document.createElement(tagName)、document.createTextNode(data)、29、窗口： document.documentElement.clientHeight/Width、 document.body.clientHeight/Width、document.body.scrollHeight/Width、document.documentElement.scrollHeight/Width、offsetHeight和offsetWidth、scrollLeft/Top、offsetLeft/Top]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用nodejs搭建server端]]></title>
    <url>%2F2016%2F04%2F23%2Fnode-create-server%2F</url>
    <content type="text"><![CDATA[新建一个js文件，保存为server.js，输入以下代码： // 新建server服务器 var http = require('http'); var hostname = '127.0.0.1'; var port = 3000; var server = http.createServer(function(req, res) { // res.writeHead(200, {'Content-Type': 'text/html'}); // res.writeHead(200, {'Content-Type': 'text/plain'}); res.statusCode = 200; res.setHeader('Content-Type', 'text/html'); // res.getHeader('content-type') res.write('&lt;head>&lt;meta charset="utf-8"/>&lt;/head>'); // res.charset = 'utf-8'; 不行 var htmlDiv = '&lt;div style="width: 200px;height: 200px;background-color: #f0f;">div&lt;/div>'; res.write('&lt;b>亲爱的，你慢慢飞，小心前面带刺的玫瑰...&lt;/b>'); res.write(htmlDiv); // 有参数=先调用 res.write(data, encoding) 之后再调用 res.end(). res.end('&lt;h1>Hello world!&lt;/h1>'); }); server.listen(port, hostname, function() { // hostname是const类型时，可以用以下写法 //console.log('Server running at http://${hostname}:${port}/'); console.log('Server running at http://%s:%s', hostname, port); // console.log('Server running at http://' + hostname + ':' + port + '/'); }); 打开控制台，进入server.js所在的文件夹 ，在命令行中输入 node server.js或者使用sublime设置好node的路径，按ctrl+B即可 在浏览器的地址栏中输入http://127.0.0.1:3000/ 就可以看到网页的内容了如果修改了server.js文件，浏览器网页中的内容不会改变，这时候就需要重启服务 打开浏览器刷新，就可以看到内容已经改变]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows----进程]]></title>
    <url>%2F2016%2F04%2F23%2Fwindows-process%2F</url>
    <content type="text"><![CDATA[打开控制台输入netstat -ano 可以查看进程所占用的进程号如要关闭某占用端口的进程 输入 taskkill /f /pid 进程号 即可]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5新内容]]></title>
    <url>%2F2016%2F04%2F17%2Fhtml5-new-content%2F</url>
    <content type="text"><![CDATA[新增的结构标签 section元素表示页面中的一个内容区块,比如章节、页眉、页脚或页面的其他部分。可以和h1、 h2……等元素结合起来使用，表示文档结构。例：HTML5中……;HTML4中 ……。 article元素表示页面中一块与上下文不相关的独立内容。比如一篇文章。 aside元素表示article元素内容之外的、与article元素内容相关的辅助信息。 header元素表示页面中一个内容区块或真个页面的标题。 hgroup元素表示对真个页面或页面中的一个内容区块的标题进行组合。 footer元素表示整个页面或页面中一个内容区块的脚注。一般来说，他会包含创作者的姓名、创作日期以及创作者的联系信息。 nav元素表示页面中导航链接的部分。 figure元素表示一段独立的流内容，一般表示文档主体流内容中的一个独立单元。使用figcaption元素为figure元素组添加标题。例如： &lt;figure> &lt;figcaption>PRC&lt;/figcaption> &lt;p>The People's Republic of China was born in 1949&lt;/p> &lt;/figure> HTML4中常写作 &lt;dl> &lt;h1>prc&lt;/h1> &lt;p>The People's Republic of China was born in 1949&lt;/p> &lt;/dl> 新增的其他元素 video元素定义视频。像电影片段或其他视频流。例：video元素HTML4中写法： audio元素定义音频。如音乐或其他音频流。例：audio元素html4中写法： embed元素用来嵌入内容(包括各种媒体)。格式可以是Midi、Wav、AIFF、AU、MP3,flash等。例：HTML4中代码示例 mark元素主要用来在视觉上向用户呈现哪些需要突出显示或高亮显示的文字。典型应用搜索结果中高亮显示搜素关键字。HTML5;HTML4 。 progress元素表示运行中的进程，可以使用progress元素显示JavaScript中耗时时间函数的进程。等待中……、请稍后等。。 time元素表示日期或时间，也可以两者同时。 ruby元素定义 ruby 注释（中文注音或字符）。与 以及 标签一同使用。ruby 元素由一个或多个字符（需要一个解释/发音）和一个提供该信息的 rt 元素组成，还包括可选的 rp 元素，定义当浏览器不支持 “ruby” 元素时显示的内容。例如漢 (ㄏㄢˋ) rt元素定义字符（中文注音或字符）的解释或发音。 rp元素在 ruby 注释中使用，以定义不支持 ruby 元素的浏览器所显示的内容。wbr元素表示软换行。与br元素的区别：br元素表示此处必须换行；wbr表示浏览器窗口或父级元素足弓宽时（没必要换行时），不换行，而宽度不够时主动在此处换行。canvas元素定义图形，比如图表和其他图像。 元素只是图形容器（画布），必须使用脚本来绘制图形。 var canvas=document.getElementById(‘myCanvas’);var ctx=canvas.getContext(‘2d’);ctx.fillStyle=’#FF0000’;ctx.fillRect(0,0,80,100);command元素——貌似没什么效果。是不是支持有问题表示命令按钮，比如单选按钮、复选框或按钮。只有当 command 元素位于 menu 元素内时，该元素才是可见的。否则不会显示这个元素，但是可以用它规定键盘快捷键。。 Click Me! details标签 目前只有 Chrome 支持 details 标签用于描述文档或文档某个部分的细节 。可与 summary 标签配合使用，summary可以为 details 定义标题。标题是可见的，用户点击标题时，会显示出 details。summary应该是details的第一个子元素。 datalist标签定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值。datalist 及其选项不会被显示出来，它仅仅是合法的输入值列表。使用 input 元素的 list 属性来绑定 datalist。 datagrid标签 如何用？定义可选数据的列表。datagrid 作为树列表来显示。如果把 multiple 属性设置为 true，则可以在列表中选取一个以上的项目。 keygen标签 如何用?标签规定用于表单的密钥对生成器字段。当提交表单时，私钥存储在本地，公钥发送到服务器。复制代码代码如下: Username: Encryption: output标签定义不同类型的输出，比如脚本的输出。复制代码代码如下: source标签标签为媒介元素（比如 和 ）定义媒介资源。 menu标签定义菜单列表。当希望列出表单控件时使用该标签。注意与nav的区别，menu专门用于表单控件。复制代码代码如下: Red blue 新增input标签email必须输入email url必须输入url地址 number必须输入数值 range必须输入一定范围内数值 Date Pickers（日期选择器）拥有多个可供选取日期和时间的新输入类型：date - 选取日、月、年month - 选取月、年week - 选取周和年time - 选取时间（小时和分钟）datetime - 选取时间、日、月、年（UTC 时间）datetime-local - 选取时间、日、月、年（本地时间） search用于搜索域，域显示为常规的文本域。 color 废除的元素1、能用css代替的元素basefont、big、center、font、s、strike、tt、u。这些元素纯粹是为画面展示服务的，HTML5中提倡把画面展示性功能放在css中统一编辑。2、不再使用frame框架。frameset、frame、noframes。HTML5中不支持frame框架，只支持iframe框架，或者用服务器方创建的由多个页面组成的符合页面的形式，删除以上这三个标签。3、只有部分浏览器支持的元素applet、bgsound、blink、marquee等标签。4、其他被废除的元素废除rb，树勇ruby替代。废除acronym使用abbr替代。废除dir使用ul替代。废除isindex使用form与input相结合的方式替代废除listing使用pre替代废除xmp使用code替代废除nextid使用guids废除plaintex使用“text/plian”（无格式正文）MIME类型替代。]]></content>
      <categories>
        <category>前端</category>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js部分整理]]></title>
    <url>%2F2016%2F04%2F17%2Fjs-any-func%2F</url>
    <content type="text"><![CDATA[通过js动态设置每一个元素的尺寸setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。setTimeout(code,millisec) code：必需。要调用的函数后要执行的 JavaScript 代码串。 millisec：必需。在执行代码前需等待的毫秒数。提示：setTimeout() 只执行 code 一次。如果要多次调用，请使用 setInterval() 或者让 code 自身再次调用 setTimeout()。setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。setInterval(code,millisec[,”lang”]) code：必需。要调用的函数或要执行的代码串。millisec：必须。周期性执行或调用 code 之间的时间间隔，以毫秒计。返回值一个可以传递给 Window.clearInterval() 从而取消对 code 的周期性执行的值。例：var int=self.setInterval(“clock()”,50) document.body.clientWidth ==&gt; BODY对象宽度document.body.clientHeight ==&gt; BODY对象高度document.documentElement.clientWidth ==&gt; 可见区域宽度document.documentElement.clientHeight ==&gt; 可见区域高度documentElement 属性可返回文档的根节点。document.body是DOM中Document对象里的body节点， document.documentElement是文档对象根节点(html)的引用。 IE在怪异模型（quick mode）下document.documentElement无法正确取到clietHeight scrollHeight等值，比如clietHeight=0。可以见IE的怪异模型并没有把html作为盒子模型的一部分，好在现在很少使用怪异模 型。（注：如果页面没写DTD或写的不对，IE6默认使用怪异模型解析页面）document.body.scrollHeight和document.documentElement.scrollHeight的区别： document.body.scrollHeight是body元素的滚动高 度，document.documentElement.scrollHeight为页面的滚动高度，且 document.documentElement.scrollHeight在IE和Firefox下还有点小差异。 IE : document.documentElement.scrollHeight = document.body.scrollHeight + marginTop bottom高度 + 上下border宽度 firefox : document.documentElement.scrollHeight = document.body.scrollHeight + marginTop bottom高度这是DOMDocument对象里的body子节点和整个节点树的根节点root。DOM把层次中的每一个对象都称之为节点，就是一个层次结构，你可以理解为一个树形结构，就像我们的目录一样，一个根目录，根目录下有子目录，子目录下还有子目录。以HTML超文本标记语言为例：整个文档的一个根就是,在DOM中可以使用document.documentElement来 访问它，它就是整个节点树的根节点。而body是子节点，要访问到body标签，在脚本中应该写：document.body。]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery部分内容]]></title>
    <url>%2F2016%2F04%2F17%2Fjquery-any-func%2F</url>
    <content type="text"><![CDATA[图片放大镜插件——jqzoom在调用jqzoom图片放大镜插件时，需要准备一大一小两张一样的图片，在页面中显示小图片，当鼠标在小图片中移动时，调用该插件的jqzoom()方法，显示与小图片相同的大图片区域，从而实现放大镜的效果，调用格式如下：$(linkimage).jqzoom({options})其中linkimage参数为包含图片的元素名称，options为插件方法的配置对象。 cookie插件——cookie使用cookie插件后，可以很方便地通过cookie对象保存、读取、删除用户的信息，还能通过cookie插件保存用户的浏览记录，它的调用格式为：保存：$.cookie(key，value)；读取：$.cookie(key)，删除：$.cookie(key，null)其中参数key为保存cookie对象的名称，value为名称对应的cookie值。 搜索插件——autocomplete搜索插件的功能是通过插件的autocomplete()方法与文本框相绑定，当文本框输入字符时，绑定后的插件将返回与字符相近的字符串提示选择，调用格式如下： $(textbox).autocomplete(urlData,[options]);其中，textbox参数为文本框元素名称，urlData为插件返回的相近字符串数据，可选项参数options为调用插件方法时的配置对象。 右键菜单插件——contextmenu右键菜单插件可以绑定页面中的任意元素，绑定后，选中元素，点击右键，便通过该插件弹出一个快捷菜单，点击菜单各项名称执行相应操作，调用代码如下： $(selector).contextMenu(menuId,{options});Selector参数为绑定插件的元素，meunId为快捷菜单元素，options为配置对象。 自定义对象级插件——lifocuscolor插件自定义的lifocuscolor插件可以在元素中，鼠标在表项元素移动时，自定义其获取焦点时的背景色，即定义元素选中时的背景色，调用格式为：$(Id).focusColor(color)其中，参数Id表示元素的Id号，color表示元素选中时的背景色。 自定义类级别插件—— twoaddresult通过调用自定义插件twoaddresult中的不同方法，可以实现对两个数值进行相加和相减的运算，导入插件后，调用格式分别为：$.addNum(p1,p2) 和 $.subNum(p1,p2)上述调用格式分别为计算两数值相加和相减的结果，p1和p2为任意数值。 拖曳插件——draggable拖曳插件draggable的功能是拖动被绑定的元素，当这个jQuery UI插件与元素绑定后，可以通过调用draggable()方法，实现各种拖曳元素的效果，调用格式如下：$(selector). draggable({options})options参数为方法调用时的配置对象，根据该对象可以设置各种拖曳效果，如“containment”属性指定拖曳区域，“axis”属性设置拖曳时的坐标方向。 放置插件——droppable除使用draggable插件拖曳任意元素外，还可以调用droppable UI插件将拖曳后的任意元素放置在指定区域中，类似购物车效果，调用格式如下：$(selector).droppable({options})selector参数为接收拖曳元素，options为方法的配置对象，在对象中，drop函数表示当被接收的拖曳元素完全进入接收元素的容器时，触发该函数的调用。 拖曳排序插件——sortable拖曳排序插件的功能是将序列元素（例如、）按任意位置进行拖曳从而形成一个新的元素序列，实现拖曳排序的功能，它的调用格式为：$(selector).sortable({options});selector参数为进行拖曳排序的元素，options为调用方法时的配置对象，面板折叠插件——accordion面板折叠插件可以实现页面中指定区域类似“手风琴”的折叠效果，即点击标题时展开内容，再点另一标题时，关闭已展开的内容，调用格式如下：$(selector).accordion({options});其中，参数selector为整个面板元素，options参数为方法对应的配置对象。 选项卡插件——tabs使用选项卡插件可以将中的选项定义为选项标题，在标题中，再使用元素的“href”属性设置选项标题对应的内容，它的调用格式如下：$(selector).tabs({options});selector参数为选项卡整体外围元素，该元素包含选项卡标题与内容，options参数为tabs()方法的配置对象，通过该对象还能以ajax方式加载选项卡的内容。 对话框插件——dialog对话框插件可以用动画的效果弹出多种类型的对话框，实现JavaScript代码中alert()和confirm()函数的功能，它的调用格式为：$(selector).dialog({options});selector参数为显示弹出对话框的元素，通常为，options参数为方法的配置对象，在对象中可以设置对话框类型、“确定”、“取消”按钮执行的代码等。 菜单工具插件——menu菜单工具插件可以通过创建多级内联或弹出式菜单，支持通过键盘方向键控制菜单滑动，允许为菜单的各个选项添加图标，调用格式如下：$(selector).menu({options});selector参数为菜单列表中最外层元素，options为menu()方法的配置对象。 微调按钮插件——spinner微调按钮插件不仅能在文本框中直接输入数值，还可以通过点击输入框右侧的上下按钮修改输入框的值，还支持键盘的上下方向键改变输入值，调用格式如下：$(selector).spinner({options});selector参数为文本输入框元素，可选项options参数为spinner()方法的配置对象，在该对象中，可以设置输入的最大、最小值，获取改变值和设置对应事件。 工具提示插件——tooltip工具提示插件可以定制元素的提示外观，提示内容支持变量、Ajax远程获取，还可以自定义提示内容显示的位置，它的调用格式如下：$(selector).tooltip({options});其中selector为需要显示提示信息的元素，可选项参数options为tooltip()方法的配置对象，在该对象中，可以设置提示信息的弹出、隐藏时的效果和所在位置。 获取浏览器的名称与版本信息在jQuery中，通过$.browser对象可以获取浏览器的名称和版本信息，如$.browser.chrome为true，表示当前为Chrome浏览器，$.browser.mozilla为true，表示当前为火狐浏览器，还可以通过$.browser.version方式获取浏览器版本信息。 检测浏览器是否属于W3C盒子模型浏览器的盒子模型分为两类，一类为标准的w3c盒子模型，另一类为IE盒子模型，两者区别为在Width和Height这两个属性值中是否包含padding和border的值，w3c盒子模型不包含，IE盒子模型则包含，而在jQuery 中，可以通过$.support.boxModel对象返回的值，检测浏览器是否属于标准的w3c盒子模型。检测对象是否为空 在jQuery中，可以调用名为$.isEmptyObject的工具函数，检测一个对象的内容是否为空，如果为空，则该函数返回true，否则，返回false值，调用格式如下：$.isEmptyObject(obj);其中，参数obj表示需要检测的对象名称。 检测对象是否为原始对象调用名为$.isPlainObject的工具函数，能检测对象是否为通过{}或new Object()关键字创建的原始对象，如果是，返回true，否则，返回false值，调用格式为：$.isPlainObject (obj);其中，参数obj表示需要检测的对象名称。 检测两个节点的包含关系调用名为$.contains的工具函数，能检测在一个DOM节点中是否包含另外一个DOM节点，如果包含，返回true，否则，返回false值，调用格式为：$.contains (container, contained);参数container表示一个DOM对象节点元素，用于包含其他节点的容器，contained是另一个DOM对象节点元素，用于被其他容器所包含。 字符串操作函数调用名为$.trim的工具函数，能删除字符串中左右两边的空格符，但该函数不能删除字符串中间的空格，调用格式为：$.trim (str);参数str表示需要删除左右两边空格符的字符串。 URL操作函数调用名为$. param的工具函数，能使对象或数组按照key/value格式进行序列化编码，该编码后的值常用于向服务端发送URL请求，调用格式为：$. param (obj);参数obj表示需要进行序列化的对象，该对象也可以是一个数组，整个函数返回一个经过序列化编码后的字符串使用$.extend()扩展工具函数调用名为$. extend的工具函数，可以对原有的工具函数进行扩展，自定义类级别的jQuery插件，调用格式为：$. extend ({options});参数options表示自定义插件的函数内容。使用$.extend()扩展Object对象除使用$.extend扩展工具函数外，还可以扩展原有的Object对象，在扩展对象时，两个对象将进行合并，当存在相同属性名时，后者将覆盖前者，调用格式为：$. extend (obj1,obj2,…objN);参数obj1至objN表示需要合并的各个原有对象。]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3的部分属性]]></title>
    <url>%2F2016%2F04%2F17%2Fcss-any-property-2%2F</url>
    <content type="text"><![CDATA[1、阴影box-shadow:x轴偏移量 y轴偏移量 [阴影模糊半径] [阴影扩展半径] [阴影颜色] [投影方式]注意：inset（内阴影） 可以写在参数的第一个或最后一个，其它位置是无效的实例正值表示在对象的底部，负值表示在对象的顶部。.boxshadow-outset{ width:100px;height:100px; box-shadow:4px 4px 6px blue,4px 4px 6px red inset;}.boxshadow-inset{ width:100px; height:100px; box-shadow:4px 4px 6px #666 inset;}111、阴影模糊半径与阴影扩展半径的区别阴影模糊半径：此参数可选，其值只能是为正值，如果其值为0时，表示阴影不具有模糊效果，其值越大阴影的边缘就越模糊；阴影扩展半径：此参数可选，其值可以是正负值，如果值为正，则整个阴影都延展扩大，反之值为负值时，则缩小；222、X轴偏移量和Y轴偏移量值可以设置为负数2、为边框应用图片 border-image 顾名思义就是为边框应用背景图片，它和我们常用的background属性比较相似 background:url(xx.jpg) 10px 20px no-repeat; 另有属性round、stretch。 用法：border-image:url(borderimg.png) 70 stretch3、颜色之RGBA：在RGB的基础上增加了控制alpha透明度的参数 语法color：rgba(R,G,B,A)4、渐变色彩 CSS3 Gradient 分为线性渐变(linear)和径向渐变(radial) background-image:linear-gradient(to left, red, orange,yellow,green,blue,indigo,violet);5、text-overflow 与 word-wrap text-overflow用来设置是否使用一个省略标记（…）标示对象内文本的溢出 属性clip（表示剪切）和ellipsis（表示显示省略标记） 但是text-overflow只是用来说明文字溢出时用什么方式显示，要实现溢出时 产生省略号的效果，还须定义强制文本在一行内显示（white-space:nowrap） 及溢出内容为隐藏（overflow:hidden），只有这样才能实现溢出文本显示省 略号的效果，代码如下：text-overflow:ellipsis;overflow:hidden;white-space:nowrap;同时，word-wrap也可以用来设置文本行为，当前行超过指定容器的边界时是否断开转行。属性：normal（表示控制连续文本换行）和break-word（表示内容将在边界内换行）6、嵌入字体@font-face@font-face能够加载服务器端的字体文件，让浏览器端可以显示用户电脑里没有安装的字体。@font-face { font-family : 字体名称; src : 字体文件在服务器上的相对或绝对路径;}7、文本阴影text-shadow可以设置文本的阴影效果 text-shadow: X-Offset Y-Offset（阴影的垂直偏移距离） blur（模糊程度） color（阴影的颜色）;8、background-origin设置元素背景图片的原始起始位置。 background-origin ： border-box | padding-box | content-box; 参数分别表示背景图片是从边框，还是内边距（默认值），或者是内容区域开 始显示。需要注意的是，如果背景不是no-repeat，这个属性无效，它会从边框开始显示。9、background-clip用来将背景图片做适当的裁剪以适应实际需要。 background-clip ： border-box | padding-box | content-box | no-clip 参数分别表示从边框、或内填充，或者内容区域向外裁剪背景。no-clip表示不裁切，和参数border-box显示同样的效果。backgroud-clip默认值为border-box。10、background-size设置背景图片的大小，以长度值或百分比显示，还可以通过cover和contain来对图片进行伸缩。background-size: auto | &lt;长度值&gt; | &lt;百分比&gt; | cover | contain1、auto：默认值，不改变背景图片的原始高度和宽度；2、&lt;长度值&gt;：成对出现如200px 50px，将背景图片宽高依次设置为前面两个值，当设置一个值时，将其作为图片宽度值来等比缩放；3、&lt;百分比&gt;：0％~100％之间的任何值，将背景图片宽高依次设置为所在元素宽高乘以前面百分比得出的数值，当设置一个值时同上；4、cover：顾名思义为覆盖，即将背景图片等比缩放以填满整个容器；5、contain：容纳，即将背景图片等比缩放至某一边紧贴容器边缘为止。11、multiple backgrounds多重背景，也就是CSS2里background的属性外加origin、clip和size组成的新background的多次叠加，缩写时为用逗号隔开的每组值；用分解写法时，如果有多个背景图片，而其他属性只有一个（例如background-repeat只有一个），表明所有背景图片应用该属性值。background ： [background-color] | [background-image] | [background-position][/background-size] | [background-repeat] | [background-attachment] | [background-clip] | [background-origin],…12、属性选择器我链接的是PDF文件我类名是icon我的title是morecss代码a[class^=icon]{ background: green; color:#fff;}a[href$=pdf]{ background: orange; color: #fff;}a[title*=more]{ background: blue; color: #fff;}13、结构性伪类选择器–root：:root选择器，从字面上我们就可以很清楚的理解是根选择器，他的意思就是匹配元素E所在文档的根元素。在HTML文档中，根元素始终是。“:root”选择器等同于元素，简单点说：:root{background:orange}==html {background:orange;}14、结构性伪类选择器—not:not选择器称为否定选择器，和jQuery中的:not选择器一模一样，可以选择除某个元素之外的所有元素。就拿form元素来说，比如说你想给表单中除submit按钮之外的input元素添加红色边框，CSS代码可以写成：form { width: 200px; margin: 20px auto;}div { margin-bottom: 20px;}input:not([type=”submit”]){ border:1px solid red;}15、结构性伪类选择器—empty:empty选择器表示的就是空。用来选择没有任何内容的元素，这里没有内容指的是一点内容都没有，哪怕是一个空格。比如说，你的文档中有三个段落p元素，你想把没有任何内容的P元素隐藏起来。我们就可以使用“:empty”选择器来控制。HTML代码： 我是一个段落 ?CSS代码：p{ background: orange; min-height: 30px;}p:empty { display: none;}?16、结构性伪类选择器—target:target选择器称为目标选择器，用来匹配文档(页面)的url的某个标志符的目标元素。我们先来上个例子，然后再做分析。示例展示点击链接显示隐藏的段落。HTML代码： Brand content for BrandCSS代码：.menuSection{ display: none;}:target{/这里的:target就是指id=”brand”的div对象/ display:block;}17、结构性伪类选择器—first-child“:first-child”选择器表示的是选择父元素的第一个子元素的元素E。简单点理解就是选择元素中的第一个子元素，记住是子元素，而不是后代元素。18、结构性伪类选择器—last-child“:last-child”选择器与“:first-child”选择器作用类似，不同的是“:last-child”选择器选择的是元素的最后一个子元素。19、结构性伪类选择器—nth-child(n)“:nth-child(n)”选择器用来定位某个父元素的一个或多个特定的子元素。其中“n”是其参数，而且可以是整数值(1,2,3,4)，也可以是表达式(2n+1、-n+5)和关键词(odd、even)，但参数n的起始值始终是1，而不是0。也就是说，参数n的值为0时，选择器将选择不到任何匹配的元素。20、结构性伪类选择器—nth-last-child(n)“:nth-last-child(n)”选择器和前面的“:nth-child(n)”选择器非常的相似，只是这里多了一个“last”，所起的作用和“:nth-child(n)”选择器有所区别，从某父元素的最后一个子元素开始计算，来选择特定的元素。21、first-of-type选择器“:first-of-type”选择器类似于“:first-child”选择器，不同之处就是指定了元素的类型,其主要用来定位一个父元素下的某个类型的第一个子元素。22、nth-of-type(n)选择器“:nth-of-type(n)”选择器和“:nth-child(n)”选择器非常类似，不同的是它只计算父元素中指定的某种类型的子元素。当某个元素中的子元素不单单是同一种类型的子元素时，使用“:nth-of-type(n)”选择器来定位于父元素中某种类型的子元素是非常方便和有用的。在“:nth-of-type(n)”选择器中的“n”和“:nth-child(n)”选择器中的“n”参数也一样，可以是具体的整数，也可以是表达式，还可以是关键词n的参数也可以为odd 和 even 是可用于匹配下标��奇数或偶数的子元素的关键词23、last-of-type选择器“:last-of-type”选择器和“:first-of-type”选择器功能是一样的，不同的是他选择是父元素下的某个类型的最后一个子元素24、nth-last-of-type(n)选择器“:nth-last-of-type(n)”选择器和“:nth-of-type(n)”选择器是一样的，选择父元素中指定的某种子元素类型，但它的起始方向是从最后一个子元素开始，而且它的使用方法类似于上节中介绍的“:nth-last-child(n)”选择器一样。25、only-child选择器“:only-child”选择器选择的是父元素中只有一个子元素，而且只有唯一的一个子元素。也就是说，匹配的元素的父元素中仅有一个子元素，而且是一个唯一的子元素。26、only-of-type选择器“:only-of-type”选择器用来选择一个元素是它的父元素的唯一一个相同类型的子元素。这样说或许不太好理解，换一种说法。“:only-of-type”是表示一个元素他有很多个子元素，而其中只有一种类型的子元素是唯一的，使用“:only-of-type”选择器就可以选中这个元素中的唯一一个类型子元素。27、:enabled选择器在Web的表单中，有些表单元素有可用（“:enabled”）和不可用（“:disabled”）状态，比如输入框，密码框，复选框等。在默认情况之下，这些表单元素都处在可用状态。那么我们可以通过伪选择器“:enabled”对这些表单元素设置样式。28、:disabled选择器“:disabled”选择器刚好与“:enabled”选择器相反，用来选择不可用表单元素。要正常使用“:disabled”选择器，需要在表单元素的HTML中设置“disabled”属性。29、:checked选择器在表单元素中，单选按钮和复选按钮都具有选中和未选中状态。（大家都知道，要覆写这两个按钮默认样式比较困难）。在CSS3中，我们可以通过状态选择器“:checked”配合其他标签实现自定义样式。而“:checked”表示的是选中状态。30、::selection选择器“::selection”伪元素是用来匹配突出显示的文本(用鼠标选择文本时的文本)。浏览器默认情况下，用鼠标选择网页文本是以“深蓝的背景，白色的字体”显示的，效果如下图所示：31、:read-only选择器“:read-only”伪类选择器用来指定处于只读状态元素的样式。简单点理解就是，元素中设置了“readonly=’readonly’32、:read-write选择器“:read-write”选择器刚好与“:read-only”选择器相反，主要用来指定当元素处于非只读状态时的样式。33、::before和::after::before和::after这两个主要用来给元素的前面或后面插入内容，这两个常和”content”配合使用，使用的场景最多的就是清除浮动。34、变形–旋转 rotate()旋转rotate()函数通过指定的角度参数使元素相对原点进行旋转。它主要在二维空间内进行操作，设置一个角度值，用来指定旋转的幅度。如果这个值为正值，元素相对原点中心顺时针旋转；如果这个值为负值，元素相对原点中心逆时针旋转35、变形–旋转 rotate()旋转rotate()函数通过指定的角度参数使元素相对原点进行旋转。它主要在二维空间内进行操作，设置一个角度值，用来指定旋转的幅度。如果这个值为正值，元素相对原点中心顺时针旋转；如果这个值为负值，元素相对原点中心逆时针旋转。36、变形–扭曲 skew()扭曲skew()函数能够让元素倾斜显示。它可以将一个对象以其中心位置围绕着X轴和Y轴按照一定的角度倾斜。这与rotate()函数的旋转不同，rotate()函数只是旋转，而不会改变元素的形状。skew()函数不会旋转，而只会改变元素的形状。1、skew(x,y)使元素在水平和垂直方向同时扭曲2、skewX(x)仅使元素在水平方向扭曲变形（X轴扭曲变形）3、skewY(y)仅使元素在垂直方向扭曲变形（Y轴扭曲变形）37、变形–缩放 scale()缩放 scale()函数 让元素根据中心原点对对象进行缩放1、 scale(X,Y)使元素水平方向和垂直方向同时缩放。若只有一个参数，则xy同时缩放2、scaleX(x)元素仅水平方向缩放（X轴缩放）3、scaleY(y)元素仅垂直方向缩放（Y轴缩放）38、变形–位移 translate()translate()函数可以将元素向指定的方向移动，类似于position中的relative。或以简单的理解为，使用translate()函数，可以把元素从原来的位置移动，而不影响在X、Y轴上的任何Web组件。1、translate(x,y)水平方向和垂直方向同时移动2、translateX(x)仅水平方向移动（X轴移动）3、translateY(Y)仅垂直方向移动（Y轴移动）39、变形–矩阵 matrix()matrix() 是一个含六个值的(a,b,c,d,e,f)变换矩阵，用来指定一个2D变换，相当于直接应用一个[a b c d e f]变换矩阵。就是基于水平方向（X轴）和垂直方向（Y轴）重新定位元素,此属性值使用涉及到数学中的矩阵，我在这里只是简单的说一下CSS3中的transform有这么一个属性值，如果需要深入了解，需要对数学矩阵有一定的知识。40、变形–原点 transform-origin在没有重置transform-origin改变元素原点位置的情况下，CSS变形进行的旋转、位移、缩放，扭曲等操作都是以元素自己中心位置进行变形。但很多时候，我们可以通过transform-origin来对元素进行原点位置改变，使元素原点不在元素的中心位置，以达到需要的原点位置。对于x轴的调整：left|center|right对于y轴的调整：top|center|bottom对于z轴的调整：length px41、动画–过渡属性 transition-property早期在Web中要实现动画效果，都是依赖于JavaScript或Flash来完成。但在CSS3中新增加了一个新的模块transition，它可以通过一些简单的CSS事件来触发元素的外观变化，让效果显得更加细腻。简单点说，就是通过鼠标的单击、获得焦点，被点击或对元素任何改变中触发，并平滑地以动画效果改变CSS的属性值。在CSS中创建简单的过渡效果可以从以下几个步骤来实现：第一，在默认样式中声明元素的初始状态样式；第二，声明过渡元素最终状态样式，比如悬浮状态；第三，在默认样式中通过添加过渡函数，添加一些不同的样式。CSS3的过度transition:属性名称|过渡所用时间|过渡模式:，主要包括以下几个子属性：transition-property:none/all/某一属性名称指定过渡或动态模拟的CSS属性transition-duration:指定完成过渡所需的时间transition-duration属性主要用来设置一个属性过渡到另一个属性所需的时间，也就是从旧属性过渡到新属性花费的时间长度，俗称持续时间。transition-timing-function:指定过渡函数，transition-timing-function：ease(缓慢开始，缓慢结束)|linear(匀速)|ease-in(缓慢开始)|ease-out(缓慢结束)|ease-in-out(缓慢开始，缓慢结束)。默认easetransition-delay:指定开始出现的延迟时间，transition-delay属性和transition-duration属性极其类似，不同的是transition-duration是用来设置过渡动画的持续时间，而transition-delay主要用来指定一个动画开始执行的时间，也就是说当改变元素属性值后多长时间开始执行。有时我们想改变两个或者多个css属性的transition效果时，只要把几个transition的声明串在一起，用逗号（“，”）隔开，然后各自可以有各自不同的延续时间和其时间的速率变换方式。但需要值得注意的一点：第一个时间的值为 transition-duration，第二个为transition-delay。42、Keyframes介绍Keyframes被称为关键帧，其类似于Flash中的关键帧。在CSS3中其主要以“@keyframes”开头，后面紧跟着是动画名称加上一对花括号“{…}”，括号中就是一些不同时间段样式规则。@keyframes changecolor{ 0%{ background: red; } 100%{ background: green; }}在一个“@keyframes”中的样式规则可以由多个百分比构成的，如在“0%”到“100%”之间创建更多个百分比，分别给每个百分比中给需要有动画效果的元素加上不同的样式，从而达到一种在不断变化的效果。经验与技巧：在@keyframes中定义动画名称时，其中0%和100%还可以使用关键词from和to来代表，其中0%对应的是from，100%对应的是to。aniamtion:name|duration|timing-function|delay|iteration-count|direction|play-state|fill-mode43、调用动画animation-name属性主要是用来调用 @keyframes 定义好的动画。需要特别注意: animation-name 调用的动画名需要和“@keyframes”定义的动画名称完全一致（区分大小写），如果不一致将不具有任何动画效果。语法：animation-name: none | IDENT[,none|DENT];44、设置动画播放时间animation-duration主要用来设置CSS3动画播放时间，其使用方法和transition-duration类似，是用来指定元素播放动画所持续的时间长，也就是完成从0%到100%一次动画所需时间。单位：S秒语法规则animation-duration: [,]取值为数值，单位为秒，其默认值为“0”，这意味着动画周期为“0”，也就是没有动画效果（如果值为负值会被视为“0”）。45、设置动画播放方式animation-timing-function属性主要用来设置动画播放方式。主要让元素根据时间的推进来改变属性值的变换速率，简单点说就是动画的播放方式。语法规则：animation-timing-function:ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(, , , ) [, ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(, , , )]它和transition中的transition-timing-function一样，具有以下几种变换方式：ease,ease-in,ease-in-out,ease-out,linear和cubic-bezier。对应功如下：46、设置动画开始播放的时间animation-delay属性用来定义动画开始播放的时间，用来触发动画播放的时间点。和transition-delay属性一样，用于定义在浏览器开始执行动画之前等待的时间。语法规则：animation-delay:[,]47、设置动画播放次数animation-iteration-count属性主要用来定义动画的播放次数。语法规则：animation-iteration-count: infinite | [, infinite | ]1、其值通常为整数，但也可以使用带有小数的数字，其默认值为1，这意味着动画将从开始到结束只播放一次。2、如果取值为infinite，动画将会无限次的播放注意：Chrome或Safari浏览器，需要加入-webkit-前缀！48、设置动画播放方向（需加前缀）animation-direction属性主要用来设置动画播放方向，其语法规则如下：animation-direction:normal | alternate [, normal | alternate]其主要有两个值：normal、alternate1、normal是默认值，如果设置为normal时，动画的每次循环都是向前播放；2、另一个值是alternate，他的作用是，动画播放在第偶数次向前播放，第奇数次向反方向播放。49、设置动画的播放状态animation-play-state属性主要用来控制元素动画的播放状态。参数：其主要有两个值：running和paused。其中running是其默认值，主要作用就是类似于音乐播放器一样，可以通过paused将正在播放的动画停下来，也可以通过running将暂停的动画重新播放，这里的重新播放不一定是从元素动画的开始播放，而是从暂停的那个位置开始播放。另外如果暂停了动画的播放，元素的样式将回到最原始设置状态。50、设置动画时间外属性animation-fill-mode属性定义在动画开始之前和结束之后发生的操作。主要具有四个属性值：none、forwards、backwords和both。其四个属性值对应效果如下：none：默认值，表示动画将按预期进行和结束，在动画完成其最后一帧时，动画会反转到初始帧forwards：表示动画在结束后继续应用最后的关键帧的位置backwards：会在向元素应用动画样式时迅速应用动画的初始帧both：元素动画同时具有forwards和backwards效果在默认情况之下，动画不会影响它的关键帧之外的属性，使用animation-fill-mode属性可以修改动画的默认行为。简单的说就是告诉动画在第一关键帧上等待动画开始，或者在动画结束时停在最后一个关键帧上而不回到动画的第一帧上。或者同时具有这两个效果。51、多列布局——Columns为了能在Web页面中方便实现类似报纸、杂志那种多列排版的布局，W3C特意给CSS3增加了一个多列布局模块（CSS Multi Column Layout Module）。它主要应用在文本的多列布局方面，这种布局在报纸和杂志上都使用了几十年了，但要在Web页面上实现这样的效果还是有相当大的难度，庆幸的是，CSS3的多列布局可以轻松实现。接下来咱们一起学习多列布局相关的知识。语法：columns： || 52、多列布局——column-widthcolumn-width的使用和CSS中的width属性一样，不过不同的是，column-width属性在定义元素列宽的时候，既可以单独使用，也可以和多列属性中其他属性配合使用。其基本语法如下所示：column-width: auto | 53、多列布局——column-countcolumn-count属性主要用来给元素指定想要的列数和允许的最大列数。其语法规则：column-count：auto | 54、列间距column-gapcolumn-gap主要用来设置列与列之间的间距，其语法规则如下：column-gap: normal || 注意：normal默认值为1em，如果你的字号是px，则默认值为字体的大小55、列表边框column-rulecolumn-rule主要是用来定义列与列之间的边框宽度、边框样式和边框颜色。简单点说，就有点类似于常用的border属性。但column-rule是不占用任何空间位置的，在列与列之间改变其宽度不会改变任何列的位置。语法规则：column-rule:||三个属性类似于border的属性56、跨列设置column-spancolumn-span主要用来定义一个分列元素中的子元素能跨列多少。column-width、column-count等属性能让一元素分成多列，不管里面元素如何排放顺序，他们都是从左向右的放置内容，但有时我们需要基中一段内容或一个标题不进行分列，也就是横跨所有列，此时column-span就可以轻松实现，此属性的语法如下：column-span: none | all 注意：none为默认值，表示不跨越任何列，all表示跨越所有列57、盒模型在CSS3中新增加了box-sizing属性，能够事先定义盒模型的尺寸解析方式，其语法规则如下：box-sizing: content-box | border-box | inheritcontent-box：默认值，其让元素维持W3C的标准盒模型，也就是说元素的宽度和高度（width/height）等于元素边框宽度（border）加上元素内距（padding）加上元素内容宽度或高度（content width/ height），也就是element width/height = border + padding + content width / heightborder-box：重新定义CSS2.1中盒模型组成的模式，让元素维持IE传统的盒模型（IE6以下版本和IE6-7怪异模式），也就是说元素的宽度或高度等于元素内容的宽度或高度。从上面盒模型介绍可知，这里的内容宽度或高度包含了元素的border、padding、内容的宽度或高度（此处的内容宽度或高度＝盒子的宽度或高度—边框—内距）。inherit：使元素继承父元素的盒模型模式58、伸缩布局（一）CSS3引入了一种新的布局模式——Flexbox布局，即伸缩布局盒模型（Flexible Box），用来提供一个更加有效的方式制定、调整和分布一个容器里项目布局，即使它们的大小是未知或者动态的，这里简称为Flex。Flexbox布局常用于设计比较复杂的页面，可以轻松的实现屏幕和浏览器窗口大小发生变化时保持元素的相对位置和大小不变，同时减少了依赖于浮动布局实现元素位置的定义以及重置元素的大小。Flexbox布局在定义伸缩项目大小时伸缩容器会预留一些可用空间，让你可以调节伸缩项目的相对大小和位置。例如，你可以确保伸缩容器中的多余空间平均分配多个伸缩项目，当然，如果你的伸缩容器没有足够大的空间放置伸缩项目时，浏览器会根据一定的比例减少伸缩项目的大小，使其不溢出伸缩容器。综合而言，Flexbox布局功能主要具有以下几点：第一，屏幕和浏览器窗口大小发生改变也可以灵活调整布局；第二，可以指定伸缩项目沿着主轴或侧轴按比例分配额外空间（伸缩容器额外空间），从而调整伸缩项目的大小；第三，可以指定伸缩项目沿着主轴或侧轴将伸缩容器额外空间，分配到伸缩项目之前、之后或之间；第四，可以指定如何将垂直于元素布局轴的额外空间分布到该元素的周围；第五，可以控制元素在页面上的布局方向；第六，可以按照不同于文档对象模型（DOM）所指定排序方式对屏幕上的元素重新排序。也就是说可以在浏览器渲染中不按照文档流先后顺序重排伸缩项目顺序。Flexbox规范版本众多，浏览器对此语法支持度也各有不同，接下来的内容以最新语法版本为例向大家展1.创建一个flex容器任何一个flexbox布局的第一步是需要创建一个flex容器。为此给元素设置display属性的值为flex。在Safari浏览器中，你依然需要添加前缀-webkit，.flexcontainer{ display: -webkit-flex; display: flex; }2.Flex项目显示Flex项目是Flex容器的子元素。他们沿着主要轴和横轴定位。默认的是沿着水平轴排列一行。你可以通过flex-direction来改变主轴方向修改为column，其默认值是row。4.Flex项目移动到顶部如何将flex项目移动到顶部，取决于主轴的方向。如果它是垂直的方向通过align-items设置；如果它是水平的方向通过justify-content设置。5.Flex项目移到左边flex项目称动到左边或右边也取决于主轴的方向。如果flex-direction设置为row，设置justify-content控制方向；如果设置为column，设置align-items控制方向。-webkit-align-items: flex-start/flex-end/center;8.Flex项目实现自动伸缩您可以定义一个flex项目，如何相对于flex容器实现自动的伸缩。需要给每个flex项目设置flex属性设置需要伸缩的值。.bigitem{ -webkit-flex:200; flex:200; } .smallitem{ -webkit-flex:100; flex:100; }59、Media Queries——媒体类型（一）随着科学技术不断的向前发展，网页的浏览终端越来越多样化，用户可以通过：宽屏电视、台式电脑、笔记本电脑、平板电脑和智能手机来访问你的网站。尽管你无法保证一个网站在不同屏幕尺寸和不同设备上看起来完全一模一样，但至少要让你的Web页面能适配用户的终端，让他更好的呈现在你的用户面前。在本节中，将会学到如何使用CSS3中的Media Queries模块来让一个页面适应不同的终端（或屏幕尺寸），从而让你的页面让用户有一个更好的体验。一、媒体类型媒体类型（Media Type）在CSS2中是一个常见的属性，也是一个非常有用的属性，可以通过媒体类型对不同的设备指定不同的样式。见图片见素材/图片60、responsive布局技巧方法。你首先禁掉你页面中所有的样式（以及与样式相关的信息），在浏览器中打开，如果你的内容排列有序，方便阅读，那么你的这个结构不会差到哪里去。61、自由缩放属性resizeresize属性主要是用来改变元素尺寸大小的，其主要目的是增强用户体验。但使用方法却是极其的简单，先从其语法入手。resize: none | both | horizontal | vertical | inheritnone用户不能拖动元素尺寸大小，both用户可以拖动元素，同时可以修改元素的宽度和高度，horizontal用户可以拖放元素，仅可以修改元素的宽度，但不能修改元素的高度，vertical用户可以拖放元素，尽可以修改元素的高度，但不能修改元素的宽度，inherit继承父元素的属性值62、CSS3外轮廓属性外轮廓outline在页面中呈现的效果和边框border呈现的效果极其相似，但和元素边框border完全不同，外轮廓线不占用网页布局空间，不一定是矩形，外轮廓是属于一种动态样式，只有元素获取到焦点或者被激活时呈现。outline属性早在CSS2中就出现了，主要是用来在元素周围绘制一条轮廓线，可以起到突出元素的作用。但是并未得到各主流浏览器的广泛支持，在CSS3中对outline作了一定的扩展，在以前的基础上增加新特性。outline属性的基本语法如下：outline: ［outline-color］ || [outline-style] || [outline-width] || [outline-offset] || inherit从语法中可以看出outline和border边框属性的使用方法极其类似。outline-color相当于border-color、outline-style相当于border-style，而outline-width相当于border-width，只不过CSS3给outline属性增加了一个outline-offset属性outline-color：定义轮廓线的颜色，属性值为CSS中定义的颜色值。在实际应用中，可以将此参数省略，省略时此参数的默认值为黑色。outline-style：定义轮廓线的样式，属性为CSS中定义线的样式。在实际应用中，可以将此参数省略，省略时此参数的默认值为none，省略后不对该轮廓线进行任何绘制。outline-width：定义轮廓线的宽度，属性值可以为一个宽度值。在实际应用中，可以将此参数省略，省略时此参数的默认值为medium，表示绘制中等宽度的轮廓线。outline-offset：定义轮廓边框的偏移位置的数值，此值可以取负数值。当此参数的值为正数值，表示轮廓边框向外偏离多少个像素；当此参数的值为负数值，表示轮廓边框向内偏移多少个像素。inherit：元素继承父元素的outline效果。63、CSS生成内容在Web中插入内容，在CSS2.1时代依靠的是JavaScript来实现。但进入CSS3进代之后我们可以通过CSS3的伪类“:before”，“:after”和CSS3的伪元素“::before”、“::after”来实现，其关键是依靠CSS3中的“content”属性来实现。不过这个属性对于img和input元素不起作用。content配合CSS的伪类或者伪元素，一般可以做以下四件事情：none：不生成任何内容attr：插入标签属性值url：使用指定的绝对或相对地址插入一个外部资源（图像，声频，视频或浏览器支持的其他任何资源）string：插入字符串在CSS中有一种清除浮动的方法叫“clearfix”64、CSS3 perspective 属性定义3D元素距视图的距离，以像素计。该属性允许你改变3D元素查看3D元素的试图，当为元素定义perspective属性是，其子元素会获得透视效果，而不是元素本身。注释：perspective 属性只影响 3D 转换元素。perspective: number|none;65、CSS3 transform-style 属性transform-style 属性规定如何在 3D 空间中呈现被嵌套的元素。注释：该属性必须与 transform 属性一同使用。transform-style: flat|preserve-3d;flat子元素将不保留3D位置，preserve-3d子元素将保留其3D位置66、CSS3 transform 属性transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜translate系列单位是px， rotate系列单位是deg;translate和rotate顺序不同，效果也会不同transform-origin属性定义变形的原点，默认是文件的中心。可以使用这个属性来改变变形的原点。67、CSS vertical-align 属性vertical-align 属性设置元素的垂直对齐方式。68、CSS strong 属性用于强调，和标签一样，用于强调文本，但它强调的程度更强一下。通常使用加粗的字体来显示其中的内容69、CSS display 属性display属性规定元素应该生成的框的类型。这个属性用于定义建立布局时元素生成的显示框类型。对于 HTML 等文档类型，如果使用 display 不谨慎会很危险，因为可能违反 HTML 中已经定义的显示层次结构。对于 XML，由于 XML 没有内置的这种层次结构，所有 display 是绝对必要的。70、CSS 属性cursor:指示鼠标到达元素时的鼠标形态71、font-smoothing属性css3种用于设置字体的抗锯齿或者光滑度的属性语法规则：font-smoothing:subpixel-antialiased(浏览器默认)|none(小像素文本)|antialiased(反锯齿)72、如何隐藏一个元素，使其不可见display:none;position:absolute;left:-999999px;visibility:hidden;opacity:0opacity设置div元素的不透明级别。opacity: value(0.0完全透明-1.0完全不透明)|inherit(父类继承);73、backface-visibility:定义当元素不面向屏幕是是否可见backface-visibility:visible(背面是可见的)|hidden(背面是不可见的);74、@font-face是css中的一个模块，主要用于将自己定义的web字体嵌入网页中@font-face { font-family: ; src: [][, []]*; [font-weight: ]; [font-style: ]; }取值说明1、YourWebFontName:此值指的就是你自定义的字体名称，最好是使用你下载的默认字体，他将被引用到你的Web元素中的font-family。如“font-family:”YourWebFontName”;”2、source:此值指的是你自定义的字体的存放路径，可以是相对路径也可以是绝路径；3、format：此值指的是你自定义的字体的格式，主要用来帮助浏览器识别，其值主要有以下几种类型：truetype,opentype,truetype-aat,embedded-opentype,avg等；4、weight和style:这两个值大家一定很熟悉，weight定义字体是否为粗体，style主要定义字体样式，如斜体。css shake: 具体样式： 75、box-sizing属性允许您以特定的方式定义匹配某个区域的特定元素。box-sizing: content-box|border-box|inherit;content-box:这是由 CSS2.1 规定的宽度高度行为。宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。border-box:为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。inherit 规定应从父元素继承 box-sizing 属性的值。]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1006不容易系列之(3)—— LELE的RPG难题]]></title>
    <url>%2F2014%2F03%2F25%2FHDU1006-3%2F</url>
    <content type="text"><![CDATA[Problem Description人称“AC女之杀手”的超级偶像LELE最近忽然玩起了深沉，这可急坏了众多“Cole”（LELE的粉丝,即”可乐”）,经过多方打探，某资深Cole终于知道了原因，原来，LELE最近研究起了著名的RPG难题:有排成一行的ｎ个方格，用红(Red)、粉(Pink)、绿(Green)三色涂每个格子，每格涂一色，要求任何相邻的方格不能同色，且首尾两格也不同色．求全部的满足要求的涂法.以上就是著名的RPG难题.如果你是Cole,我想你一定会想尽办法帮助LELE解决这个问题的;如果不是,看在众多漂亮的痛不欲生的Cole女的面子上,你也不会袖手旁观吧?Input输入数据包含多个测试实例,每个测试实例占一行,由一个整数N组成，(0&lt;n&lt;=50)。Output对于每个测试实例，请输出全部的满足要求的涂法，每个实例的输出占一行。Sample Input 12 Sample Output 36 #include &lt;stdio.h> int main() { int n; __int64 m[60]={0,3,6,6}; for(int i=4;i&lt;=50;i++) m[i]=m[i-1]+m[i-2]*2; while(scanf("%d",&amp;n)!=EOF) { printf("%I64d\n",m[n]); } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1005不容易系列之一]]></title>
    <url>%2F2014%2F03%2F25%2FHDU1005%2F</url>
    <content type="text"><![CDATA[Problem Description大家常常感慨，要做好一件事情真的不容易，确实，失败比成功容易多了！做好“一件”事情尚且不易，若想永远成功而总从不失败，那更是难上加难了，就像花钱总是比挣钱容易的道理一样。话虽这样说，我还是要告诉大家，要想失败到一定程度也是不容易的。比如，我高中的时候，就有一个神奇的女生，在英语考试的时候，竟然把40个单项选择题全部做错了！大家都学过概率论，应该知道出现这种情况的概率，所以至今我都觉得这是一件神奇的事情。如果套用一句经典的评语，我们可以这样总结：一个人做错一道选择题并不难，难的是全部做错，一个不对。不幸的是，这种小概率事件又发生了，而且就在我们身边：事情是这样的——HDU有个网名叫做8006的男性同学，结交网友无数，最近该同学玩起了浪漫，同时给n个网友每人写了一封信，这都没什么，要命的是，他竟然把所有的信都装错了信封！注意了，是全部装错哟！现在的问题是：请大家帮可怜的8006同学计算一下，一共有多少种可能的错误方式呢？Input输入数据包含多个多个测试实例，每个测试实例占用一行，每行包含一个正整数n（1&lt;n&lt;=20），n表示8006的网友的人数。Output对于每行输入请输出可能的错误方式的数量，每个实例的输出占用一行。Sample Input 23 Sample Output12 #include&lt;iostream> #include &lt;stdio.h> using namespace std; long long int fun(int n) { long long int m; if(n&lt;=3) m=n-1; else m=(n-1)*(fun(n-1)+fun(n-2)); return m; } int main() { int n; long long int fun(int); while(scanf("%d",&amp;n)!=EOF) { cout&lt;&lt;fun(n)&lt;&lt;endl; } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1004超级楼梯]]></title>
    <url>%2F2014%2F03%2F25%2FHDU1004%2F</url>
    <content type="text"><![CDATA[Problem Description有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？Input输入数据首先包含一个整数N，表示测试实例的个数，然后是N行数据，每行包含一个整数M（1&lt;=M&lt;=40）,表示楼梯的级数。Output对于每个测试实例，请输出不同走法的数量Sample Input 223 Sample Output12 #include&lt;iostream> #include &lt;stdio.h> using namespace std; int main() { int n; int fun(int n); scanf("%d",&amp;n); int i,k; for(i=0;i&lt;n;i++) { scanf("%d",&amp;k); long long int m[50]={0,0,1,2}; if(k&lt;=3) { m[k]=k-1; cout&lt;&lt;m[k]&lt;&lt;endl; } else { for(int i=4;i&lt;=k;i++) { m[4]=m[3]+m[2]; m[2]=m[3]; m[3]=m[4]; } cout&lt;&lt;m[4]&lt;&lt;endl; } } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1003母牛的故事]]></title>
    <url>%2F2014%2F03%2F25%2FHDU1003%2F</url>
    <content type="text"><![CDATA[Problem Description有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？ Input输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。n=0表示输入数据的结束，不做处理。Output对于每个测试实例，输出在第n年的时候母牛的数量。每个输出占一行。Sample Input 2450 Sample Output 246 #include &lt;iostream> using namespace std; int fun(int n) { if(n&lt;=4) return n; else return (fun(n-1)+fun(n-3)); } int main() { int n; int fun(int n); while(cin>>n&amp;&amp;n!=0) { int m; m=fun(n); cout&lt;&lt;m&lt;&lt;endl; } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1002蟠桃记]]></title>
    <url>%2F2014%2F03%2F25%2FHDU1002%2F</url>
    <content type="text"><![CDATA[Problem Description喜欢西游记的同学肯定都知道悟空偷吃蟠桃的故事，你们一定都觉得这猴子太闹腾了，其实你们是有所不知：悟空是在研究一个数学问题！什么问题？他研究的问题是蟠桃一共有多少个！不过，到最后，他还是没能解决这个难题，呵呵^-^当时的情况是这样的：第一天悟空吃掉桃子总数一半多一个，第二天又将剩下的桃子吃掉一半多一个，以后每天吃掉前一天剩下的一半多一个，到第n天准备吃的时候只剩下一个桃子。聪明的你，请帮悟空算一下，他第一天开始吃的时候桃子一共有多少个呢？Input输入数据有多组，每组占一行，包含一个正整数n（1&lt;n&lt;30），表示只剩下一个桃子的时候是在第n天发生的。Output对于每组输入数据，输出第一天开始吃的时候桃子的总数，每个测试实例占一行。Sample Input 24 Sample Output422 #include &lt;iostream> using namespace std; int fun(int n) { int m; if(n==2) return 4; else return ((fun(n-1)+1)*2); } int main() { int n; while(cin>>n&amp;&amp;n>1&amp;&amp;n&lt;30) { int m; m=fun(n); cout&lt;&lt;m&lt;&lt;endl; } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭电1007FatMouse' Trade]]></title>
    <url>%2F2014%2F03%2F20%2Foj-1007%2F</url>
    <content type="text"><![CDATA[Problem DescriptionFatMouse prepared M pounds of cat food, ready to trade with the cats guarding the warehouse containing his favorite food, JavaBean.The warehouse has N rooms. The i-th room contains J[i] pounds of JavaBeans and requires F[i] pounds of cat food. FatMouse does not have to trade for all the JavaBeans in the room, instead, he may get J[i] a% pounds of JavaBeans if he pays F[i] a% pounds of cat food. Here a is a real number. Now he is assigning this homework to you: tell him the maximum amount of JavaBeans he can obtain.InputThe input consists of multiple test cases. Each test case begins with a line containing two non-negative integers M and N. Then N lines follow, each contains two non-negative integers J[i] and F[i] respectively. The last test case is followed by two -1’s. All integers are not greater than 1000.OutputFor each test case, print in a single line a real number accurate up to 3 decimal places, which is the maximum amount of JavaBeans that FatMouse can obtain.Sample Input 5 37 24 35 220 325 1824 1515 10-1 -1 Sample Output13.33331.500 #include&lt;iostream> #include&lt;stdio.h> #include&lt;stdlib.h> using namespace std; struct num1 { double a; double b; double c; }num[10001]; int Compare(const void *a, const void *b) { struct num1 *p,*q; p=(num1 *)a; q=(num1 *)b; if(p->c&lt;q->c) return 1; else if(p->c>q->c) return -1; else return 0; } int main() { int n,i,m; while(scanf("%d%d",&amp;n,&amp;m)) { if(m==-1&amp;&amp;n==-1) break; double sum=0.0; for(i=0;i&lt;m;i++) { scanf("%lf%lf",&amp;num[i].a,&amp;num[i].b); num[i].c=(num[i].a)/(num[i].b); } qsort(num,m,sizeof(num[0]),Compare); for(i=0;i&lt;m&amp;&amp;n>0;i++) { if(n&lt;num[i].b) num[i].a=num[i].c*n; sum=sum+num[i].a; n=(double)(n-num[i].b); } printf("%.3lf\n",sum); } return 0; } //数组排序太慢，注意compare的排序。]]></content>
      <categories>
        <category>算法</category>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭电1008（坑）]]></title>
    <url>%2F2014%2F03%2F19%2Foj-1008%2F</url>
    <content type="text"><![CDATA[注意格式 Problem DescriptionTomorrow is contest day, Are you all ready?We have been training for 45 days, and all guys must be tired.But , you are so lucky comparing with many excellent boys who have no chance to attend the Province-Final.Now, your task is relaxing yourself and making the last practice. I guess that at least there are 2 problems which are easier than this problem.what does this problem describe?Give you a positive integer, please split it to some prime numbers, and you can got it through sample input and sample output.InputInput file contains multiple test case, each case consists of a positive integer n(1&lt;n&lt;65536), one per line. a negative terminates the input, and it should not to be processed. OutputFor each test case you should output its factor as sample output (prime factor must come forth ascending ), there is a blank line between outputs. Sample Input 6012-1 Sample Output Case 1.2 2 3 1 5 1 Case 2.2 2 3 1 #include&lt;stdio.h> int main() { int n,i,j=1; while(scanf("%d",&amp;n)&amp;&amp;n>0) { int a[65537]={0}; if(j>1) printf("\n"); printf("Case %d.\n",j); j=j+1; for(i=2;n!=1;) { if(n%i==0) { a[i]=a[i]+1; n=n/i; } else i++; } int p=i; for(i=2;i&lt;=p;i++) { if(a[i]!=0) { printf("%d %d ",i,a[i]); } } printf("\n"); } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oj链表第一题]]></title>
    <url>%2F2014%2F03%2F17%2Foj-linked-list%2F</url>
    <content type="text"><![CDATA[#include &lt;iostream> using namespace std; struct link { int num; link *next; }; link *creat(void) { int n; cin>>n; link *p1,*p2,*head; head=NULL; p1=new link; head=p1; for(int i=0;i&lt;n;i++) { cin>>p1->num; p2=p1; p1=new link; p2->next=p1; } p2->next=NULL; return head; } link *daozhi(link *head) { link *p,*q,*r; p=head; q=r=NULL; while(p) { q=p->next; p->next=r; r=p; p=q; } return r; } void print(link *head) { link *p; p=head; while(p) { cout&lt;&lt;p->num&lt;&lt;" "; p=p->next; } cout&lt;&lt;endl; } int main() { link *creat(void); link *daozhi(link *head); void print(link *head); link *head; head=creat(); head=daozhi(head); print(head); return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1006题解]]></title>
    <url>%2F2014%2F03%2F17%2Foj-1006%2F</url>
    <content type="text"><![CDATA[Problem DescriptionFamous Harry Potter,who seemd to be a normal and poor boy,is actually a wizard.Everything changed when he had his birthday of ten years old.A huge man called ‘Hagrid’ found Harry and lead him to a new world full of magic power. If you’ve read this story,you probably know that Harry’s parents had left him a lot of gold coins.Hagrid lead Harry to Gringotts(the bank hold up by Goblins). And they stepped into the room which stored the fortune from his father.Harry was astonishing ,coz there were piles of gold coins. The way of packing these coins by Goblins was really special.Only one coin was on the top,and three coins consisted an triangle were on the next lower layer.The third layer has six coins which were also consisted an triangle,and so on.On the ith layer there was an triangle have i coins each edge(totally i*(i+1)/2).The whole heap seemed just like a pyramid.Goblin still knew the total num of the layers,so it’s up you to help Harry to figure out the sum of all the coins. Input The input will consist of some cases,each case takes a line with only one integer N(0&lt;N&lt;2^31).It ends with a single 0. Output对于每个输入的N,输出一行,采用科学记数法来计算金币的总数(保留三位有效数字)Sample Input1 3 0Sample Output1.00E0 1.00E1 Hint Hint when N=1 ,There is 1 gold coins. when N=3 ,There is 1+3+6=10 gold coins. Source Gardon-DYGG #include&lt;stdio.h> #include&lt;cmath> int main() { __int64 sum,total; double n,p; while(scanf("%I64d",&amp;sum)!=EOF&amp;&amp;sum) { n=log10(1.0*sum/6)+log10(1.0*(sum+1))+log10(1.0*(sum+2)); total=(int)(n); printf("%.2fE%d\n",pow(10.0,n-total),total); } return 0; }]]></content>
      <categories>
        <category>算法</category>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
</search>
