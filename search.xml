<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[prime-number]]></title>
    <url>%2F2018%2F07%2F25%2Fprime-number%2F</url>
    <content type="text"><![CDATA[给定一个数字n, 打印出n以内的所有素数。素数的定义非常简单，对于一个整数，除1和它本身外，再没有其他因数了，这个数就是素数。就是说，只除以1或者本身时余数为0，除以其他数所得的余数均不为0。 最简单的方法-- 返回一个整数的所有因数 factors :: Integral a => a -> [a] factorsn=[ x | x &lt;- [1..n], mod n x == 0] > factors 24 -- out: [1,2,3,4,6,8,12,24] -- 检验一个数是否为素数的函数，只需检验它的因数是否只有1和他自己 isPrime :: Integral a => a -> Bool isPrime n = factors n == [1, n] -- 生成素数列表 primes :: Integral a => a -> [a] primes n = [x | x&lt;- [1 .. n], isPrime x] 上面的方法效率很低，每次求因数的时候，要从1～n全都遍历一遍 思考一下，可以简化一些过程 除去2以外，所有的素数都必须为奇树 素数必须是大于等于2的整数 对于一个整数N，若它有一个因数为p1，必有另外一个因子p2，使得N=p1*p1，并 并且p1与p2 一 分布在N的两端或p1 =p2 = 根号下N; 因为比2大的素数必须是奇数，所以它一 也不会有偶因数. 所以，对2进行单独讨论，然后对于其他的数只需要用它去除以所有 3 ∼ 根号下n的所有奇 数，若余数全不为0，则这个数为素数。这样，对于isPrime可以这样定义 isPrime' :: Integral a => a -> Bool isPrime' 2 = True isPrime' p = p > 1 &amp;&amp; (all (\n -> p `mod` n/=0 ) $ takeWhile(\n -> n*n &lt;= p)[3,5..]) -- 注： takeWhile (\n -> n*n &lt;= p) [3,5..]) 求出了 3 ∼ √N 的所有奇数数组成的列表 除此之外还有一个方法叫做埃拉托斯特尼筛法。给 从2开始连续的一列数，2为素数。那 么，在2之后有2 为因数的数均不为素数，可以被筛 。下一个数为3，3之后的所有为3的倍数的数就全被筛 了，因为4为2的倍数，这在第一轮中已经被筛掉了，下一个是5，依次类推，假设列表是无穷的，那么按着这个方法可以遍历所有的素数。 在看书时，阅读到这一块，就感觉真棒👍。填鸭式学习没有这样的思考过程，入门式的编程是以解决问题为主，未曾再进行思考。所以，入门加深入，会发现原来这个问题原来有如此优雅的方法。 PS: 以上出自haskell函数式编程入门]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[summary-work]]></title>
    <url>%2F2018%2F07%2F14%2Fsummary-work%2F</url>
    <content type="text"><![CDATA[react selector最近我看到很多组件需要的redux中的值是一样的，但是，我需要为每个组件写一个mapState，我最直观的感觉是代码的重复性。于是我看了文档，在redux中的找到了一个selector的概念，看了看是可以减少我的代码重复性的。我尝试写了一个，就将这个重构工作交给同事。同事给我的说的意思是：selector可以理解成vue里面的computed。是通过计算得到一个新的值。例如： const getCurrentUser = (state) => ({ currentUser: state.info.currentUser }); 虽然上段代码需要在多个组件中出现。如果抽成一个方法，那么阅读代码的人需要再去找到这个方法才知道我实际需要的数据格式，虽然函数的名字已经很明确，但是你不清楚实际上在组件中使用的变量名。 例如： const searchSelector = { hasSearchFunction: (state) => state.info.currentUser.isBig &amp;&amp; state.info.currentUser.isSmall } 上段代码体现了selector的特点，通过计算得到一个新的值。这是一个提倡的做法。 redux store虽然这个坑我没遇到过，但是踩坑的人告诉我，不要什么东西都放在store里面，在store里面存值，是要进行一次stringfy，最直接的就是不要把不能进行stringfy的数据往store里面放。 组件大小最近在开发新功能的时候，会看到之前写的代码。我能体会得到之前组长的槽点。现在我看到组件，不光大而且里面很多if，看着就脑袋疼。React提倡组件可复用性。组件如果做到最大的复用性，最直接的方法就是组件功能单一性，这样组件可能变得非常小，最好还是把握一下度。以下代码会给你什么启示？ // ArticleItem.jsx const ArticleItem = () => { return ( &lt;div className="article-item"> &lt;div className="article-item__cover"> {/* ....content */} &lt;/div> &lt;div className="article-item__conent"> &lt;div className="article-item__content--top"> {/* ....content */} &lt;/div> &lt;div className="article-item__content--middle"> {/* ....content */} &lt;/div> {/* ....others content */} &lt;/div> {/* ....content */} &lt;/div> ); }; // ArticleItem.jsx const ArticleItem = () => { return ( &lt;div className="article-item"> &lt;ArticleItemCover /> &lt;ArticleItemContent> &lt;ArticleItemContentTop /> &lt;ArticleItemContentMiddle /> &lt;/ArticleItemContent> &lt;/div> ); }; 以上代码会给你带来不同的直观感受。阅读第一版代码，需要足够的耐心来阅读才能知道article中的内容。看第二版的代码，你可以很清晰的看到，article中到底有着什么内容。嗯，可以理解为什么别人不想看我的代码了，又臭又长！现在看来重构别人的代码也是件痛苦的事情。 闲谈之前看到很多的大神的经验谈，但是最真实的感受就是：没经历过真的很难去理解其中的意思。只有真正上手后，才能理解其中的奥妙。hhhh，是不是特别像高中的老师痛心疾首的告诉学生要好好学习，当时真的内心毫无波动，但是现在在想，会发现已经没有足够的精力对待学习这个事情了。活到老学到老，加油，你是最棒的！]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[history-push-state]]></title>
    <url>%2F2018%2F07%2F13%2Fhistory-push-state%2F</url>
    <content type="text"><![CDATA[如何想要点击浏览器自带的前进 后退按钮 不刷新页面，可以通过改变history的state想了一下，写了一个小demo。 &lt;nav> &lt;a href="/home">主页&lt;/a> &lt;a href="/about">个人&lt;/a> &lt;a href="/test">测试&lt;/a> &lt;/nav> &lt;div id="content">&lt;/div> &lt;script> const baseHref = location.href; const baseUrl = '/test.html'; window.onload = () => { const links = document.querySelectorAll('a'); links.forEach(item => { item.addEventListener('click', (event) => { event.preventDefault(); const href = item.getAttribute('href'); history.pushState('', '', baseHref + href); setContentHtml(href); }); }); window.onpopstate = (event) => { // console.log(event); const currentPathname = event.target.location.pathname; const targetHref = currentPathname.split(baseUrl)[1]; setContentHtml(targetHref); } const setContentHtml = (content) => { document.getElementById('content').innerHTML = content; } // 接管路由 // 1. 得到baseUrl之后的href // 2. 根据href去render } &lt;/script> 假如你是直接打开html文件，使用history.pushState会出错，这时候你需要新开一个server。其中最主要的是，你要托管a链接的herf。其中在onpopstate中，我得到targetHref的方式，感觉有些蠢，目前还没想到好的方法。去看一下其他的框架可能会给我一个不一样的思路。飘过～ 2018-07-14 更新在history这个项目中得到的启示：history.pushState的第一个参数就是onpopstate事件中的event.state这样的话，我可以对现有的进行一些改进 // first argumens is event state // history.pushState('', '', baseHref + href); history.pushState(href, null, baseHref + href); // .... // const currentPathname = event.target.location.pathname; // const targetHref = currentPathname.split(baseUrl)[1]; const targetHref = event.state; 这样想一下，event.state里面可以存很多东西….]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>history&#39;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rails-access-origin]]></title>
    <url>%2F2018%2F07%2F06%2Frails-access-origin%2F</url>
    <content type="text"><![CDATA[gem 'rack-cors', :require => 'rack/cors' config.middleware.insert_before 0, Rack::Cors do allow do origins '*' resource '*', :headers => :any, :methods => [:get, :post, :options] end end]]></content>
  </entry>
  <entry>
    <title><![CDATA[bad-code-2]]></title>
    <url>%2F2018%2F07%2F05%2Fbad-code-2%2F</url>
    <content type="text"><![CDATA[最近的烦恼最近真的超级苦恼。一直在进行新功能的开发，没时间做我之前想要重构的东西。在进行开发的时候，这个时候我已经很注意重构的信号，新功能的开发需要重构一些代码，秉承着一个pr只做一个功能，于是我需要切换分支，提pr，合并pr之后，再进行新功能的开发，这个事情真的非常痛苦。之前没有充分的经验和思考进行的开发，给现在的我带了巨大的痛苦。 启示（都是泪）1. 每个文件的入口文件应尽可能的保持干净不要因为函数小，就要往index中塞。index是入口文件，了解整个项目从这里开始，所以要保证，这里的代码做到最简洁明了，一眼看过去，就能有一概览的感觉。小函数感觉放在一个单独的文件中太不值当的，就把所有的小函数放在一个文件中。整理之后，我感觉非常清新。 2. 多处都用到的样式，这个时候就要考虑重命名了要不看了很疑惑，这个页面为什么有其他页面的style 3.实时抽取util组件划分要清楚，例如可以抽出来api.js、tool.js 4.函数复杂度尽可能的降低若真的找不到适合的解决方法，可以与身边的人分享一下，或许会得到更好的解决办法 5. 你连续copy一段代码以上，这个时候，你可以考虑写一个工具来生成相同的代码6. 需要lazy的地方，及时lazy7. 一个问题有两个不同的解决办法，各有利弊,选择代价最小的移动端和PC端共用一个相同的组件，这个我写一个组件，写两份样式。在这个情况下，假如你修改一下组件，这个时候，你就要同时修改两份样式。一般移动端展示的UI较少，用PC端的组件，会造成很多DOM的多余。所以这个时候，写两个组件更好一点。 8.对于react的看法要学会切小片片，尽可能的组件化，组件尽可能的小，职责尽可能明确。之前写两个wrapper有一段相同的代码，这个还可以接受，等我再写一个wrapper时，发现还需要那一段相同的代码，我受不了了，于是将一个组件拆成了三层。emmmm，组件小多么重要。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bad-code]]></title>
    <url>%2F2018%2F07%2F02%2Fbad-code%2F</url>
    <content type="text"><![CDATA[重构当你发现现有的结构满足不了现有的功能，这是重构的信号。很遗憾，为了赶进度，当这些信号出现时，你没有放在第一位去考虑，随着增量的开发，再回头准备下手重构，有一种牵一发动全身的感觉。 烂代码的由来词不达意代码写出来的目的是给人看的，一般你写的代码都不会由你维护。emmmm 随意的命名，给阅读代码的人带来巨大的负担。自己看两天的代码也会有一种雾里看花的感觉。 二随一变这个是在开发过程中，两个对象都随着一个对象变，又勤勤恳恳的写了两遍。这个时候，当发生一点变化，我要找到全部随变的代码，两个一块修改…改的手都累了，眼也花了 我就不改变参数的个数现有的函数不能满足最新的需求，哎呀，我得在往这个函数中传一个参数，emmm，好麻烦，试试能不能在现有的参数中得到我想要的参数，还可以，就这样吧。于是，开始循环，整个函数已经不堪重负了….满篇的if else 来来来 我的麻花真好看写了一个函数，哎呀，我这边需要和这个函数差不多的函数。哎呀，传一个标志，里面判断吧。这麻花不是一般的好看啊 const getData => (isAdd) { if (isAdd) { ..... } // 共用代码 if(isAdd) { ..... } // 共用代码 if (isAdd) { ..... } } repeat yourself做spa的时候，五个页面都是一个list，于是我勤勤恳恳的写了五个list。这是在做ui的时候。在接数据的时候，我发现这几个页面的整体都是一样的，唯一不同的就是里面的item是不一样的，那我为什么还要写五遍呢？其实开发的时候，就是ctrl+c和ctrl+v，那个时候还庆幸，因为把功能划分的十分清楚，我在每个页面map一遍，还挺简单的。沉浸在这种欢乐中，导致忘了这个repeat的操作。于是，动手写个一个生成list的function后，每个组件的代码两行就可以搞定了。 磨刀不误砍柴工对待一个复杂的问题，首先要勾勒出它大概的轮廓，把能想到的全列上，以此先做出一个好的架构。边写边想看是一个需要摒弃的习惯（对于我自己来说）。这次新做的搜索，我先写好ui,在接数据之前，我能大概想到是什么个情况。于是我开始下手写了。写着写着，我发现，嗯 导航需要条件，下面的list需要条件，右边的筛选也需要这个条件。筛选和list是属于一个组件中，我已经写到单独的list这一块了，有种写不下去的感觉，于是我开始将它们共用的数据全部放在父组件。这对于开发中的时间，是一个巨大的浪费，因为这意味着我之前的工作是白做的。这个时候，我开始拿起纸和笔，开始分析我应该怎么去规划…尽管我再分析的时候，把能预见的问题都想到了，但是在开发过程中还是遇到了未知的问题..写代码的仔细分析很重要….开发过程中的清晰头脑也很重要 先写到这….]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[refactor]]></title>
    <url>%2F2018%2F06%2F23%2Frefactor%2F</url>
    <content type="text"><![CDATA[闲谈最近很大一部分工作是在进行重构工作，每次都需要提一个大pr，很是心累。原本项目就是重写了一份，但是在架构方面还是没有做好。在开发过程中，没有进行总结，错过了重构的好机会，导致后期维护起来很累。编写代码的很大感觉，哎这一块我好像写过，copy过来。其实这就是一个重构的信号。don&#39;t repeat yourself.在开发过程中，我做了很多copy的工作，于是出来混总是要还的。现在重构起来就需要将凌乱的部分整合在一起。 css整理工作最近的整理工作，主要是在整理css和js，现在想想也很是惊奇。对于css的整理，是在前期没有很好的去总结组件的共同之处，导致css文件是一个增量的过程，而不是迭代的过程。意思到这点之后，我开始梳理和提取相同的地方。css的整理要注意的是：词达意和语义化，这意味着别人一看到你的class就能大概猜出来它是个什么样的。 js整理工作对于js的整理，很大一部分问题就自己否定自己。刚开始写的时候，我问自己：js可以拿redux里面的数据吗？我在没有查询的基础上给了一个自己否定的答案。嗯，不可以的话只能退而求其次了。现在有人告诉我可以，于是开始整理和重构。看起来问题是出在我没有做好准备工作上面。 什么时候进行整理我不知道这次的整理是否可以称得上重构？但是这次的整理是我的整体思路更加清晰，架构也在渐渐明了之中。在编写的过程，做好的时机是：这一块我之前写过类似的，这个时候，你就考虑把相同的地方抽出来作为一个单独的部分。还有一个情况是你写着写着写不下去了，这个时候，就需要从头梳理一下思路，到底是哪出的问题。或者是目前的代码已经不能满足新的需求时。 整理完一个item，感觉浑身清爽PS:作为一个前端来说，写出来的是直接和用户交流的产品，在开发过程中，我是在知道需求的基础上进行开发的，对于一个临时的功能，我可以写的简单一点，但是也需在明了的基础上进行，emmmm…反之，使用者已疯]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pdf]]></title>
    <url>%2F2018%2F04%2F08%2Fpdf%2F</url>
    <content type="text"><![CDATA[在网页中浏览pdf文件，最简单的办法当然是插入iframe了 html5中浏览pdf文件html5中有标签可以插入pdf,但是在每个浏览器上的表现形式不一样… &lt;embed src="pdfFiles/interfaces.pdf" width="600" height="500" alt="pdf" pluginspage="http://www.adobe.com/products/acrobat/readstep2.html"> 插件pdf.jspdf.js是一个浏览器兼容的插件，移动端也很使用，有一点：需要引入的包太大。为此，有人又做了一个包裹pdf.js-viewer。这个npm是pdf.js的打包后的版本。在使用的过程中，你会发现样式不对，此时你可以将pdf.js中的viewer.scss，拷贝的你的开发目录，而不是引入pdf.js-viewer的css，里面的样式已经过时了。语言包引入后，页面就会翻译，不用做其他设置。 &lt;!DOCTYPE html> &lt;html lang="en"> &lt;head> &lt;meta charset="UTF-8"> &lt;title>Document&lt;/title> &lt;link rel="stylesheet" href="./viewer-2.css"> &lt;link type="application/l10n" href="node_modules/pdf.js-viewer/locale/zh-CN/viewer.properties" /> &lt;style> html, body { height: 100%; margin: 0; padding: 0; } body { overflow: hidden; } #pdfjs { height: 100%; } #viewBookmark, #secondaryToolbarToggle { display: none; } pdfjs-wrapper { display: block; height: 100%; } &lt;/style> &lt;/head> &lt;body> &lt;div id="pdfjs"> &lt;!--#include virtual="node_modules/pdf.js-viewer/viewer.html" --> &lt;/div> &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js">&lt;/script> &lt;script src="node_modules/pdf.js-viewer/pdf.js">&lt;/script> &lt;script type="text/javascript"> $(function() { // window.PDFJS.locale = 'zh-CN'; $('div#pdfjs').load('http://localhost:65534/viewer.html', function(res) { window.PDFJS.webViewerLoad(); window.PDFViewerApplication.open('http://localhost:65534/sample-3pp.pdf'); }); }); &lt;/script> &lt;/body> &lt;/html> 集成到webpack中测试开发可以正常使用，需要集成到webpack中。由于文件都需要用webpack打包，于是按照平常一样，将文件引入，发现控制台报错。在调试过程中，我遇到5种左右的错误，影响最深刻的一点是：document undefined…也是很迷，调试过程中，发现pdf.js种的代码执行了两遍，第二次的时候就会出这个错误。仔细翻了翻源码，在pdf.js中，它需要引入pdf.work.js文件，webpack打包时，它根本就找不到这个文件，最后的结果是只在windows上挂载了关于pdf的两个对象…最后的最后，直接在页面上引入pdf.js和pdf.work.js，由于文件过大，你按需进行加载就可以了。 最后的最后，写了很长时间的slim模版，我忘了原生的标签怎么写了…导致我在引入语言包话费个很长时间…也是很迷…切莫忘本😊]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery-plugin]]></title>
    <url>%2F2018%2F03%2F13%2Fjquery-plugin%2F</url>
    <content type="text"><![CDATA[使用插件现在是使用webpack打包，yarn安装需要的插件很便捷。今天遇到了一个奇怪的问题，我使用yarn安装了一个jquery插件，使用时，jquery报错… 排错 安装、引用是否正确首先先确定一下：包是否正确安装；使用时是否正确引用；ok，这两个都是正确的 webpack是否配置正确在webpack中，一般都会将jQuery设置为全局变量，在webpack中设置如下: new webpack.ProvidePlugin({ $: "jquery", jQuery: "jquery" }) webpack版本是否合适开发中使用的是rails-webpack，其中的配置需要更改（之前对照文档修改配置，报错；今天才看到原来是版本问题😂） 最最重要的一点：查看你安装的插件的包里面有没有node_modules这个文件夹在排查错误时，我将包里面的代码拷贝到开发目录，我发现能用。。。直接引用包就不可以。使用插件，最终目的是在$这个对象上挂载方法。报错就是说明$对象上没有这个方法，问题来了，包里面的$是哪来的？全局对象还是node_modules文件夹中的jquery???引用多个插件，插件依赖的jquery版本可能不是一样的，webpack打包的时候，首先去找安装包的插件node_modules里面的jquery，局部变量覆盖全局变量。所以此时挂载方法的$对象是node_modules包中的jquery，而不是全局的$对象 为什么安装的jquery版本会不同这个时候你也许会疑问🤔️为什么会安装这么多版本？首先你要去检查依赖的jquery版本，这个时候你可以去查看yarn.lock文件，里面有具体的依赖关系。这个时候，假如按照算法，你发现几个插件依赖的jquery的版本应该是一致的。但为什么yarn计算出来的不一样呢🤔️？因为yarn在add包时，计算lock的时候，会在原来的基础上进行计算，恰好在这个时间隔中，jquery升级了…这就导致yarn计算出来的依赖版本可能有所不同此时，你可以使用yarn upgrade进行更新lock文件 如果以上步骤还不能解决问题…我也不知道根本问题是什么]]></content>
      <categories>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>jquery</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[get-module]]></title>
    <url>%2F2017%2F11%2F15%2Fget-module%2F</url>
    <content type="text"><![CDATA[发送邮件: nodemailer 基本代码，使用之前请确保邮箱开启SMTP const nodemailer = require('nodemailer'); nodemailer.createTestAccount(() => { const config = { host: 'smtp.163.com', port: 465, secure: true, // true for 465, false for other ports auth: { user: 'xxxx@163.com', // generated ethereal user pass: 'xxx' // generated ethereal password } }; const transporter = nodemailer.createTransport(config); // setup email data with unicode symbols const mailOptions = { from: '"Fred Foo 👻" &lt;xxx@163.com>', // sender address to: 'xxxx@gmail.com', // list of receivers subject: 'Hello ✔', // Subject line text: 'Hello world?', // plain text body html: '&lt;b>Hello world?&lt;/b>' // html body }; // send mail with defined transport object transporter.sendMail(mailOptions, (error, info) => { if (error) { return console.log(error); } console.log('Message sent: %s', info.messageId); }); }); 若使用SSL, 在config中添加 secureConnection: true, // use SSL 3.添加附件, 在mailOptions添加 attachments: [ { filename: '文档.txt', // 不会乱码 content: '哈哈哈' }, { filename: '2.txt', content: 'heool word' } ] 添加图片, 在mailOptions添加 attachments: [ { filename: '文档.txt', content: '哈哈哈' }, { filename: '01.png', // image path: './flow.png', // 图片路径 cid: '00000001' } ]]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[project]]></title>
    <url>%2F2017%2F11%2F06%2Fproject%2F</url>
    <content type="text"><![CDATA[设计图出代码根据设计图，如何写出好的代码。设计图是一张一张的出的，因为不知道哪一块会在其他的设计图中出现，于是只看到当下并不是一个好的想法。看到一张图，可以先思考一下，哪一块有可能被复用。在class的命名上就会有所改变…刚开始一个元素在主页出现，我可以给它命名home__XX，但是当这个元素也在文章页面出现时，再起一个class，重复写一样的css，这不是一个好的想法，但是将这个类名直接写在文章页，看着又很不爽。在项目中，使用scss用来开发，这个时候，你可以改变类名或者使用@include和@extend来组织代码。js部分，不止实现功能，也要保证优雅。例如一个参数可能是数组或者string，你可以这样写： if (typeof argument === 'string') { //... } else if (typeof argument === 'object') { //... } 也可以这样 const map = { string: () => { //... }, object: () => { //... } }; return map[typeof argument](); 文件夹组织根据项目需要组织出合适的文件结构，文件名也要更好的表达出这个文件夹中的内容，使之清晰… 重构开发的过程中，代码量越来越大，这时候可以考虑一下代码的重构。重构是不大幅度改变代码的基础上进行的…大幅度的重构甚至重写不能称作重构…推荐书籍：重构:改善既有代码的设计]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pm2]]></title>
    <url>%2F2017%2F09%2F13%2Fpm2%2F</url>
    <content type="text"><![CDATA[由来嘤嘤，看到ruby中有一个gem叫做capistrano， 使用它可以实现一键部署到服务器上了。之前在懵里懵懂的时候，做了一个网站，每次更改后，我都用filezilla将新版本的代码上传，再restart项目，超级费劲。看到ruby后，于是赶紧去网上搜了搜，pm2可以做这件事。之前也见到过pm2，那时候我在寻求守护进程的module，但是我选择了forever。 使用pm2实现自动部署这个链接对我的帮助很大，基本上按照他的步骤来应该是可以实现自动化部署。 出现的问题服务器上的node是我很久之前安装的，但是pm2要求使用nvm，于是装了nvm，但是到了“克隆好之后执行安装和启动”，这一步报错：npm 这个命令找不到。去寻找解决办法，有的说将.bashrc文件中的关于nvm的部分放在最上面，还有的说要使用nvm重新安装node，这两个方法都试了，但是都没有解决错误。于是我只能去pm2的目录中的source文件夹，手动去执行npm install 和 pm2 start app.js 等待update得到解决方案： nginx转发最暴力的方法就是下面👇的代码： server{ listen 80; server_name xxx.xxx.xxx;(域名) location / { proxy_pass http://127.0.0.1:3000 } } 目前可以解决我的需要，假如还有其他的端口需要监听该怎么办？]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-first]]></title>
    <url>%2F2017%2F09%2F13%2Flinux-first%2F</url>
    <content type="text"><![CDATA[对待自己的服务器，想着反正也没人攻击，也就从来没在意过。前天得到了一个讯号：要好好对待服务器，第一步就是安全性， 你需要这么做 使用root账户登录后，创建一个用户并设置密码，如果有必要，就赋予用户root权限 上传ssh-key，上传成功后，你就不用输入密码登录服务器了 关闭密码登录，打开ssh-key登录 以后就使用你新建的用户登录吧]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week6]]></title>
    <url>%2F2017%2F09%2F03%2Fweek6%2F</url>
    <content type="text"><![CDATA[举一个栗子🌰：在分页时，你通常会看到url上一般是xxx?page=1通常的做法是点击第几页直接跳转页面，是通过location进行的现在的需求是：在跳转页面的时候，我既想要改变url，同时我只需要改变分页的数据，而不需要整个页面重绘。 —–很幸运history提供了这么一个方法pushState，它有三个参数：state object，title，以及一个可选的URL地址。第二个参数title:现在firefox和chrome已经忽略该参数 window.history.pushState('','title','?page=1'); pushState参考链接]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[coursera-3]]></title>
    <url>%2F2017%2F09%2F03%2Fcoursera-3%2F</url>
    <content type="text"><![CDATA[淡淡的忧伤three time 是三倍的意思 学习一门新的语言目前学习一门新的语言仅仅停留在Syntax，但是真的要把代码写的优雅，你更要了解它的Type-checking和Evalustion，了解这两者之后，你能知道代码在哪里可以优化，而不是代码的优化是在写代码中或者看到别人的代码时看到的目前这个方面需要改变，思想的转变…人的思想都是在肤浅向深沉转变😄 应用类型下面是一段java代码，乍看上去没有问题，但是使用p.getAllowesUsers[0] = p.currentUser，这一句代码使权限形同虚设。原因是：getAllowesUsers中直接返回的是allowedUsers，我尝试修改p.getAllowesUsers的值, 实际上修改了示例的私有变量的allowedUsers的值修改： 在getAllowesUsers中直接返回的是allowedUsers的一个克隆 class ProtextedResource { private Resource theResource = ...; private String[] allowedUsers = ...; public String[] getAllowesUsers () { return allowedUsers; } public String currentUser() { // ... } public void useTheResource() { for(int i = 0; i&lt; allowedUsers.length; i++) { if (currentUser().equals(allowedUsers[i])) { ... // access allowed: use it return ; } } throw new IllegalAccessException(); } } 之前在项目中，我定义了一个default的值，合并对象选的是lodash的extend,因为没有看文档就直接使用了，extend(default, options)，发生了bug。我的本意是default是一个不可变的值，它作为一个函数的默认值。经过长时间😅的调试，我发现default的值改变了，去看文档发现extend会改变第一个参数的值。于是更改为extend({}, default, options)当应用类型作为函数的参数，一定要特别注意，尽量使用实参的clone值，要不在函数中修改参数的值，就相当于修改实参的值了… 尾递归递归在一定程度上可以代替loop，一方面它看起来更优雅，另一方面…下面的代码上面的函数是我们经常使用的方式，通俗易懂。下面的递归称为尾递归。两种函数实现的功能相同。但是若要分析到stack处，你会发现下面的函数比上面的函数有更好的性能；首先上面的函数涉及到每次递归都要去进栈和出栈后才能得到就过，但是下面的函数却没有这样的操作。而且在Evalustion阶段，上方的函数最终结果的数据类型需要依赖上一步的结果；下面的函数时不需要上一步的计算结果 fun sum1 xs = case xs of [] => 0 | i::xs’ => i + sum1 xs’ (* tail recursion*) fun sum2 xs = let fun f (xs,acc) = case xs of [] => acc | i::xs’ => f(xs’,i+acc) in f(xs,0) end 就到这吧…😪]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week5]]></title>
    <url>%2F2017%2F08%2F26%2Fweek5%2F</url>
    <content type="text"><![CDATA[上周没写总结… if条件什么时候为false因为react共用组件，但是传过来的值的结构不同，于是使用||来进行判断选择，于是写了以下代码放心的提上去了 const count = node.count || node.usage_count || node.total_count 发现报total_count是undefined，这个我仔细看了代码没找出来哪错了，于是把生产环境的数据库拿下来，开始调试…最后发现因为usage_count的值为零的时候，会继续往后执行，因为node.usage_count值为0，js会认为是false…我的原意是为undefined的时候，会继续向后执行。使用js很随便，但是忘记了随便的副作用。于是我只能用if…else…去判断undefined了👉当if语句中的变量为false，0，NaN，空字符串，null，undefined时，判断结果为假; 图片是使用背景图还是img标签一般来说，我的习惯是图片一般使用img标签插入页面。但是，假如一个网站有中文英文两个版本，通过类名的切换而不是跳转页面可以实现中英文的切换，这个时候，就不要img标签，而是背景图的形式插入图片，这样做的好处是：图片是在css设置的，我可以为元素设置不同的类名进而切换图片 BEM不应该嵌套太深BEM命名的方式，一般是一个block里面包含element,所以我是一个block一层来的。大哥告诉我这样是不对的，划分block没有错，但是在命名不冲突的情况下，block中的element的类名没有必要一定按照block的类名开头。 一定要选好元素之前做tab切换的时候，咋改都没达到想要的效果。看了大哥的代码，才发现自己选错元素了。应该选择section的父元素而不是每个section…写代码之前没有经过严密的思考，遇到错误时，思想受到了限制，导致没想到正确的方向去… calccss3中的calc这个计算属性超级好用，但是有一点需要注意 height: calc(100%-75px); 以上代码不起作用，让人摸不着头脑，经过查询之后，需要注意的是-号两边要有空格 height: calc(100% - 75px); display:flex;兼容性网站要兼容到IE9，而flex是从ie10兼容的。找hack但是没有只对IE9起作用的hack…唉，使用\9的hack，它也在IE10下起作用对于IE9的兼容，我一般使用display: table;和display: table-cell;。此时你在设置子元素的margin是不起作用的，此时你想要的效果这两个css属性可以达到你的需求border-collapse: separate;、border-spacing: 5rem。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week5-1]]></title>
    <url>%2F2017%2F08%2F26%2Fcoursera-2%2F</url>
    <content type="text"><![CDATA[说在前面的话最初对待语言的看法：相比语言更重要的是由编程思想，语言只是一种工具。所以对于只停留在Syntax阶段，没有去深究语言的内在。之前在学习C++的时候，老师也讲过一些内存方面…例如一段很简单的代码，在C++中会造成死循环…代码片段我还是没找到…在学编译原理的时候，也学过词法分析、语法树等等…但是总是来说对于语言还是又一个模糊的概念近期在coursera看一门课程，收获很大。刚开始看视频，因为自己的英语能力薄弱，刚开始看的时候，恨不得每句话都Google tanslate一遍，看多了就习惯了，因为大部分的术语你已经知道意思了，所以能知道大概的意思。Google翻译的意思，因为不知道术语所以翻译出来也很奇特。目前是以ML为例讲解的 variable binding变量的绑定主要包括两个环境：静态环境记录了变量的类型；动态环境记录了变量的值 val x = 34 (* static env : x : int *) (* dynamic env : x -> 34 *) rules to expressions它共有三个部分：语法检查、类型检查和评估规则 Syntax: if el then e2 else e3 where if, then, and else are keywords and e1, e2, and e3 are subespressions Type-checking: first el must have bool type e2 and e3 can hav any type(let`s call it t), but they must have the same type t the type of the entire expression is also t Evalustion rules: first evalustion el to a value call it v1 if it`s true, evaluate e2 and that result is the whole expression`s result else, evaluate e3 and that result is the whole expression`s result shadowing当你重复声明相同的变量时，之前声明的值就会被覆盖，当你在REPL中看它的值的时候，就会变成hidden value，所以不建议重复声明变量 val x = 34 val x = 45 (* this is not assiginment statement *) 递归ML语言没有for循环，所以在对于list类型的数据，会尝试使用递归去解决问题，但是小心哦，不恰当的使用递归，会使运行次数呈指数式增长。下面是求list中的最大值，可以简单粗暴的理解成求数组中的最大值 fun bad_max(numbers: int list) = if null numbers then 0 else if null tl numbers then hd numbers else if hd numbers > bad_max(tl numbers) then hd numbers else bad_max(tl numbers) 上面代码逻辑清晰，通俗易懂，但是使用的时候，假如数组中的数是从大到小排列时，程序运行速度很快；相反，数组中的数若是从小到大排列，当数组是[1,…30]时，你就会发现有延迟…讲师用了一张图给你讲解 优化的方法是：你可以将bad_max(tl numbers)的值赋予一个变量，这样，每次程序运行时bad_max(tl numbers)只会执行一遍。这里使用了let...in...end，在这个课程中，作者也讲解了作用域的问题，例如子作用域的值回覆盖父作用域的值… 关键字每门语言都会提供关键字来提高代码的可读性，在适当的地方记得使用 调试错误调试错误时，一定要有耐心…]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week4]]></title>
    <url>%2F2017%2F08%2F20%2Fweek4%2F</url>
    <content type="text"><![CDATA[只想睡觉...]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm-package]]></title>
    <url>%2F2017%2F08%2F17%2Fnpm-package%2F</url>
    <content type="text"><![CDATA[写包的初衷项目中很多地方用到相同的代码段，做其他项目的时候，也会用到这个功能，于是，大哥让我写一个包，供目前以及以后的项目使用 提供的功能在机器之心这个页面，上面的nav会根据滚动条的位置进而改变active状态，同时，点击nav中的每个链接，页面也会滚动到相应的section。这个功能很常见。目前，包提供的两种形式： 使用锚链接：你通过点击nav中的链接，通过锚点来使页面滚动到相应的section；同时，滚动条的位置改变时，会更改页面的hash，nav的active也会改变。 使用点击事件：你通过点击nav中的链接，通过获得元素的data-index来确定相应的section，所以你必须为nav中的item添加data-index属性；同时，滚动条的位置改变时，nav的active也会改变。 项目的地址点击这去仓库具体的参数请查看readme 项目发布的过程 新建一个文件夹，npm init来填写包的信息 编写代码 完成代码编写，若你使用ES6或者ES7的语法，需要使用babel转换一下 npm login npm publish 到这你的包发布成功，若更新包，记得要改package.json中的version 遇到的坑 完成代码编写后，直接发布了，使用的时候报错：import那报错；我以为是因为没有因为代码压缩，于是进行了代码的压缩，发现并没有什么软用；因为项目使用webpack打包，就想是不是因为没有打包，于是就开始了打包，结果项目还是报错。边上网边查，我还以为是代码写错了…；最后，看了其他包的样子，发现是使用babel打包的，解决了这个大问题。 若你安装不上一个包，报错说是因为名字重复了：不是文件夹的名字和包的名字重复了，而是你的项目的package.json中的name和包的名字重复了… 自己坑自己，代码变量拼写错误，最近老是犯这个错误😔 终结～]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES7-decorator]]></title>
    <url>%2F2017%2F08%2F13%2FES7-decorator%2F</url>
    <content type="text"><![CDATA[装饰模式对于装饰模式，现在还剩下鸡腿堡+香菜+辣椒的记忆。这个是装饰模式的一个例子：有一个汉堡的抽象构件，鸡腿堡是具体构件，香菜和辣椒都是具体的装饰角色。现在我想计算鸡腿堡+香菜+辣椒的价格 针对的问题你想要动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。不改变接口的前提下，增强所考虑的类的性能。何时使用： 需要扩展一个类的功能，或给一个类增加附加责任。 需要动态的给一个对象增加功能，这些功能可以再动态地撤销。 需要增加一些基本功能的排列组合而产生的非常大量的功能，从而使继承变得不现实。 es7中的装饰器es7新增的decorator 属性，它借鉴自 Python，在 Python 里，decorator 实际上是一个 wrapper，它作用于一个目标函数，对这个目标函数做一些额外的操作，然后返回一个新的函数。 装饰propertyES2016装饰器是一个返回函数的表达式，可以将target，name和property描述符作为参数。你可以通过在装饰器前加一个“@”字符来应用它，并将其放置在您想要装饰的顶部。可以为类或属性定义装饰器。 class Cat { meow() { return `${this.name} say meow`; } } // 如果给meow方法加上可读属性 // 定义一个装饰器 function readonly (target, name, descriptor) { descriptor.writeable = false; return descriptor; } class Cat { @readonly meow() { return `${this.name} say meow`; } } // 此时你尝试修改meow，就会报错 // // 在这里推荐一个module： core-decorators 装饰class在这种情况下，装饰器将使用目标target的构造函数。 function hero(target) { target.isHero = true } @hero class MyHero {} console.log(MyHero.isHero); // true 还可以进一步扩展，为装饰功能提供参数。 function hero(isHero) { return function(target) { target.isHero = isHero; } } // 你可以写成ES6的形式 // const hero = isHero => target => target.isHero = isHero; @hero(false) class MyHero {} console.log(MyHero.isHero); // false 参考参考链接]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>es7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week3]]></title>
    <url>%2F2017%2F08%2F13%2Fweek3%2F</url>
    <content type="text"><![CDATA[❓psd转html首先你拿到设计图应该做什么？我的做法是浏览一下整个页面，找出每个模块的共同点。之后开始搭建html，再写css，最后写js。昨天拿到设计图，按照这样的模式去做。可是在最后添加icon时犯了难，因为在icon库里面没有找到合适的，就想着在psd中直接导出icon，可是这时候去看psd的时候，发现整个模块是一个图层，这个时候犯了难，我不知道设计者这样做的意图？再接着我将整个模块作为一个png导出，直接放在页面上，我感觉这样做是不对的，最后的方法是将需要的图标裁剪出来，多个图标但在一个png中。这次给我一个提示：你拿到设计图第一件事是需要干什么？浏览页面的时候，是不是需要将每个模块的所在的图层全都要过一遍以及注意事项… ❓一个带有渐变颜色的圆形边框首先为了使div带有渐变颜色的边框，于是设置它的border-image是一个渐变颜色，虽然边框是渐变的了，当时它没有圆角，即使再改变它的border-radius也不会有作用。👉我在stackoverflow上找到了解决方法点击这里。但是这种实现还是有个缺点，就是div必须设置一个背景色，进而来掩盖它的after伪元素的背景色。但是我想要的效果是它的背景色是透明的，没有找到好的解决办法，就找了一个和背景色相近的颜色去代替😔。这个偷懒的方法，期待完美的解决方案… ❓css画出文件夹📁的轮廓这个问题最难的部分是画出文件夹📁上方那个弧度，没有什么好的办法，就是用两个元素的border-radius连接而成，理所当然的，画出的轮廓有些奇怪…因为border-radius越大，边框的弧度久越大，可见的border宽度会越来越窄，所以会有一种不圆滑的感觉。感觉我的想法有些奇怪… 如何做出宽高成比例的div父容器设置width和padding，padding设置百分比，padding设置百分比之后和width相关。子容器飘在父容器上width和height等于父容器即可。 ❓es7装饰器大哥说：没有什么是包不能解决的。查看了代码是使用了装饰器。 js中的offsetTop和jq中的offset()、position()使用起来还是不等同的，具体的得去查看源码… rails on ruby在查询的时候，能进行include的就不要在jbuilder里面再去查询一遍。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week2]]></title>
    <url>%2F2017%2F08%2F05%2Fweek2%2F</url>
    <content type="text"><![CDATA[分页插件写分页插件，我开始的想法是： 判断是否显示“上一页” 判断是否显示“第一页” 判断是否显示“…”、”current-2”、”current-1” 判断是否显示 current页面 判断是否显示”current+1”、”current+2”、“…” 判断是否显示“最后一页” 判断是否显示“最后一页” 我的目的是最少要显示cuurent周围的四个number，按照这个想法写出来，当cuurent为1时，只会显示123三个number，而我的预期是现实12345这五个number😔调整一下做法，将上面的3-5合并，left和right表示current-2和current+2，在left&lt;0时候，将right加上left的相反数，right&gt;total同理最后，我还是找了一个插件用在项目中，👉插件的名字是：react-paginate，css部分需要你自己去写… react and jquery目前有一个container的组件，它的子组件是list和detail，list的子组件是item，点击item，detail组件会显示，显示效果是通过增加删除类名实现的。想着组件传值比较麻烦，于是就在方法里面直接使用jq早啊道元素控制。大哥告诉我，这个解决办法是不推荐的。👉正确的做法是使用state。通过改变state的值，进而改变元素的class。 redis还记得之前的一个面试问题：视频有最热视频、点赞最多视频、其他视频，每次去服务器要十个数据…由于用户使用量很多，每次去数据库查询，访问量太大。这样的话，👉可以使用redis去做缓存，这样取数据库可以直接取缓存中取，设置一个时间去更新redis即可。现在又一个需求，是记录每天用户登录网站的数量。👉方法一：给用户表增加一个最后登录时间的列，每天定时执行程序，统计一下最后登录时间是昨天的用户数量。这个方法中，选择什么时候去执行程序很重要，要不然就会有漏网之鱼。👉方法二：最粗暴的办法是，在redis中创建一个字段，它是一个数组，每次知道用户登录的时候，就将用户的idpush进数组，每天用户的登录的数量，直接通过数组的长度就可以得到。这个方法的缺点就是：用户的id字段也是一串很长的字符串，数组会特别大。👉方法三：在redis中创建一个字段，它是一个字符串，默认是长度是用户的数量的0，若用户登录，就将对应的位置为1。在这三个方法中，第三个方法是最优方法。还有一个可以做缓存的数据库叫memcache，它和redis的区别就是，redis可以持久化。 插件js-base64Graphql中自带的分页，after字段是base64的字符串。前端传值就需要将数字转化成base64位的字符串。 import { Base64 } from &#39;js-base64&#39;; const cursor = Base64.encode(number); 最后说句题外话，任何炒作都不能改变一个东西没落的事实，与其去炒作，还不如用脑子把东西做的更好。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[douban]]></title>
    <url>%2F2017%2F08%2F02%2Fdouban%2F</url>
    <content type="text"><![CDATA[在千里码刷题的时候看到了这个题目题目要求是爬取豆瓣评分最高的250部电影的总分… 分析爬数据，首先是实用http模块去爬取全部的HTML然后使用cheerio去得到HTML中自己想要的数据最后每页得到的总分相加 题目中的坑1、因为豆瓣是https开头，使用https模块，具体的方法没看，使用还是按照http模块来的2、如果按照正常的逻辑去写代码，最后得到的总分是0，因为https抓取数据是异步进行的3、使用promise来进行处理，首先需要等到25页的数据全部抓取完毕，再进行计算总分，这时候想到了promise.all这个方法。4、第一次尝试将使用promise，我在getData中直接将resolve(res)，等到下面使用的时候，res又是一个异步执行，这下尴尬😅了，于是调整顺序，在res执行end事件的时候再resolve5、js中浮点类型计算的坑，我直接暴力的*10，最后在／10 代码爬评分时，顺便把电影名也爬下来了，我准备把没看的都补上😄 const https = require('https') const cheerio = require('cheerio') let sumScore = 0 let allMovie = [] function filterMovie(html) { let $ = cheerio.load(html) let movieList = $('.grid_view li') let total = 0 let movies = [] movieList.each(function(index, item) { let score = $(item).find('.bd .rating_num').text() let movieName = $(item).find('.hd a').text().replace(/\s+/g,"") movies.push({ name: movieName, score }) total += Number(score) * 10 }) return { total, movies } } function getData(url) { return new Promise(function(resolve, reject) { https .get(url, function(res) { let html = '' res .on('data', function(data) { html += data }) .on('end', function() { resolve(filterMovie(html)) }) }) .on('error', function(err) { reject(err) }) }) } let funcArr = [] for(let i = 0; i &lt;= 225; i=i + 25) { let url = `https://movie.douban.com/top250?start=${i}` funcArr.push(getData(url)) } Promise .all(funcArr) .then(res => { res.forEach(list => { const { total, movies } = list sumScore += total allMovie = allMovie.concat(movies) }) console.log("总分：" + sumScore / 10) allMovie.forEach(movie => { const { name, score } = movie; console.log("评分：" + score + "，影片名：" + name) }) }) .catch(err => { console.log(err) console.log("出错了") }) 如果你有更好的想法，欢迎交流👏]]></content>
      <categories>
        <category>代码</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[work1]]></title>
    <url>%2F2017%2F07%2F28%2Fweek1%2F</url>
    <content type="text"><![CDATA[收获一turbolinks是一款将网站变成spa的一个插件，看到文档的的某些地方和ionic有些许相似之处，于是就将之前做webApp的疑问提了出来：打开页面刚开始进的页面是主页还是登录页？经过讨论后，👉是主页；为App添加一个拦截器，对于用户登录后才能使用的页面，进入时，首先在拦截器中判断有无用户登录…另外，两者之间还有相同的一点：都会提前缓存页面。之前做app的时候，添加了拦截器，因为app首先打开进入主页（这时候开始缓存和主页相关的页面），判断用户未登录，会重定向到用户登录页，这时候就会发生页面的闪烁，关于这个问题我没有查😶，我很暴力的加了一个spash….另外，关于支付宝账单页，数据是如何传递，数据格式如何设计，尝试去爬数据也没看到数据长什么样子的😑，于是目前的想到的方法是，👉后端每次去数据库取count条数据，在按照日期分组后，传到前端；前端的处理方式是：判断得到的第一个月数据与本地现有的最后一个月的数据时候是同年同月，如果是就concat第一个月的数据，剩下的数据直接push。 收获二在将加载更多全都迁移至react的过程中，我在大哥的基础上，比这葫芦画瓢，完成了页面的重构…但是现在有一个问题是：假如全用react去渲染，那么爬虫就爬不到数据，于是采用的方式是：render的时候，会在页面上先渲染一部分数据，剩下的就交给react来做；但是apollo目前提供的解决方案是：假如你将数据渲染到页面上时，会先查找cache中有没有数据，如果有就将数据渲染到页面上；否则发出网络请求。这意味着，只要我将插件渲染到页面上，就会发出网络请求，这一条网络请求是不需要的。因为用户可能不会浏览很多数据，于是想到的办法是：👉等用户去点击加载更多的时候，再去发送网络请求。查找apollo的文档，能想到的办法是：👉预先向cache中写去空数据，这样渲染时，在cache中找到数据，就不发送请求了，但是我不知如何写入数据😖，这是一个预留问题😞很忧伤的一个问题…待续… 收获三知道了reduce这个优雅的方法，promise也提供了这个方法…. 收获四在还原原型图时，更多的时间应该花费在如何设计HTML的结构上，再接下来再写css，最后再写js。这次做的时候，本来是设计好了还能符合要求的HTML结构，结果在写css的时候，发现现在的HTML不能达到预期，于是开始设计调整HTML，幸亏样式使用scss写的😉…还有一个，我看到排排站的元素，首先想到的不是ul&gt;li，而是直接用a标签去尝试解决… 收获五再看文档的时候，看到了一个新的名词：Vanilla JS；用Google translate翻译了叫奶味js😀，于是就去查它到底是何方神圣，原来它的另一个名字叫做javascript😅 收获六因为sublimen并没有完整配置，push上去的代码就跑不过测试。这次找到了eslint检测js的package,叫做SublimeLinter-contrib-eslingt，代码不通过有红色标识…]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array的reduce方法]]></title>
    <url>%2F2017%2F07%2F28%2Freduce%2F</url>
    <content type="text"><![CDATA[初识第一次听说Array的reduce方法是在面试的时候这次看到大哥写的一个函数，里面用了reduce，哇，真的好优雅。因为代码的重复片段太多，我尝试去封装一个通用函数，没有成功。于是大哥出动了。目的是这样的：我可能需要data.user.article的值，或者需要data.article的值，或者需要data.categories.article的值，于是封装一个方法每次取到article的值。 // 封装一个函数reg，参数为belongto，传递的参数分别是：['user'] [] [categories] // 函数内部的主要代码是 return belongto.reduce((p,c) => p[c], data).article reduce文档Syntaxarr.reduce(callback[, initialValue]) 参数callback有四个参数：分别是accumulator(它是callback上一次返回的值或者是initialValue，前提是initialValue存在)、currentValue(正在使用的值)、currentIndex(正在使用的值在数组中的索引)、array(这个是循环的数组)；initialValue：用作第一次调用回调的初始值，如果不提供此参数，则第一次调用回调的初始值是数组的第一个元素。为了保证安全，最好提供这个值 tip: 当数组为空时，若提供initialValue，则最后的返回值是initialValue，否则，报错； 当数组不为空时，若提供initialValue，则循环从index为0开始；否则循环从index为1开始，accumulator此时为index为0的值。 返回值回调函数的最后的返回值 用法求数组元素的总和（告别for循环） var sum = [0, 1, 2, 3].reduce((a, b) => a + b, 0); // sum is 6 连接数组 [[0, 1], [2, 3], [4, 5]].reduce((a, b) => a.concat(b), []); // result is [0, 1, 2, 3, 4, 5] 相同元素在数组中出现几次 var names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice']; var countedNames = names.reduce( (allNames, name) => { if (name in allNames) { allNames[name]++; } else { allNames[name] = 1; } return allNames; }, {}); // countedNames is: // { 'Alice': 2, 'Bob': 1, 'Tiff': 1, 'Bruce': 1 }]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[relay-apollo]]></title>
    <url>%2F2017%2F07%2F23%2Frelay-apollo%2F</url>
    <content type="text"><![CDATA[使用relay的感受初次接触relay，感觉上很臃肿，因为必须为每个组件设置container；若query层级嵌套很深，为了组件化，就必须将每一个react的component全部分开，在项目中，我写了六个组件，那么每个组件都需要container，写起来感觉满满的恶意。 使用Apollo再次接触Apollo，看了文档，感觉和relay大同小异，与relay的不同是：无需为每个component设置container，最后写一个query就ok👌了。query也可以由多个fragment组成。另外，apollo也为angularjs提供了解决方案，有点想不明白🤔，angularjs本身就是双向数据绑定，为什么要对它提供解决方案…另外，Apollo虽然自身内部集成了redux，假如你的项目中使用了redux，你可以使用redux而不用Apollo内部的redux。 relay 因为container的存在，数据划分的比较严密，你只能在当前的container访问fragment中的的属性，不能访问父或子fragment的属性。而apollo直接使用的是请求得到的Object…Apollo也可以和项目原有的redux相结合使用，relay不可以…待续…这次写的很匆忙，假如有不正确的地方，请指正，谢谢😊。]]></content>
      <categories>
        <category>graphql</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
        <tag>graphql</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2017%2F07%2F22%2Fgit%2F</url>
    <content type="text"><![CDATA[使用git想要去合并两个commit今天好不容易完成了工作，睡觉的时候突然想到还有些小瑕疵，就想改正。但是改动范围很小，不好意思在commit一次，于是就想将两次commit合并在一起，但是我没有将最新的commit推送到远程分支，就直接合并了两个commit成了一个新的commit，在推送到远程时，也没有先进行pull的动作（👉每次push之前一定要进行pull的动作），导致远程commit和我合并的commit发生冲突，最后还需要手动merge。看了一下提交记录，吓坏了，本来我想合并commit，预计的commit只会在之前的基础上多一次commit，但是现在多了三次commit，这下坏了。于是，上网查询，试了好几种办法。找到了一个很合适的办法 git reset HEAD^ --hard //彻底回退到上次提交 git push origin 分支名 -f // 强制推送到远程 这样操作以后，我的问题解决了 待续… -补充—最好不要不要强行push😕]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-relay]]></title>
    <url>%2F2017%2F07%2F22%2Freact-relay%2F</url>
    <content type="text"><![CDATA[上次写感想还是2014的时候，那个时候是老师布置的作业（尴尬)队长看到GraphQL很好，于是先拿一个功能来试手😊。前端要使用GraphQL，最简单的方法是使用ajax发送query字符串。这个方法，若query嵌套层级太深，会导致query很长，长的让人接受不了；再者，假如数据变化，需要你手动的去改变DOM。项目中使用了react，于是队长给推荐了react-relay来配合GraphQL。首先给的时间是看GraphQL和react-relay的文档，先瞄一眼relay的文档，感觉是层层嵌套，就先去看GraphQL的文档，relay的文档没有看完…😶 第一天开始在队长的鼓励下开始写relay，到了relay的官网上，看到有一个Demo，就把代码给copy下来，再根据文档理解了代码的意思，就开始尝试着写代码。写代码的过程有点别扭，刚开始接触，会犯一些错误。但是又不知道错误发生的原因，于是就开始google解决。也想吐槽一下文档，文档上说，fragment的name建议是fileName_propsName，于是为了名字短点，就全部改了，结果编译的时候，告诉我是must be。😢代码终于不报错了，但是需要一个schema的文件。我想手写schema太繁琐了，也是去查有没有自动生成schema的插件，但是很遗憾，我找到都是配合node使用的（假如你有好的插件，请推荐给我，谢谢）。找啊找，找啊找，也没找到合适的，最终是队长上网找了一个工具生成的🤗。schema的问题解决。schema的存在是为了映射fragment的type。这个时候，大哥过来问问我怎么样了，我告诉他，虽然安装了react-relay，可是文档上的方法不存在，我就很暴力的改了源码，将方法暴露出来。他告诉我relay现在有两个版本：classic和modern，modern是最新的。我弱弱的问一句，咱们用哪个版本，他说当然是最新的。我的内心在哭泣😭。既然只是版本的迭代，思想肯定没有太大的变化，于是打起精神来看文档。👉这里是我太心急了，直接看了Demo，就ctrl+f去直接搜方法了，没有整体的先浏览一下文档，要不然也不会有这个不可预料的情况。 第二天边看文档，边改我的代码。👉刚开始报错是“没有配置babel或者graphql写错了”，假如你的babel配置是按照文档来的，那最有可能的就是你的fragment或者query写错了。最简单的query可以正常的渲染出来了，因为是query中需要有参数，所以开始看如何使用参数。在查资料的时候，这个链接给了我很大的帮助。但是在这个过程中，下面的错误伴随了我十个小时，我一直在尝试解决这个错误，于是上网查啊查 查啊查 查啊查也没找到答案 第三天大哥说他写出来了，我看了他的代码，对比我的代码，唯一的不同是，我将edges和node要写在不同的fragment中。我尝试在正确的代码上改成我设计的fragment，功能就报错了。我意识到，需要将edges和node写在同一个fragment中。👉出现这个错误的原因是，我已经封装好的fragment，出现这个错误，我全部的心思都放在了index.js，没有检查我封装好的组件。假如再来一次，我也会被困在这个error上出不来。之后因为还有一个加载更多的动作，于是我开始完成这个功能，在这个过程中，我学会了react父子组件如何传递消息。 测试功能完成好了。但是在进行测试的时候，再看network时，加载更多这个按钮是通过first这个参数来进行请求数据，first的意思就是取前first数据，后端限制first只能取到50，即使可以取到1000，但是在网络上传输1000条数据，也是一笔庞大的负担。relay也提供了分页的container，但是没有研究出来是怎样使用的。于是relay需要更换….所以，没有一个很好的方式来解决这个问题。👉队长又给推荐了Apollo，接下来要去看Apollo了待续…]]></content>
      <categories>
        <category>graphql</category>
      </categories>
      <tags>
        <tag>graphql</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wechatPHP]]></title>
    <url>%2F2017%2F03%2F29%2FwechatPHP%2F</url>
    <content type="text"><![CDATA[使用apache+php5.4n1、打开apache配置文件httpd.conf 搜索httpd-vhosts.conf，打开这一行的注释2、打开apache所在目录下的，conf/extra/httpd-vhost.conf 增加以下代码，保存 &lt;VirtualHost *:80&gt; DocumentRoot &quot;D:\WWW\car-xxxx\car&quot; ServerName www.car-zones.com &lt;/VirtualHost&gt; &lt;Directory &quot;D:\WWW\car-xxxx\car&quot;&gt; Options Indexes FollowSymLinks Includes ExecCGI AllowOverride All Order allow,deny Allow from all &lt;/Directory&gt; 3、重启apache4、打开c:/windows/system32/drivers/etc/hots最后一行加入：www.car-xxxx.com5、访问 www.car-xxxx.com6、完成配置 第一次学习，记录一下]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>微信公众号</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dataTable]]></title>
    <url>%2F2017%2F03%2F26%2FdataTable%2F</url>
    <content type="text"><![CDATA[偶然发现一个叫 dataTable 的组件，觉得很好用，于是研究了一番，下面是代码 var lang = { "sProcessing": "处理中...", "sLengthMenu": "每页 _MENU_ 项", "sZeroRecords": "没有匹配结果", "sInfo": "当前显示第 _START_ 至 _END_ 项，共 _TOTAL_ 项。", "sInfoEmpty": "当前显示第 0 至 0 项，共 0 项", "sInfoFiltered": "(由 _MAX_ 项结果过滤)", "sInfoPostFix": "", "sSearch": "搜索:", "sUrl": "", "sEmptyTable": "表中数据为空", "sLoadingRecords": "载入中...", "sInfoThousands": ",", "oPaginate": { "sFirst": "首页", "sPrevious": "上页", "sNext": "下页", "sLast": "末页", "sJump": "跳转" }, "oAria": { "sSortAscending": ": 以升序排列此列", "sSortDescending": ": 以降序排列此列" } }; var table = $("#sample").dataTable({ language:lang, //提示信息 autoWidth: false, //禁用自动调整列宽 processing: true, //隐藏加载提示,自行处理 serverSide: true, //启用服务器端分页 searching: true, //禁用原生搜索 search: { "search": "" }, ordering:false, renderer: "bootstrap", //渲染样式：Bootstrap和jquery-ui lengthChange: false, pageLength:15, rowId: '_id', pagingType: "simple_numbers", //分页样式：simple,simple_numbers,full,full_numbers columnDefs: [{ "targets": 'nosort', //列的样式名 "orderable": false //包含上样式名‘nosort’的禁止排序 }], ajax: function (data, callback, settings) { //封装请求参数 var param = {}; param.keyword = data.search.value; param.limit = data.length;//页面显示记录条数，在页面显示每页显示多少项的时候 param.start = data.start;//开始的记录序号 param.page = (data.start / data.length)+1;//当前页码 //console.log(param); //ajax请求数据 $.ajax({ type: "POST", url: "/payment/result", cache: false, //禁用缓存 data: param, //传入组装的参数 dataType: "json", success: function (result) { //封装返回数据 var returnData = {}; returnData.draw = data.draw;//这里直接自行返回了draw计数器,应该由后台返回 returnData.recordsTotal = result.totalCount;//返回数据全部记录 returnData.recordsFiltered = result.totalCount;//后台不实现过滤功能，每次查询均视作全部结果 returnData.data = result.payment;//返回的数据列表 //调用DataTables提供的callback方法，代表数据已封装完成并传回DataTables进行渲染 //此时的数据需确保正确无误，异常判断应在执行此回调前自行处理完毕 callback(returnData); } }); }, //列表表头字段 columns: [ { className: "center", orderable : false, bSortable : false, data : "_id", render : function(data, type, row, meta) { var content = '&lt;label class="position-relative">'; content += '&lt;input type="checkbox" class="ace" value="' + data + '" />'; content += '&lt;span class="lbl">&lt;/span>'; content += '&lt;/label>'; return content; } }, { "data": "type", render:function(date,type,full) { var content = null; if(date == 1) { content = '收入'; } else { content = '支出'; } return content; } }, { "data": "name" }, { "data": "price" }, { "data": "product_type" }, { "data": "meta.createAt", render:function(date,type,full) { return date.slice(0,10); } }, { bSortable : false, visible : true, data : "_id", render : function(data, type, full) { var content = '&lt;div class="hidden-sm hidden-xs action-buttons">'+ '&lt;a href="/payment/detail/' + data + '" class="blue">'+ '&lt;i class="ace-icon fa fa-search-plus bigger-130">&lt;/i>'+ ' &lt;/a>'+ '&lt;a href="javascript:void(0);" data-id="' + data + '" class="delete_btn red">'+ '&lt;i class="ace-icon fa fa-trash-o bigger-130">&lt;/i>'+ '&lt;/a>'+ '&lt;/div>'+ '&lt;div class="hidden-md hidden-lg">'+ ' &lt;div class="inline position-relative">'+ ' &lt;button data-toggle="dropdown" data-position="auto" class="btn btn-minier btn-yellow dropdown-toggle">&lt;i class="ace-icon fa fa-caret-down icon-only bigger-120">&lt;/i>&lt;/button>'+ '&lt;ul class="dropdown-menu dropdown-only-icon dropdown-yellow dropdown-menu-right dropdown-caret dropdown-close">'+ ' &lt;li>&lt;a href="/payment/detail/' + data + '" data-rel="tooltip" title="" data-original-title="View" class="tooltip-info">&lt;span class="blue">&lt;i class="ace-icon fa fa-search-plus bigger-120">&lt;/i>&lt;/span>&lt;/a>'+ '&lt;li>&lt;a data-rel="tooltip" title="" data-original-title="Delete" data-id="' + data + '" class="delete_btn tooltip-error">&lt;span class="red">&lt;i class="ace-icon fa fa-trash-o bigger-120">&lt;/i>&lt;/span>&lt;/a>&lt;/li>'+ '&lt;/ul>&lt;/div>&lt;/div>'; return content; } } ] }).api(); //此处需调用api()方法,否则返回的是JQuery对象而不是DataTables的API对象 });]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[moment]]></title>
    <url>%2F2016%2F12%2F11%2Fmoment%2F</url>
    <content type="text"><![CDATA[首先，好久没有来多博客了 今天在学习MongoDB时，需要格式化时间，上网查了一下，nodejs中的moment模块可以格式化时间。首先，mongodb中有一个字段是Date类型需要一个默认值，就是当前时间，可以使用以下代码来格式化时间 moment().format('YYYY-MM-DD HH:mm:ss') 使用以下代码也是可以的 moment(Date.now()).format('YYYY-MM-DD HH:mm:ss') 目前只使用这两个方法，以后再来补充——————————————————分割线———————————-在存入数据库时，我已经格式化日期了，取出来发现是没有格式的数据，很纳闷，不知道原因，找到了解决办法。express我是用的jade模板，在app.js中加入 app.locals.moment = require('moment') 在jade中读取日期数据使用 #{moment(friend.createTime).format('YYYY-MM-DD HH:mm:ss')} 取出来的日期是格式化的]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[useMongoDB]]></title>
    <url>%2F2016%2F12%2F11%2FuseMongoDB%2F</url>
    <content type="text"><![CDATA[最近在学习mongdb 以下是使用mongoose模块来保存数据 var mongoose = require('mongoose'); var moment = require('moment'); // 连接字符串格式为mongodb://主机/数据库名 mongoose.connect('mongodb://localhost/test'); var db = mongoose.connection; //输出连接日志 db.on('error', function callback() { console.log("Connection error"); }); db.once('open', function callback() { console.log("Mongo working!"); }); // 创建schema var Schema = mongoose.Schema; var userSchema = new Schema({ name: String, age: Number, createTime: { type: Date, default: moment().format('YYYY-MM-DD HH:mm:ss') }, updateTime: { type: Date, default: moment().format('YYYY-MM-DD HH:mm:ss') }, telphone: String }); // 构建model var User = mongoose.model('User', userSchema); //构建model实例 var userData = new User({ name: 'root', age: 21, telphone: '18766560229' }); // 保存数据 userData.save(function(err) { if (err) { console.log(err) } else { console.log('Save success'); } }) 还有，输出信息有以下信息：(node:7780) DeprecationWarning: Mongoose: mpromise (mongoose’s default promise library) is deprecated, plug in your own promise library instead: http://mongoosejs.com/docs/promises.html也不不知道是什么意思，需要补充]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ngInterpolate]]></title>
    <url>%2F2016%2F09%2F17%2FngInterpolate%2F</url>
    <content type="text"><![CDATA[$interpolate服务返回一个函数，用来在特定的上下文中运算表达式。示例：html代码： &lt;div ng-controller="myController"> &lt;input ng-model="to" type="email" placeholder="email" /> &lt;textarea ng-model="emailBody">&lt;/textarea> &lt;pre>{{previewText}}&lt;/pre> &lt;/div> js代码： angular.module('myApp', []) .controller('myController',['$scope','$interpolate', function($scope,$interpolate) { $scope.$watch('emailBody',function(body) { if(body) { var template = $interpolate(body); $scope.previewText = template({to:$scope.to}) } }) } ]) 使用：在输入框中输入你的email地址，在文本框中输入，previewText中的值即为to的值]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java1]]></title>
    <url>%2F2016%2F07%2F20%2Fjava1%2F</url>
    <content type="text"><![CDATA[Java已经忘了差不多了，最近又需要重新捡起Java。对于一副扑克牌共有54张，扑克牌洗牌就是将这54张牌没有规律的输出出来，用ArrayList实现，本质是54个数的随机输出，穿了身衣服，输出出来就好看多了 public class Poker { public static String poker(int num) { String str = ""; String[] huase = {"红桃","黑桃","梅花","方块"}; String[] number = {"A","2","3","4","5","6","7","8","9","10","J","Q","K"}; if(num/4 > 12) { if(num%4 == 0) { str += "小鬼"; } else if(num%4 == 1) { str += "大鬼"; } } else { str += huase[num%4] + number[num/4] ; } return str; } } public class Client { public static void main(String[] args) { // 定义变量 ArrayList list = new ArrayList(); Random random = new Random(); Poker poker = new Poker(); int i = 0; // 向数组中增加数字 for(i=0;i&lt;54;i++) { list.add(poker.poker(i)); } // 随机输出数组中的每个数字 int length = list.size(); for(i=0;i&lt;length;i++) { //随机生成数组下标 int num = random.nextInt(list.size()); //取出数字 System.out.println(list.get(num)); //将数字从数组中移除 list.remove(num); } } } 看起来舒服多了]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-margin]]></title>
    <url>%2F2016%2F07%2F16%2Fcss-margin%2F</url>
    <content type="text"><![CDATA[今天在慕课上看了张大神又一力作，整理了一下margin的巧妙使用：1、margin实现自适应的宽高比为2：1的矩形 &lt;div id=&quot;container&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;style type=&quot;text/css&quot;&gt; #container { width: 400px; height: 250px; } .box { background-color: olive; overflow: hidden; } .box &gt; div { margin: 50%; } &lt;/style&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
</search>
